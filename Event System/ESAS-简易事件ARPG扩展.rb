#==============================================================================
# ■ 简易事件ARPG扩展 by 老鹰（http://oneeyedeagle.lofter.com/）
#==============================================================================
$imported ||= {}
$imported["EAGLE-ESAS"] = true
#==============================================================================
# - 2022.2.4.22
#==============================================================================
# - 本插件新增一系列方便事件脚本调用的方法，用于创作简易ARPG
#--------------------------------------------------------------------------
# ○ 前言
#--------------------------------------------------------------------------
# - 使用本插件需要一部分脚本知识，比如需要知道最基础的字符串、数组是什么
# - 还需要一些RGSS的基础认识，如知道地图上的事件，其数据存储在Game_Event对象中
#   同时可以通过 $game_map.events[id] 获取指定id序号的事件
# - 本插件核心在于各个时机增加对指定事件页的（并行）调用
#--------------------------------------------------------------------------
# 【注意】
# - 对于本插件的新增脚本
#     标注了【全局】的可以在任意地方使用
#     标注了【地图】的可以在地图上时使用（即开启菜单时就不可以用了）
#     标注了【事件】的必须在事件脚本中使用
#--------------------------------------------------------------------------
#
#=============================================================================
# ○ 核心 - 事件页执行扩展
#=============================================================================
# - 本插件的核心思想是增加在各个时机执行指定事件页的方式
# - 由于事件自身机制优秀，可视化的编辑也更加方便，
#    因此本插件尽量保证结合事件指令来达成目的，
#    而对于事件脚本，也新增了报错捕捉，确保能快速DEBUG
#--------------------------------------------------------------------------
#  @esas
#
#  【事件】当事件页是在ESAS相关功能中（具体的，就是下述注释中出现的功能）被调用时，
#         事件指令-脚本中才会存在的变量
#         （具体见 Process_Event_Data 类）
#
#  在ESAS事件脚本中，新增了下列可读取的数据：
#    @esas.mid 获取当前执行事件页所在的地图ID
#    @esas.eid 获取当前执行事件页所在的事件ID
#    @esas.pid 获取当前执行事件页的页码ID
#    @esas.chara 获取当前事件页的调用来源角色
#             比如：由玩家绑定的按键触发的当前事件页，该变量值为 $game_player
#             比如：由 $game_map.events[1].run_event() 调用的当前事件页，
#                  该变量值为 $game_map.events[1]
#             比如：由动画播放时调用的当前事件页，该变量值为动画的调用来源
#    @esas.x
#    @esas.y 获取来源角色位于地图上的坐标
#             比如：由动画播放时调用的当前事件页，则为动画所在的地图坐标
#
#--------------------------------------------------------------------------
#  chara.run_event(params)
#
#  【地图】以事件/角色为【本事件】，执行指定事件页（并行处理）
#
#     注意：通过该方法，每个角色同时只会执行一个事件页，
#          若旧的事件页还未执行完，再次调用时将尝试强制终止，并开始执行新事件页
#
#    chara → Game_Character类及其子类的对象
#          可以用 chara = ESAS.get_chara(chara_id) 获取
#          其中 chara_id 为 -1 时代表玩家，正数时代表对应ID事件的对象
#
#    params → 存储一系列执行信息的哈希表
#       :mid → 所要执行的事件页的地图ID（若不传入或传入0，则为当前地图）
#               （若传入 -1，则为公共事件，且 :pid 无效）
#       :eid → 所要执行的事件页的事件ID
#       :pid → 所要执行的事件页的页号（若不传入或传入0，则取符合出现条件的最大页）
#       :abort → 是否可以强制终止，默认 true
#                若设置为 false ，则会保证必定执行完，中途的其余事件页调用都被取消
#
#     若使用了【事件互动扩展 by老鹰】，新增如下设置：
#       :sym → 仅调用事件页中的对应名称的互动，而不执行整页
#
#      此外，可以传入【事件互动扩展 by老鹰】的tags格式字符串来进行params设置：
#        如 chara.run_event("mid=1 abort=false")
#
# - 示例：
#    事件脚本：chara = ESAS.get_chara(1) # 获取1号事件对象
#             ps = { :mid => 2, :eid => 2 } # 设置调用2号地图2号事件第1页
#             ps[:abort] = false # 设置不允许强制终止
#             chara.run_event(ps) # 并行调用事件页（当前事件继续执行之后的指令）
#
# - 高级：
#    chara.esas_running? → 角色是否存在正在执行run_event调用的事件页
#    chara.esas_abort(n) → 打断角色正在执行的run_event事件页，
#                          若成功，给角色增加n帧硬直
#                 （硬直期间角色无法移动、无法利用 chara.run_event 触发esas事件）
#
#--------------------------------------------------------------------------
#  chara.freeze(n)
#
#  【地图】给角色设置持续 n 帧的硬直，
#         期间角色无法行动，无法触发它的 chara.run_event() 方法，
#         在 n 帧后将会自动解除该硬直状态
#
#    n → 若不传入或传入 0，则不限制持续时间
#
#  chara.unfreeze
#
#  【地图】解除角色硬直
#
# - 高级：
#    chara.freeze? → 角色正处于硬直？
#
#--------------------------------------------------------------------------
#  chara.no_esas(n)
#
#  【地图】给角色设置持续 n 帧的无敌，期间角色不可被 esas_iter 响应事件指令，
#         即事件中通过事件脚本 esas_iter(ids) 迭代事件时，该chara事件将被跳过，
#         在 n 帧后将会自动解除该无敌状态
#
#    n → 若不传入或传入 0，则不限制持续时间
#
#  chara.re_esas
#
#  【地图】解除角色无敌
#
# - 高级：
#    chara.no_esas? → 角色正处于无敌？
#
#--------------------------------------------------------------------------
# - 玩家按键触发事件页
#
#    $game_player.set_key(key, params)
#
#      【全局】给玩家绑定按键触发的事件页
#
#       key → 设置绑定按键，当按下对应按键时，自动执行一次事件页
#             与 Input 模块中所响应的键值Symbol保持一致
#       params → 要调用的事件页的信息，同 chara.run_event 中的params
#
#    $game_player.call_key(key)
#
#      【全局】直接调用一次按键所绑定的事件页
#
# - 高级：
#    $game_player.esas_running? → 角色是否存在正在执行的事件页（含按键触发的）
#    $game_player.esas_abort(n) → 打断角色正在执行的事件页（含按键触发的），
#                                若有任意一个打断成功，给角色增加n帧硬直
#
# - 示例：
#    事件脚本：$game_player.set_key(:A, {:mid => 0, :eid => 1, :pid => 2})
#     → 当玩家按下Shift键时，调用当前地图1号事件的第2页，将并行执行
#        请在事件页中设置玩家的禁止移动等
#
#--------------------------------------------------------------------------
# - 绑定事件页并行
#
#    在事件页的开头第一个指令为注释的情况下，在注释中编写
#
#       <esas mid eid pid>
#
#    可以指定该事件页符合条件并显示时，同步开始并行执行的事件页，
#      其中的【本事件】全部被替换为当前事件。
#
#    若使用了【事件互动扩展 by老鹰】，则可以编写tags字符串，并新增sym设置：
#       <esas mid=1 eid=2 pid=0 sym=互动>
#      来便捷编写所绑定的事件页，或者具体设置所触发的事件页中的互动。
#
#    当本事件被按键/接触触发时，绑定的事件页也暂停执行。
#
# - 示例：
#     1号事件的第2页开头注释中填写了 <esas 0 2 1>
#     当事件的第2页符合出现条件并显示时，同步开始并行执行当前地图2号事件的第1页
#     并且执行过程中的【本事件】均为 1号事件
#
#--------------------------------------------------------------------------
#
#=============================================================================
# ○ 模块 - 动画
#=============================================================================
# - 动画播放是非常常用的一项功能，在动画播放中途，也应该能够并行执行事件页
#   本插件扩展了动画播放相关方式
#--------------------------------------------------------------------------
#  ESAS.anim_map(anim_id, x, y, params)
#
#  【地图】在地图上指定位置播放动画
#
#    anim_id → 数据库中对应动画的ID
#              请提前设置动画的x坐标偏移值 16，y坐标偏移值0，以对齐格子底部中心播放
#    x, y → 地图上的坐标（与编辑器中一致）
#    params → 设置具体帧播放时，需要调用的事件页 {帧序号 => 事件页params}
#             同时可以传入 :chara_id => id 来存储动画的来源角色id
#             比如 { 5 => {:mid=>1,:eid=>2,:pid=>1}, :chara_id => -1 }
#             代表当前动画第 5 帧时执行1号地图2号事件第1页，且来源为玩家
#
# （若使用了【像素级移动 by老鹰】）
#  ESAS.anim_map_pixel(anim_id, px, py, params)
#
#  【地图】在地图上指定位置播放动画
#
#    x, y → 地图上的移动单位坐标
#
#
#  ESAS.anim_event(anim_id, chara_id, params)
#
#  【地图】在指定事件上指定位置播放动画
#
#    chara_id → -1时代表玩家，正数代表对应事件
#
#
# - 示例：
#    事件脚本：ps = { 2 => {:mid => -1, :eid => 2} } # 设置第2帧时调用2号公共事件
#             ps[:chara_id] = 1 # 设置调用来源为1号事件
#             ESAS.anim_map(112, 6, 9, ps) # 并行显示112号动画
#
#--------------------------------------------------------------------------
#
#=============================================================================
# ○ 模块 - 目标获取
#=============================================================================
# - 对于ARPG，能够获取角色面前指定范围内的全部目标是非常关键的一件事
#   本插件引入了一个完整的模块用于处理目标的获取
#--------------------------------------------------------------------------
# - 范围数组
#     本插件使用最基础的一维数组[x,y]来表示坐标，使用坐标的数组来保存范围
#
# - 范围数组的约定：
#     范围设置时，角色朝向右，且角色位于(0,0)处，向右为x正方向，向下为y正方向
#
# - 示例：（黑色方块为角色，空心方块为范围）
#      □
#    ■□□   → 该范围数组为 arr = [ [1,0], [2,0], [1,-1], [1,1] ]
#      □
#
# - 示例：
#   □□■□□   → 该范围数组为 arr = [ [-2,0], [-1,0], [1,0], [2,0], [0,1] ]
#       □
#--------------------------------------------------------------------------
# - 兼容
#
#    如果使用了【像素级移动 by 老鹰】，则需要注意，此处传入的依然为RGSS中的坐标，
#    但 $game_player.x 获取的是 移动单位坐标！
#
#--------------------------------------------------------------------------
#  xys = ESAS.range_xys(chara_id, arr)
#
#  【全局】传入角色ID和范围数组，返回实际在地图上的坐标的数组
#
#     chara_id → -1 代表玩家，正数代表事件ID
#     arr → 范围数组
#
# - 示例：
#    玩家位于地图的(5,3)处，朝向右
#      xys = ESAS.range_xys(-1, [[1,0], [2,0]])
#    则 xys = [ [6,3], [7,3] ]
#
#--------------------------------------------------------------------------
#  xys = ESAS.range_xys(x, y, direction, arr)
#
#  【全局】传入地图位置(x,y)和朝向和范围数组，返回实际在地图上的坐标的数组
#
#     x,y → 地图上的坐标，和编辑器中显示的保持一致
#     direction → 朝向（2朝下，4朝左，6朝右，8朝上）
#     arr → 范围数组
#
# - 示例：
#    在地图的(5,3)处，朝向右
#      xys = ESAS.range_xys(5,3, 6, [[1,0], [2,0]])
#    则 xys = [ [6,3], [7,3] ]
#
#--------------------------------------------------------------------------
#  ids = ESAS.range_ids(xys, type)
#
#  【全局】传入地图坐标数组和索引范围，返回位于这些坐标内的角色的ID数组
#
#     xys → 地图上实际坐标的数组
#     type → :party 代表只检索我方角色，:enemy 代表只检索敌方角色
#            :all 代表全部角色都会检索，若不传入，则检索敌方角色
#     ids → 被检索到的角色的ID的数组（其中-1代表玩家，正数代表对应ID的事件）
#           注意：无图像 且 当前激活的事件页无任何指令 的事件将会被跳过
#
# - 示例：
#    承上，在地图的(6,3)处存在3号事件，在(7,3)处存在5号事件，在(8,3)处存在2号事件
#      ids = ESAS.range_ids(xys)
#    则 ids = [ 3, 5 ]
#
#--------------------------------------------------------------------------
#  ids = ESAS.select_ids(ids, sym)
#
#  【全局】传入角色ID数组和筛选条件，返回符合条件的ID数组
#
#     sym →
#       若 sym 为符号，则事件/角色名字需含有该字符串
#              比如 ESAS.select_ids(ids, :<NPC>) ，就筛选出名称含有 <NPC> 的事件
#       若 sym 为字符串，则事件当前页第一个指令为注释，注释中需含有该字符串，
#              或角色数据库备注栏中需含有该字符串
#       若 sym 为数组，则每一项为字符串，且事件/角色需要在eval后全部返回 true
#              可用 s 代表开关组，v 代表变量组，e代表当前判定的事件/角色对象
#                  es 代表当前地图的事件组， pl 代表玩家
#              比如 ESAS.select_ids(ids,
#                        ["(pl.x - e.x).abs < 2", "(pl.y - e.y).abs < 2"] )
#              会筛选出和玩家x、y距离均小于2格的事件，并返回它们的ID的数组
#
# - 示例：
#    承上，3号事件名称为 "事件<npc>"， 5号事件名称为 "事件<enemy>"
#      ids = ESAS.select_ids(ids, :<enemy>)
#    则 ids = [ 5 ]
#
#--------------------------------------------------------------------------
#
#=============================================================================
# ○ 模块 - 事件迭代
#=============================================================================
# - 在目标获取中，我们获得了在指定范围内的事件ID的数组，
#   但是在事件中并不好对这些事件进行处理
#   因此本插件对默认的事件编辑器进行了扩展，使其能够在一个事件页中对其他事件进行处理
#--------------------------------------------------------------------------
#  esas_iter(ids)
#
#  【事件】开始对角色ID数组中的事件迭代，之后事件指令的【本事件】将替换为被迭代事件
#
#  esas_iter_end
#
#  【事件】结束事件的迭代区域，若未迭代完，则回到迭代开头继续
#
# - 示例：当前事件为 2 号事件
#    | 事件脚本：esas_iter( [1,3] )
#    | 独立开关：A开启
#    | 显示动画：本事件，1号动画
#    | 事件脚本：esas_iter_end
#    | 独立开关：A开启
#
#    则 依次对1号事件和3号事件进行处理：
#         先开启1号事件的独立开关A，在1号事件上面显示1号动画，
#         再开启3号事件的独立开关A，在3号事件上面显示1号动画，
#      最后开启当前事件（2号事件）的独立开关A
#
#--------------------------------------------------------------------------
#
#=============================================================================
# ○ 模块 - POP
#=============================================================================
# - 为了让ARPG能更加生动，伤害数字等信息文本的显示也不可或缺
#   本插件新增了扩展性较强的气泡文本显示模块，能够轻松增加任意弹出文本
#--------------------------------------------------------------------------
#  ESAS.new_pop(params)
#
#  【全局】生成一个立即显示，然后消失的气泡文本，
#
#     params → 各种参数的Hash
#        :text => 需要绘制的文本（单行，不可含转义符）
#        :cid => 绑定显示的角色ID（-1为玩家，正数为事件）
#        :type => 显示模式（:zoom 放大并淡出，:bounce 弹跳并淡出）
#        :w / :h => 精灵宽度、高度
#        :size => 字体大小
#        :color => 字体颜色的索引号
#
# - 示例：
#    在玩家行走图上显示 10 的文本
#      ESAS.new_pop( {:cid => -1, :text => "10"} )
#
# - 若使用了【事件互动扩展 by老鹰】，则可以编写tags字符串进行设置：
#
#      ESAS.new_pop( "text=miss cid=-1 color=17" )
#
#--------------------------------------------------------------------------
#
#=============================================================================
# ○ 模块 - 扩展
#=============================================================================
# - 此处放一些稀奇古怪的扩展功能
#   全部是基于给 Game_Character 类新增的 tmp 变量（Hash结构）
#   你也可以通过调用 chara.tmp 获取这个哈希变量，并且任意对其中的值进行修改
#--------------------------------------------------------------------------
# - 显示HP
#    为地图上的事件绑定了一个非常简单的HP血条精灵
#
#    利用 chara.hp = v 初始化事件的HP，同时将会在事件底部显示一个血条
#    对 chara.hp 进行操作的同时，将会直观反映到血条图像的增减上
#    （注意，并不包含POP，请自己增加POP的事件脚本）
#
# - 示例：
#    事件脚本：chara.hp = 10 # 初始化HP为 10
#    事件脚本：chara.hp -= 5 # 减少 5 点HP
#
# - 高级：
#     chara.tmp[:hp_max] 存储了初始化时的HP值，并且将被作为HP上限进行绘制
#                       （但并不会对hp值的更改进行限制）
#     chara.tmp[:hp_draw] 存储了当前被绘制的HP值
#
#=============================================================================

#=============================================================================
# ○ 设置
#=============================================================================
module ESAS
  #=============================================================================
  # ○【设置】常量
  #=============================================================================
  # 当开关开启时，禁止事件的自主移动（移动路线指令不受影响）
  S_ID_NO_EVENT_MOVE = 0

  # 当开关开启时，禁止玩家的按键移动
  S_ID_NO_PLAYER_MOVE = 0
end

#=============================================================================
# ○ 通用
#=============================================================================
module ESAS
  #--------------------------------------------------------------------------
  # ● 执行eval
  #--------------------------------------------------------------------------
  def self.eval(str, params = {})
    s = $game_switches; v = $game_variables
    e = params[:event]; es = $game_map.events
    pl = $game_player
    begin
      eval(str)
    rescue
      p "在执行ESAS中的eval时发生错误！"
      p " - 报错信息：#{$!}"
      p " - 扩展信息：" + params[:log] if params[:log]
      return false
    end
  end
  #--------------------------------------------------------------------------
  # ● 获取指定行走图角色的对象
  #--------------------------------------------------------------------------
  def self.get_chara(id = -1)
    if id == -1
      return $game_player
    elsif id > 0
      return $game_map.events[id]
    elsif id < 0
      return $game_player.followers[id.abs - 2]
    end
  end
  #--------------------------------------------------------------------------
  # ● 获取指定行走图角色的精灵
  #--------------------------------------------------------------------------
  def self.get_chara_sprite(id = -1)
    if SceneManager.scene_is?(Scene_Map)
      charas_s = SceneManager.scene.spriteset.character_sprites
      chara = get_chara(id)
      charas_s.each { |s| return s if s.character == chara }
    end
    return nil
  end
  #--------------------------------------------------------------------------
  # ● 获取指定事件页的指令列表
  # （参数均与编辑器中显示的数字保持一致）
  #--------------------------------------------------------------------------
  def self.get_event_list(map_id, event_id, page_id = nil)
    event = nil
    map_id = $game_map.map_id if map_id.nil? || map_id == 0
    # 公共事件
    if map_id < 0
      event = $data_common_events[event_id]
      return event.list
    end
    # 地图上的事件
    if map_id != $game_map.map_id
      map = ESAS.get_map_data(map_id)
      event_data = map.events[event_id] rescue return
      return if event_data == nil
      event = Game_Event.new(map_id, event_data)
    else
      event = $game_map.events[event_id] rescue return
    end
    page = nil
    if page_id == nil || page_id == 0
      page = event.find_proper_page
    else
      page = event.event.pages[page_id-1] rescue return
    end
    return page.list
  end
  #--------------------------------------------------------------------------
  # ● 获取地图数据
  #--------------------------------------------------------------------------
  def self.get_map_data(map_id)
    EAGLE.cache_load_map(map_id)
  end
end
#=============================================================================
# ○ EAGLE - Cache
#=============================================================================
module EAGLE
  #--------------------------------------------------------------------------
  # ● 读取地图
  #--------------------------------------------------------------------------
  def self.cache_load_map(map_id)
    @cache_map ||= {}
    return @cache_map[map_id] if @cache_map[map_id]
    @cache_map[map_id] = load_data(sprintf("Data/Map%03d.rvdata2", map_id))
    @cache_map[map_id]
  end
  #--------------------------------------------------------------------------
  # ● 清空缓存
  #--------------------------------------------------------------------------
  def self.cache_clear
    @cache_map ||= {}
    @cache_map.clear
    GC.start
  end
end
#==============================================================================
# ■ 【读取部分】
#==============================================================================
module EAGLE
  #--------------------------------------------------------------------------
  # ● 读取事件页开头的注释组
  #--------------------------------------------------------------------------
  def self.event_comment_head(command_list)
    return "" if command_list.nil? || command_list.empty?
    t = ""; index = 0
    while command_list[index].code == 108 || command_list[index].code == 408
      t += command_list[index].parameters[0]
      index += 1
    end
    t
  end
end

#=============================================================================
# ○ 更新
#=============================================================================
module ESAS
  #--------------------------------------------------------------------------
  # ● 每帧更新
  #--------------------------------------------------------------------------
  def self.update
    update_anims
    update_pops
  end
end
class Scene_Base
  #--------------------------------------------------------------------------
  # ● 绑定每帧更新
  #--------------------------------------------------------------------------
  alias eagle_esas_scenebase_update_basic update_basic
  def update_basic
    eagle_esas_scenebase_update_basic
    ESAS.update
  end
end

#=============================================================================
# ○ 核心设置 - 执行指定事件页
#=============================================================================
module ESAS
  #--------------------------------------------------------------------------
  # ● 管理事件页执行的类
  #--------------------------------------------------------------------------
  class Process_Event
    attr_reader   :params, :data
    #--------------------------------------------------------------------------
    # ● 初始化
    #--------------------------------------------------------------------------
    def initialize(params = {}, params_data = {})
      reset(params)
      reset_data(params_data)
      @interpreter = Game_Interpreter.new(1)
    end
    #--------------------------------------------------------------------------
    # ● 重置
    #--------------------------------------------------------------------------
    def reset(params)
      @params = params
      #@params[:mid] ||= nil # 设置指定事件页的位置 - 地图ID
      #@params[:eid] ||= nil  # 事件ID
      #@params[:pid] ||= nil  # 事件页ID（与编辑器中一致）
      @params[:abort] ||= true # 是否可以被强制中止
      #@params[:key] ||= nil # 按键呼叫（玩家用）
      @params[:enable] ||= true # 是否可以按键
      @params[:active] = false # 是否已经在执行
      @params[:repeat] ||= false #是否自动循环执行（在执行run后，自动循环）
    end
    #--------------------------------------------------------------------------
    # ● 重置数据
    #--------------------------------------------------------------------------
    def reset_data(params)
      @data = Process_Event_Data.new
      @params.each do |k, v|
        @data.method("#{k}=").call(v) rescue nil
      end
      params.each do |k, v|
        @data.method("#{k}=").call(v) rescue nil
      end
    end
    #--------------------------------------------------------------------------
    # ● 开始执行
    #--------------------------------------------------------------------------
    def run
      list = ESAS.get_event_list(@params[:mid], @params[:eid], @params[:pid])
      return if list.nil?
      @params[:active] = true
      @interpreter.bind_esas(@data)
      event_id = 0
      event_id = @data.chara.id if @data.chara
      @interpreter.setup(list, event_id)
      if $imported["EAGLE-EventInteractEX"]
        @interpreter.event_interact_search(@params[:sym]) if @params[:sym]
      end
    end
    #--------------------------------------------------------------------------
    # ● 在更新？
    #--------------------------------------------------------------------------
    def running?
      @interpreter.running?
    end
    #--------------------------------------------------------------------------
    # ● 终止事件
    #--------------------------------------------------------------------------
    def abort
      return false if !@params[:abort]
      @interpreter.clear
      return true
    end
    #--------------------------------------------------------------------------
    # ● 每帧更新
    #--------------------------------------------------------------------------
    def update
      @interpreter.update
      f = running?
      run if @params[:repeat] && @params[:active] && !f
      @params[:active] = f
      update_key if @params[:key]
    end
    #--------------------------------------------------------------------------
    # ● 更新按键判定
    #--------------------------------------------------------------------------
    def update_key
      return if @params[:active]
      run if @params[:enable] && Input.trigger?(@params[:key])
    end
  end
  #--------------------------------------------------------------------------
  # ● 存储事件页执行环境等信息的类
  #  用于传递给 Game_Interpreter类中使用
  #--------------------------------------------------------------------------
  class Process_Event_Data
    attr_accessor :mid, :eid, :pid, :chara, :x, :y
    def initialize
      @mid = @eid = @pid = nil
      @chara = nil  # 如果来源为 行走图角色 就存储Game_Character对象
      @x = @y = nil # 当前处理所在的地图位置，当来源为动画时，需要靠其获得显示位置
    end
  end
end

class Game_Interpreter
  attr_reader :esas, :event_id
  #--------------------------------------------------------------------------
  # ● 绑定信息类
  #--------------------------------------------------------------------------
  def bind_esas(data)
    @esas = data
  end
  #--------------------------------------------------------------------------
  # ● 脚本
  #--------------------------------------------------------------------------
  alias eagle_esas_command_355 command_355
  def command_355
    begin
      eagle_esas_command_355
    rescue
      p "#{@map_id}号地图#{@event_id}号事件第#{@index+1}行指令eval出错！"
      p " - 报错信息：#{$!}"
      if @esas_iter_ids
        p " - 出错指令位于 esas_iter 与 esas_iter_end 的范围内！"
      end
      if @esas
        p " - 当前出错事件是 ESAS 所执行的事件页！"
        p "  - 谁造成了这次调用：#{@esas.chara.id}（-1为玩家，正数为对应事件）" if @esas.chara
        p "  - 谁实际进行这次调用：#{self.event_id}（-1为玩家，正数为对应事件）"
        p "  - 被调用的事件页：#{@esas.mid}号地图#{@esas.eid}号事件第#{@esas.pid}页"
        p "  - 报错的指令行数：#{@index+1}"
      end
      return false
    end
  end
end

class Game_CharacterBase
  attr_reader :tmp
  #--------------------------------------------------------------------------
  # ● 初始化公有成员变量
  #--------------------------------------------------------------------------
  alias eagle_esas_charabase_init_public_members init_public_members
  def init_public_members
    eagle_esas_charabase_init_public_members
    init_esas_members
  end
  #--------------------------------------------------------------------------
  # ● 初始化ESAS变量
  #--------------------------------------------------------------------------
  def init_esas_members
    @tmp = {}
    @freeze = false
    @freeze_count = 0
    @no_esas = false
    @no_esas_count = 0
  end
  #--------------------------------------------------------------------------
  # ● 冻结/硬直/阻止自身发起的ESAS处理
  #--------------------------------------------------------------------------
  def freeze(count = 0)
    @freeze = true
    @freeze_count = count if count > 0
  end
  #--------------------------------------------------------------------------
  # ● 冻结/硬直？
  #--------------------------------------------------------------------------
  def freeze?
    @freeze
  end
  #--------------------------------------------------------------------------
  # ● 解冻
  #--------------------------------------------------------------------------
  def unfreeze
    @freeze = false
  end
  #--------------------------------------------------------------------------
  # ● 开始无敌帧/阻止受到的ESAS处理
  #--------------------------------------------------------------------------
  def no_esas(count = 0)
    @no_esas = true
    @no_esas_count = count if count > 0
  end
  #--------------------------------------------------------------------------
  # ● 无敌帧中？
  #--------------------------------------------------------------------------
  def no_esas?
    @no_esas
  end
  #--------------------------------------------------------------------------
  # ● 无敌帧结束
  #--------------------------------------------------------------------------
  def re_esas
    @no_esas = false
  end
  #--------------------------------------------------------------------------
  # ● 每帧更新
  #--------------------------------------------------------------------------
  alias eagle_esas_charabase_update update
  def update
    update_freeze_count
    update_no_esas_count
    eagle_esas_charabase_update
  end
  #--------------------------------------------------------------------------
  # ● 更新冻结倒计时
  #--------------------------------------------------------------------------
  def update_freeze_count
    return if @freeze_count <= 0
    @freeze_count -= 1
    unfreeze if freeze? && @freeze_count == 0
  end
  #--------------------------------------------------------------------------
  # ● 更新无敌帧倒计时
  #--------------------------------------------------------------------------
  def update_no_esas_count
    return if @no_esas_count <= 0
    @no_esas_count -= 1
    re_esas if no_esas? && @no_esas_count == 0
  end
end

class Game_Character < Game_CharacterBase
  attr_reader :esas_event
  #--------------------------------------------------------------------------
  # ● 获取名称
  #--------------------------------------------------------------------------
  def name
    ""
  end
  #--------------------------------------------------------------------------
  # ● 获取注释
  #--------------------------------------------------------------------------
  def note
    ""
  end
  #--------------------------------------------------------------------------
  # ● 初始化ESAS变量
  #--------------------------------------------------------------------------
  def init_esas_members
    super
    data = { :chara => self, :x => self.x, :y => self.y }
    @esas_event = ESAS::Process_Event.new({}, data)
  end
  #--------------------------------------------------------------------------
  # ● 执行ESAS的事件
  #--------------------------------------------------------------------------
  def run_event(params)
    return if freeze?
    if @esas_event.running?
      return if !@esas_event.abort # 不可以强制中止，就取消当前事件的执行
    end
    if params.is_a?(String) && $imported["EAGLE-EventInteractEX"]
      params = EAGLE_COMMON.parse_tags(params)
      params[:mid] = params[:mid].to_i if params[:mid]
      params[:eid] = params[:eid].to_i
      params[:pid] = params[:pid].to_i if params[:pid]
      params[:abort] = false if params[:abort] == "false"
    end
    @esas_event.reset(params)
    @esas_event.run
  end
  #--------------------------------------------------------------------------
  # ● 存在ESAS的事件更新？
  #--------------------------------------------------------------------------
  def esas_running?
    @esas_event.running?
  end
  #--------------------------------------------------------------------------
  # ● 终止ESAS的事件更新
  #--------------------------------------------------------------------------
  def esas_abort(count = 0)
    if @esas_event.abort
      freeze(count)
      return true
    end
    return false
  end
  #--------------------------------------------------------------------------
  # ● 每帧更新
  #--------------------------------------------------------------------------
  def update
    super
    @esas_event.update
  end
  #--------------------------------------------------------------------------
  # ● 冻结
  #--------------------------------------------------------------------------
  def freeze(count = 0)
    super
    # 停止移动
    @move_route_forcing = false
    restore_move_route
  end
  #--------------------------------------------------------------------------
  # ● 空事件？
  #--------------------------------------------------------------------------
  def empty?
    return false
  end
end

class Game_Player < Game_Character
  attr_reader :id, :esas_keys
  #--------------------------------------------------------------------------
  # ● 初始化
  #--------------------------------------------------------------------------
  alias eagle_esas_player_init initialize
  def initialize
    eagle_esas_player_init
    @id = -1
  end
  #--------------------------------------------------------------------------
  # ● 初始化ESAS变量
  #--------------------------------------------------------------------------
  def init_esas_members
    super
    @esas_keys = {}
#~     set_key(:A, {:mid => 1, :eid => 9}) # TEST
  end
  #--------------------------------------------------------------------------
  # ● 获取名称
  #--------------------------------------------------------------------------
  def name
    actor.name
  end
  #--------------------------------------------------------------------------
  # ● 获取注释
  #--------------------------------------------------------------------------
  def note
    actor.note
  end
  #--------------------------------------------------------------------------
  # ● 由方向键移动
  #--------------------------------------------------------------------------
  alias eagle_esas_player_move_by_input move_by_input
  def move_by_input
    return if freeze? || $game_switches[ESAS::S_ID_NO_PLAYER_MOVE]
    eagle_esas_player_move_by_input
  end
  #--------------------------------------------------------------------------
  # ● 每帧更新
  #--------------------------------------------------------------------------
  alias eagle_esas_player_update update
  def update
    eagle_esas_player_update
    update_keys
  end
  #--------------------------------------------------------------------------
  # ● 每帧更新
  #--------------------------------------------------------------------------
  def update_keys
    @esas_keys.each { |key, process| process.update }
  end
  #--------------------------------------------------------------------------
  # ● 玩家存在按键事件执行？
  #--------------------------------------------------------------------------
  def esas_running?
    super || @esas_keys.any? { |key, process| process.running? }
  end
  #--------------------------------------------------------------------------
  # ● 终止玩家的全部按键事件
  #  count 为若打断成功可产生的硬直时间
  #--------------------------------------------------------------------------
  def esas_abort(count = 0)
    f = super(count)
    flag = false
    @esas_keys.each { |key, process|
      flag = true if process.abort
    }
    freeze(count) if flag
    return f || flag
  end
  #--------------------------------------------------------------------------
  # ● 绑定按键对应的事件
  #--------------------------------------------------------------------------
  def set_key(key, params)
    if params.is_a?(String) && $imported["EAGLE-EventInteractEX"]
      params = EAGLE_COMMON.parse_tags(params)
      params[:mid] = params[:mid].to_i if params[:mid]
      params[:eid] = params[:eid].to_i
      params[:pid] = params[:pid].to_i if params[:pid]
      params[:abort] = false if params[:abort] == "false"
    end
    params[:key] = key
    data = { :chara => self, :x => self.x, :y => self.y }
    @esas_keys[key] = ESAS::Process_Event.new(params, data)
  end
  #--------------------------------------------------------------------------
  # ● 呼叫按键对应的事件
  #--------------------------------------------------------------------------
  def call_key(key)
    data = @esas_keys[key]
    data.run if data
  end
end

class Game_Follower < Game_Character
  attr_reader :id
  #--------------------------------------------------------------------------
  # ● 初始化
  #--------------------------------------------------------------------------
  alias eagle_esas_follower_init initialize
  def initialize(member_index, preceding_character)
    eagle_esas_follower_init(member_index, preceding_character)
    @id = -member_index
  end
  #--------------------------------------------------------------------------
  # ● 获取名称
  #--------------------------------------------------------------------------
  def name
    actor.name
  end
  #--------------------------------------------------------------------------
  # ● 获取注释
  #--------------------------------------------------------------------------
  def note
    actor.note
  end
end

class Game_Event < Game_Character
  #--------------------------------------------------------------------------
  # ● 初始化ESAS变量
  #--------------------------------------------------------------------------
  def init_esas_members
    super
    data = { :chara => self, :x => self.x, :y => self.y }
    @esas_ai_event = ESAS::Process_Event.new({}, data)
  end
  #--------------------------------------------------------------------------
  # ● 获取名称
  #--------------------------------------------------------------------------
  def name
    @event.name
  end
  #--------------------------------------------------------------------------
  # ● 获取当前事件页的头部注释
  #--------------------------------------------------------------------------
  def note
    EAGLE.event_comment_head(@list)
  end
  #--------------------------------------------------------------------------
  # ● 冻结
  #--------------------------------------------------------------------------
  def freeze(count = 0)
    super
    # 停止事件触发
    @locked = true
  end
  #--------------------------------------------------------------------------
  # ● 解冻
  #--------------------------------------------------------------------------
  def unfreeze
    super
    @locked = false
  end
  #--------------------------------------------------------------------------
  # ● 自动移动的更新
  #--------------------------------------------------------------------------
  alias eagle_esas_event_update_self_movement update_self_movement
  def update_self_movement
    return if esas_running?
    return if freeze? || $game_switches[ESAS::S_ID_NO_EVENT_MOVE]
    eagle_esas_event_update_self_movement
  end
  #--------------------------------------------------------------------------
  # ● 事件启动
  #--------------------------------------------------------------------------
  alias eagle_esas_event_start start
  def start
    return if freeze? || esas_running?
    eagle_esas_event_start
  end
  #--------------------------------------------------------------------------
  # ● 当前位于空事件页？
  #  事件指令列表为空 且 事件图像为空
  #--------------------------------------------------------------------------
  def esas_empty?
    return true if @erased
    if @page.nil? || (@page.list.size == 1 && @page.graphic.character_name == "")
      return true
    end
    return false
  end
  #--------------------------------------------------------------------------
  # ● 设置事件页
  #--------------------------------------------------------------------------
  alias eagle_esas_event_setup_page_settings setup_page_settings
  def setup_page_settings
    eagle_esas_event_setup_page_settings
    t = EAGLE.event_comment_head(@list)
    ps = { :repeat => true }
    t.scan( /<esas ?(.*?)>/ ).each do |params|
      _t = params[0]
      if _t =~ /(\d+) (\d+) (\d+)/
        ps[:mid] = $1.to_i
        ps[:eid] = $2.to_i
        ps[:pid] = $3.to_i
      elsif $imported["EAGLE-EventInteractEX"]
        _params = EAGLE_COMMON.parse_tags(_t)
        ps[:mid] = _params[:mid].to_i if _params[:mid]
        ps[:eid] = _params[:eid].to_i
        ps[:pid] = _params[:pid].to_i if _params[:pid]
        ps[:sym] = _params[:sym] if _params[:sym]
      end
    end
    if ps[:eid]
      ps[:mid] = $game_map.map_id if ps[:mid] == 0
      ps[:eid] = @id if ps[:eid] == 0
      @esas_ai_event.reset(ps)
      @esas_ai_event.run
    end
  end
  #--------------------------------------------------------------------------
  # ● 每帧更新
  #--------------------------------------------------------------------------
  alias eagle_esas_event_update update
  def update
    eagle_esas_event_update
    return if freeze?
    @esas_ai_event.update unless $game_map.interpreter.event_id == @id
  end
end

class Sprite_Character < Sprite_Base
  attr_reader :cw, :ch
end
class Spriteset_Map
  attr_reader :character_sprites
end
class Scene_Map < Scene_Base
  attr_reader :spriteset
end

#=============================================================================
# ○ 动画
#=============================================================================
module ESAS
  #--------------------------------------------------------------------------
  # ● 每帧更新
  #--------------------------------------------------------------------------
  @sprites_anim = []
  def self.update_anims
    @sprites_anim.each { |s| s.update if s.animation? }
  end
  #--------------------------------------------------------------------------
  # ● 在地图指定位置显示动画
  #  x/y 为地图上的坐标
  #  params 为 帧数 => 执行事件页的参数params
  #   同时 params[:chara_id] 可以传入动画的来源角色ID
  #--------------------------------------------------------------------------
  def self.anim_map(anim_id, x, y, params = {})
    s = empty_anim_sprite
    s.bind_map(x, y)
    s.bind_params(params)
    s.eagle_start_animation(anim_id)
    s
  end
  #--------------------------------------------------------------------------
  # ● 在地图指定位置显示动画（移动单位坐标）
  # 当使用了【像素级移动 by老鹰】
  #--------------------------------------------------------------------------
  def self.anim_map_pixel(anim_id, px, py, params = {})
    s = empty_anim_sprite
    s.bind_map_pixel(px, py)
    s.bind_params(params)
    s.eagle_start_animation(anim_id)
    s
  end
  #--------------------------------------------------------------------------
  # ● 在事件上显示动画
  #  chara_id 为 -1 时为玩家，正数为当前地图事件
  #--------------------------------------------------------------------------
  def self.anim_event(anim_id, chara_id, params = {})
    return if !SceneManager.scene_is?(Scene_Map)
    s = empty_anim_sprite
    c = ESAS.get_chara(chara_id)
    s.bind_character(c)
    s.bind_params(params)
    s.eagle_start_animation(anim_id)
    s
  end
  #--------------------------------------------------------------------------
  # ● 获取一个闲置精灵
  #--------------------------------------------------------------------------
  def self.empty_anim_sprite
    i = @sprites_anim.index { |s| !s.animation? }
    return @sprites_anim[i].reset if i
    s = Sprite_EagleBase.new
    @sprites_anim.push(s)
    return s
  end
end

class Sprite_EagleBase < Sprite_Base
  #--------------------------------------------------------------------------
  # ● 初始化对象
  #     character : Game_Character
  #--------------------------------------------------------------------------
  def initialize(viewport = nil)
    super(viewport)
    self.ox = 16
    self.oy = 32
    reset
  end
  #--------------------------------------------------------------------------
  # ● 重置绑定
  #--------------------------------------------------------------------------
  def reset
    @character = nil
    @map_x = @map_y = nil
    @px = @py = nil
    @params = {}
    @esas_events = []
    stop_animation
    self
  end
  #--------------------------------------------------------------------------
  # ● 绑定 帧 => 事件执行params
  #--------------------------------------------------------------------------
  def bind_params(params)
    @params = params
    @esas_events.clear
  end
  #--------------------------------------------------------------------------
  # ● 绑定显示到屏幕
  #--------------------------------------------------------------------------
  def bind_screen(x, y)
    self.x = x
    self.y = y
    update_position
  end
  #--------------------------------------------------------------------------
  # ● 绑定显示在事件上
  #--------------------------------------------------------------------------
  def bind_character(character)
    @character = character
    update_position
  end
  #--------------------------------------------------------------------------
  # ● 绑定显示在地图上（RGSS坐标）
  #--------------------------------------------------------------------------
  def bind_map(map_x, map_y)
    @map_x = map_x
    @map_y = map_y
    update_position
  end
  #--------------------------------------------------------------------------
  # ● 绑定显示在地图上（移动单位坐标）
  #--------------------------------------------------------------------------
  def bind_map_pixel(px, py)
    @px = px
    @py = py
    update_position
  end
  #--------------------------------------------------------------------------
  # ● 更新画面
  #--------------------------------------------------------------------------
  def update
    super
    update_position
    update_esas_events
  end
  #--------------------------------------------------------------------------
  # ● 更新位置
  #--------------------------------------------------------------------------
  def update_position
    if @character
      self.x = @character.screen_x
      self.y = @character.screen_y
      self.z = @character.screen_z
      return
    end
    if @px && $imported["EAGLE-PixelMove"]
      self.x = PIXEL_MOVE.unit2pixel($game_map.adjust_x(@px)) + 16
      self.y = PIXEL_MOVE.unit2pixel($game_map.adjust_y(@py)) + 32
      return
    end
    if @map_x
      if $imported["EAGLE-PixelMove"]
        x_, e_ = PIXEL_MOVE.rgss2unit(@map_x)
        self.x = PIXEL_MOVE.unit2pixel($game_map.adjust_x(x_))
        y_, e_ = PIXEL_MOVE.rgss2unit(@map_y)
        self.y = PIXEL_MOVE.unit2pixel($game_map.adjust_y(y_))
        return
      end
      self.x = $game_map.adjust_x(@map_x) * 32 + 32
      self.y = $game_map.adjust_y(@map_y) * 32 + 48
      return
    end
  end
  #--------------------------------------------------------------------------
  # ○ 更新ESAS事件
  #--------------------------------------------------------------------------
  def update_esas_events
    @esas_events.each { |e| e.update }
  end
  #--------------------------------------------------------------------------
  # ● 生成动画精灵
  #--------------------------------------------------------------------------
  def make_animation_sprites
    @ani_sprites = []
    if @use_sprite && !@@ani_spr_checker.include?(@animation)
      16.times do
        sprite = Sprite_EagleAnimFrame.new(viewport)
        sprite.visible = false
        sprite.dx = sprite.dy = 0
        @ani_sprites.push(sprite)
      end
      if @animation.position == 3
        @@ani_spr_checker.push(@animation)
      end
    end
    @ani_duplicated = @@ani_checker.include?(@animation)
    if !@ani_duplicated && @animation.position == 3
      @@ani_checker.push(@animation)
    end
  end
  #--------------------------------------------------------------------------
  # ● 显示动画
  #--------------------------------------------------------------------------
  def eagle_start_animation(anim_id)
    animation = $data_animations[anim_id]
    start_animation(animation)
  end
  #--------------------------------------------------------------------------
  # ● 更新动画
  #--------------------------------------------------------------------------
  def update_animation
    return unless animation?
    @ani_duration -= 1
    if @ani_duration % @ani_rate == 0
      if @ani_duration > 0
        frame_index = @animation.frame_max
        frame_index -= (@ani_duration + @ani_rate - 1) / @ani_rate
        animation_set_sprites(@animation.frames[frame_index])
        apply_frame_ex(frame_index)  # 额外处理
        @animation.timings.each do |timing|
          animation_process_timing(timing) if timing.frame == frame_index
        end
      else
        end_animation
        return
      end
    end
    update_animation_origin   # 更新原点
    update_animation_position # 更新位置
  end
  #--------------------------------------------------------------------------
  # ○ 中止动画
  #--------------------------------------------------------------------------
  def stop_animation
    @ani_duration = 0 # 剩余动画时间（帧）
    end_animation
  end
  #--------------------------------------------------------------------------
  # ● 设置动画的精灵
  #     frame : 帧数据（RPG::Animation::Frame）
  #--------------------------------------------------------------------------
  def animation_set_sprites(frame)
    cell_data = frame.cell_data
    @ani_sprites.each_with_index do |sprite, i|
      next unless sprite
      pattern = cell_data[i, 0]
      if !pattern || pattern < 0
        sprite.visible = false
        next
      end
      sprite.bitmap = pattern < 100 ? @ani_bitmap1 : @ani_bitmap2
      sprite.visible = true
      sprite.src_rect.set(pattern % 5 * 192,
        pattern % 100 / 5 * 192, 192, 192)
      if @ani_mirror
        sprite.dx = - cell_data[i, 1]
        sprite.dy = + cell_data[i, 2]
        sprite.angle = (360 - cell_data[i, 4])
        sprite.mirror = (cell_data[i, 5] == 0)
      else
        sprite.dx = cell_data[i, 1]
        sprite.dy = cell_data[i, 2]
        sprite.angle = cell_data[i, 4]
        sprite.mirror = (cell_data[i, 5] == 1)
      end
      sprite.z = self.z + 300 + i
      sprite.ox = 96
      sprite.oy = 96
      sprite.zoom_x = cell_data[i, 3] / 100.0
      sprite.zoom_y = cell_data[i, 3] / 100.0
      sprite.opacity = cell_data[i, 6] * self.opacity / 255.0
      sprite.blend_type = cell_data[i, 7]
    end
  end
  #--------------------------------------------------------------------------
  # ○ 执行第 frame_index 帧时的额外处理
  #--------------------------------------------------------------------------
  def apply_frame_ex(frame_index)
    if ps = @params[frame_index]
      data = {}
      data[:chara] = ESAS.get_chara(@params[:chara_id]) if @params[:chara_id]
      if @character
        data[:x] = @character.x
        data[:y] = @character.y
      end
      if @map_x
        data[:x] = @map_x
        data[:y] = @map_y
      end
      e = ESAS::Process_Event.new(ps, data)
      e.run
      @esas_events.push(e)
    end
  end
  #--------------------------------------------------------------------------
  # ○ 更新动画的原点
  #--------------------------------------------------------------------------
  def update_animation_origin
    if @animation.position == 3
      if viewport == nil
        @ani_ox = Graphics.width / 2
        @ani_oy = Graphics.height / 2
      else
        @ani_ox = viewport.rect.width / 2
        @ani_oy = viewport.rect.height / 2
      end
    else
      @ani_ox = x - ox + width / 2
      @ani_oy = y - oy + height / 2
      if @animation.position == 0
        @ani_oy -= height / 2
      elsif @animation.position == 2
        @ani_oy += height / 2
      end
    end
  end
  #--------------------------------------------------------------------------
  # ○ 更新动画的位置
  #--------------------------------------------------------------------------
  def update_animation_position
    @ani_sprites.each_with_index do |sprite, i|
      sprite.x = @ani_ox + sprite.dx
      sprite.y = @ani_oy + sprite.dy
    end
  end
end

class Sprite_EagleAnimFrame < Sprite
  attr_accessor  :dx, :dy
end

#=============================================================================
# ○ 目标获取
#=============================================================================
module ESAS
  #--------------------------------------------------------------------------
  # ● 依据技能范围数组，获取实际地图坐标的数组
  # 技能范围坐标编写时，请按角色位于[0,0]且朝右方向设置
  #  （向右为x正方向，向下为y正方向）
  #   比如角色面前一格，写成 [1,0]，角色面朝x正方向，面前一格就是[1,0]
  #   比如角色左手边一格，写成 [0,-1]
  #--------------------------------------------------------------------------
  def self.range_xys(*params)
    if params.size == 2  # (chara_id, arr)
      chara_id = params[0]
      chara = get_chara(chara_id)
      x = chara.x
      y = chara.y
      if $imported["EAGLE-PixelMove"]
        x = chara.rgss_x
        y = chara.rgss_y
      end
      dir = chara.direction
      arr = params[1]
    elsif params.size == 4  # (x, y, dir, arr)
      x = params[0]
      y = params[1]
      dir = params[2]
      arr = params[3]
    else
      p "ESAS.range_xys 参数数目错误！"
      return []
    end
    arr.collect do |dxy|
      _dxy = range_convert_to(dxy, dir)
      _x = x + _dxy[0]
      _y = y + _dxy[1]
      [_x, _y]
    end
  end
  #--------------------------------------------------------------------------
  # ● 索引指定地图坐标内的事件ID数组
  # arr 为地图实际坐标的数组
  #--------------------------------------------------------------------------
  def self.range_ids(arr, type = :enemy)
    es = []
    arr.each do |xy|
      range_all(type).each do |e|
        next if e.esas_empty?
        es.push(e) if e.pos?(xy[0], xy[1])
      end
    end
    es.collect { |e| e.id }
  end
  #--------------------------------------------------------------------------
  # ● 依据技能范围数组，获取实际地图坐标的数组
  # 注意：此方法为使用了【像素级移动 by老鹰】，格子大小与人物的碰撞矩形相同
  #--------------------------------------------------------------------------
  def self.range_xys_pixel(*params)
    if !$imported["EAGLE-PixelMove"]
      p "ESAS.range_xys_pixel 方法错误！没有使用【像素级移动 by老鹰】"
      return []
    end
    if params.size == 2  # (chara_id, arr)
      chara_id = params[0]
      chara = get_chara(chara_id)
      _rect = chara.get_collision_rect(false)
      dir = chara.direction
      arr = params[1]
    elsif params.size == 6 # (x,y,w,h, dir, arr)
      x = params[0]
      y = params[1]
      w = params[2]
      h = params[3]
      dir = params[4]
      arr = params[5]
      _rect = Rect.new(x, y, w, h)
    else
      p "ESAS.range_xys_pixel 参数数目错误！"
      return []
    end
    arr.collect do |dxy|
      _dxy = range_convert_to(dxy, dir)
      r = _rect.clone
      r.x = r.x + _dxy[0] * _rect.width
      r.y = r.y + _dxy[1] * _rect.height
      r
    end
  end
  #--------------------------------------------------------------------------
  # ● 索引指定地图坐标内的事件ID数组
  # 注意：此方法为使用了【像素级移动 by老鹰】，格子大小与人物的碰撞矩形相同
  #--------------------------------------------------------------------------
  def self.range_ids_pixel(arr_rect, type = :enemy)
    es = []
    arr_rect.each do |xy|
      range_all(type).each do |e|
        next if e.esas_empty?
        es.push(e) if e.pos_rect?(xy)
      end
    end
    es.collect { |e| e.id }
  end
  #--------------------------------------------------------------------------
  # ● 获取索引对象的范围
  #--------------------------------------------------------------------------
  def self.range_all(type = :enemy)
    case type
    when :party # 只获取被标记为玩家的角色
      return range_party
    when :enemy # 只获取被标记为敌人的角色
      return range_enemy
    when :all   # 全部角色
      return range_party + range_enemy
    end
  end
  #--------------------------------------------------------------------------
  # ● 索引范围 - 我方
  #--------------------------------------------------------------------------
  def self.range_party
    [$game_player]
  end
  #--------------------------------------------------------------------------
  # ● 索引范围 - 敌方
  #--------------------------------------------------------------------------
  def self.range_enemy
    $game_map.events.values
  end
  #--------------------------------------------------------------------------
  # ● 将朝右方向的相对坐标更改为朝dir方向
  #--------------------------------------------------------------------------
  def self.range_convert_to(dxy, dir)
    case dir
    when 2
      return [-dxy[1], dxy[0]]
    when 4
      return [-dxy[0], -dxy[1]]
    when 6
      return dxy
    when 8
      return [dxy[1], -dxy[0]]
    end
  end
  #--------------------------------------------------------------------------
  # ● 从ID数组中挑选出符合条件的事件
  #  sym 为筛选条件，具体见 select_cond? 方法
  #  返回满足全部条件的事件的ID数组
  #--------------------------------------------------------------------------
  def self.select_ids(ids, sym)
    arr_r = []
    ids.each do |id|
      e = ESAS.get_chara(id)
      arr_r.push(e.id) if e && select_cond?(e, sym)
    end
    return arr_r
  end
  #--------------------------------------------------------------------------
  # ● 判断指定角色是否符合条件
  #--------------------------------------------------------------------------
  def self.select_cond?(chara, sym)
    # 如果是符号，则认定为名称的匹配
    if sym.is_a?(Symbol)
      sym = sym.to_s
      return chara.name.include?(sym)
    end
    # 如果是字符串，则认定为注释/事件页开头注释的匹配
    if sym.is_a?(String)
      return chara.note.include?(sym)
    end
    # 如果是数组，则认定每一项为筛选条件字符串
    if sym.is_a?(Array)
      params = {:event => chara,
        :log => "处理#{chara.id}号角色的条件时出错，请检查事件脚本中的 select_ids "}
      return sym.all? { |s| ESAS.eval(s, params) == true }
    end
  end
end

#=============================================================================
# ○ 事件迭代
#=============================================================================
class Game_Interpreter
  #--------------------------------------------------------------------------
  # ● 获取当前事件的ID
  #--------------------------------------------------------------------------
  def event_id
    return @esas_iter_id if @esas_iter_id
    return @event_id
  end
  #--------------------------------------------------------------------------
  # ● 获取当前事件对象
  #--------------------------------------------------------------------------
  def event
    begin
      return $game_map.events[self.event_id]
    rescue
      t  = "无法找到 #{@map_id} 号地图中 #{self.event_id} 号的事件！"
      t += "请确定事件脚本中没有在 0 号ID的情况下使用 event"
      p t
      return nil
    end
  end
  #--------------------------------------------------------------------------
  # ● 对事件ID数组进行迭代
  #  脚本之间的指令的 本事件 将替换为被迭代事件
  #--------------------------------------------------------------------------
  def esas_iter(event_ids = [])
    if @esas_iter_ids == nil
      return esas_iter_skip_all if event_ids.nil? || event_ids.empty?
      @esas_iter_start_index = @index
      @esas_iter_ids = event_ids.dup
      esas_iter_skip_all if !esas_iter_skip_no_esas # 处理事件的无敌帧
    end
  end
  #--------------------------------------------------------------------------
  # ● 迭代尾部
  #--------------------------------------------------------------------------
  def esas_iter_end
    if @esas_iter_ids
      @index = @esas_iter_start_index if esas_iter_skip_no_esas
    end
  end
  #--------------------------------------------------------------------------
  # ● 跳过全部迭代
  #--------------------------------------------------------------------------
  def esas_iter_skip_all
    _i = @index + 1
    while _i < @list.size
      if (@list[_i].code == 355 || @list[_i].code == 655) &&
         @list[_i].parameters[0].include?("esas_iter_end")
        break @index = _i + 1
      end
      _i += 1
    end
  end
  #--------------------------------------------------------------------------
  # ● 跳过处于无敌帧的
  #--------------------------------------------------------------------------
  def esas_iter_skip_no_esas
    @esas_iter_id = nil
    loop do
      if @esas_iter_ids.empty? # 没有事件了，需要跳过迭代
        @esas_iter_ids = nil
        return false
      end
      @esas_iter_id = @esas_iter_ids.shift
      chara = ESAS.get_chara(@esas_iter_id)
      next if chara.no_esas?
      return true
    end
  end
  #--------------------------------------------------------------------------
  # * Get Character
  #     param : If -1, player. If 0, this event. Otherwise, event ID.
  #--------------------------------------------------------------------------
  def get_character(param)
    if $game_party.in_battle
      nil
    elsif param < 0
      $game_player
    else
      events = same_map? ? $game_map.events : {}
      events[param > 0 ? param : self.event_id]
    end
  end
  #--------------------------------------------------------------------------
  # * Conditional Branch
  #--------------------------------------------------------------------------
  alias eagle_esas_command_111 command_111
  def command_111
    result = false
    case @params[0]
    when 2  # Self switch
      if self.event_id > 0
        key = [@map_id, self.event_id, @params[1]]
        result = ($game_self_switches[key] == (@params[2] == 0))
      end
      @branch[@indent] = result
      command_skip if !@branch[@indent]
    else
      eagle_esas_command_111
    end
  end
  #--------------------------------------------------------------------------
  # * Common Event
  #--------------------------------------------------------------------------
  def command_117
    common_event = $data_common_events[@params[0]]
    if common_event
      child = Game_Interpreter.new(@depth + 1)
      child.setup(common_event.list, same_map? ? self.event_id : 0)
      child.run
    end
  end
  #--------------------------------------------------------------------------
  # * Control Self Switch
  #--------------------------------------------------------------------------
  def command_123
    if self.event_id > 0
      key = [@map_id, self.event_id, @params[0]]
      $game_self_switches[key] = (@params[1] == 0)
    end
  end
  #--------------------------------------------------------------------------
  # * Temporarily Erase Event
  #--------------------------------------------------------------------------
  def command_214
    $game_map.events[self.event_id].erase if same_map? && self.event_id > 0
  end
end

#=============================================================================
# ○ POP
#=============================================================================
module ESAS
  #--------------------------------------------------------------------------
  # ● 每帧更新
  #--------------------------------------------------------------------------
  @sprites_pop = []
  def self.update_pops
    return if @sprites_pop.empty?
    tmp = []
    @sprites_pop.each do |s|
      s.update
      next s.dispose if s.finish
      tmp.push(s)
    end
    @sprites_pop = tmp
  end
  #--------------------------------------------------------------------------
  # ● 新生成一个POP
  #--------------------------------------------------------------------------
  def self.new_pop(params = {})
    # :text => 绘制文本
    # :cid => 绑定角色的ID
    # :type => 显示模式
    # :w / :h => 精灵宽度高度
    # :size => 字体大小
    # :color => 字体颜色
    if params.is_a?(String) && $imported["EAGLE-EventInteractEX"]
      params = EAGLE_COMMON.parse_tags(params)
      params[:cid] = params[:cid].to_i
      params[:type] = params[:type].to_sym if params[:type]
      params[:w] = params[:w].to_i if params[:w]
      params[:h] = params[:h].to_i if params[:h]
      params[:size] = params[:size].to_i if params[:size]
      params[:color] = params[:color].to_i if params[:color]
    end
    s = Sprite_Pop.new(params)
    s.reset
    @sprites_pop.push(s)
  end
  #--------------------------------------------------------------------------
  # ● POP精灵
  #--------------------------------------------------------------------------
  class Sprite_Pop < Sprite
    attr_reader :finish
    #--------------------------------------------------------------------------
    # ● 初始化
    #--------------------------------------------------------------------------
    def initialize(params)
      super(nil)
      @params = params
      process_params
      @fiber = Fiber.new { run }
      @finish = false
    end
    #--------------------------------------------------------------------------
    # ● 处理参数
    #--------------------------------------------------------------------------
    def process_params
      @params[:type] ||= :bounce
      @params[:chara] = ESAS.get_chara(@params[:cid])
      @params[:chara_s] = ESAS.get_chara_sprite(@params[:cid])
    end
    #--------------------------------------------------------------------------
    # ● 释放
    #--------------------------------------------------------------------------
    def dispose
      self.bitmap.dispose
      super
    end
    #--------------------------------------------------------------------------
    # ● 重置
    #--------------------------------------------------------------------------
    def reset
      self.bitmap.dispose if self.bitmap
      w = @params[:w] || 64
      h = @params[:h] || 18
      self.bitmap = Bitmap.new(w, h)
      redraw
      reset_position
    end
    #--------------------------------------------------------------------------
    # ● 重绘
    #--------------------------------------------------------------------------
    def redraw
      t = @params[:text]
      self.bitmap.font.size = @params[:size] || @params[:h] || 18
      self.bitmap.font.color = text_color( @params[:color] || 0 )
      self.bitmap.draw_text(0,0,self.width,self.height, t, 1)
    end
    #--------------------------------------------------------------------------
    # * Get Text Color
    #     n : Text color number (0..31)
    #--------------------------------------------------------------------------
    def text_color(n)
      Cache.system("Window").get_pixel(64 + (n % 8) * 8, 96 + (n / 8) * 8)
    end
    #--------------------------------------------------------------------------
    # ● 重设初始位置
    #--------------------------------------------------------------------------
    def reset_position
      self.ox = self.width / 2
      self.oy = self.height / 2
      if c = @params[:chara]
        self.x = c.screen_x
        self.y = c.screen_y
      end
      @y0_bounce = self.y
      if s = @params[:chara_s]
        self.y -= s.ch/2
      else
        self.y -= 16
      end
      self.z = 300
    end
    #--------------------------------------------------------------------------
    # ● 每帧更新
    #--------------------------------------------------------------------------
    def update
      super
      @fiber.resume if @fiber
    end
    #--------------------------------------------------------------------------
    # ● 开始
    #--------------------------------------------------------------------------
    def run
      Fiber.yield
      begin
        self.method("run_#{@params[:type]}").call
      rescue
        p "使用ESAS的POP时发生错误！"
        p "- 报错信息：#{$!}"
        p "- 请检查 :type 参数是否正确！已经用默认弹跳默认进行替换"
        run_bounce
      end
      self.opacity = 0
      @finish = true
    end
    #--------------------------------------------------------------------------
    # ● 开始 - 缩放弹出
    #--------------------------------------------------------------------------
    def run_zoom
      y0 = self.y + 16
      y1 = self.y - 16
      def easeOutBack(v)
        return 0 if v == 0
        return 1 if v == 1
        c1 = 1.70158
        c3 = c1 + 1
        return 1 + c3 * (v - 1)**3 + c1 * (v - 1)**2
      end
      t = 30
      t.times do |i|
        per = easeOutBack(i * 1.0 / t)
        self.zoom_x = self.zoom_y = 0.5 + (1.0 - 0.5) * per
        self.y = y0 + (y1 - y0) * per
        Fiber.yield
      end
      30.times { self.opacity -= 7; Fiber.yield }
    end
    #--------------------------------------------------------------------------
    # ● 开始 - 弹跳
    #--------------------------------------------------------------------------
    def run_bounce
      vx = rand * 2 - 1; _x = self.x
      vy = -2 - rand(2)
      f = false
      100.times do |i|
        _x += vx; self.x = _x
        self.y += vy
        vy += 1 if i % 4 == 0
        if (self.y >= @y0_bounce) && f == false
          vy = (-vy * 0.5).to_i
          f = true
        end
        if (vy == 0)
          f = false
          vx = 0 if self.y >= @y0_bounce
        end
        Fiber.yield
      end
      30.times { self.opacity -= 7; Fiber.yield }
    end
  end # end of class Sprite_Pop
end

#=============================================================================
# ○ HP血条
#=============================================================================
class Game_CharacterBase
  attr_accessor  :hp
end
class Sprite_Character < Sprite_Base
  #--------------------------------------------------------------------------
  # ● 释放
  #--------------------------------------------------------------------------
  alias eagle_esas_dispose dispose
  def dispose
    dispose_eagle_hp
    eagle_esas_dispose
  end
  #--------------------------------------------------------------------------
  # ● 更新
  #--------------------------------------------------------------------------
  alias eagle_esas_update update
  def update
    eagle_esas_update
    update_eagle_hp if @character
  end

  #--------------------------------------------------------------------------
  # ● HP条
  #--------------------------------------------------------------------------
  def update_eagle_hp
    start_eagle_hp if @character.hp && @character.tmp[:hp_draw].nil?
    if @eagle_sprite_hp
      @eagle_sprite_hp.x = self.x
      @eagle_sprite_hp.y = self.y
      @eagle_sprite_hp.z = self.z + 1
      if @character.tmp[:hp_draw] != @character.hp
        redraw_eagle_hp
      end
      @eagle_sprite_hp.opacity = 0 if @character.hp == @character.tmp[:hp_max]
      if @character.hp <= 0
        @character.hp = nil
        dispose_eagle_hp
      end
    end
  end
  def start_eagle_hp
    @character.hp = @character.hp.to_i
    @character.tmp[:hp_max] = @character.hp if @character.tmp[:hp_max].nil?
    @character.tmp[:hp_draw] = 0
    @eagle_sprite_hp = ::Sprite.new(viewport)
    @eagle_sprite_hp.bitmap = Bitmap.new(32, 4)
    @eagle_sprite_hp.ox = 16
    @eagle_sprite_hp.oy = 0
    redraw_eagle_hp
  end
  def redraw_eagle_hp
    @eagle_sprite_hp.opacity = 200
    b = @eagle_sprite_hp.bitmap
    d = @character.hp - @character.tmp[:hp_draw]
    @character.tmp[:hp_draw] += (d > 0 ? 1 : -1) if d != 0

    b.clear
    # 绘制边框
    b.fill_rect(0, 0, b.width, b.height, Color.new(0,0,0,255))
    # 绘制动态损失hp
    if d < 0
      hp_rate = @character.tmp[:hp_draw] * 1.0 / @character.tmp[:hp_max]
      w = (b.width-2) * hp_rate
      b.fill_rect(1, 1, w, b.height-2, Color.new(150,150,150,255))
    end
    # 绘制当前hp
    hp_rate = @character.hp * 1.0 / @character.tmp[:hp_max]
    w = (b.width-2) * hp_rate
    b.fill_rect(1, 1, w, b.height-2, Color.new(255,0,0,255))
  end
  def dispose_eagle_hp
    if @eagle_sprite_hp
      @eagle_sprite_hp.bitmap.dispose
      @eagle_sprite_hp.dispose
      @character.tmp[:hp_max] = nil
      @character.tmp[:hp_draw] = nil
    end
    @eagle_sprite_hp = nil
  end
end
