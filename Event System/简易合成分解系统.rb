#==============================================================================
# ■ 简易合成分解系统 by 老鹰（http://oneeyedeagle.lofter.com/）
#==============================================================================
$imported ||= {}
$imported["EAGLE-ItemEX"] = true
#==============================================================================
# - 2019.12.16.15
#==============================================================================
# - 本插件新增在菜单物品栏中触发的物品分解与合成系统
#--------------------------------------------------------------------------
# ○ 定义：物品标志字符
#--------------------------------------------------------------------------
# - 物品标志字符为本插件所使用的数据类型（字符串），用于传入指定物品的信息，格式为
#
#      物品数目 + 物品类型字符 + 物品ID
#
#   其中 物品数目 可以省略，默认取 1
#   其中 物品类型字符 用 i 代表物品，w 代表武器，a代表护甲
#                可以省略，默认取 i
#   其中 物品ID 为其在数据库中的ID
#
# - 示例：
#     5i1  代表 5 个 1 号物品
#     2w52 代表 2 个 52 号武器
#     a4   代表 1 个 4 号护甲
#     6    代表 1 个 6 号物品
#--------------------------------------------------------------------------
# ○ 物品分解
#--------------------------------------------------------------------------
# - 在 数据库-物品/武器/护甲 备注栏中填写下式来定义当前物品的分解公式（只能填写一次）
#
#      <break 物品标志字符>
#
#   其中 物品标志字符 可重复填入多组，用空格隔开
#
# - 示例：
#    1号物品备注栏 <break i2 2i3> 则分解成 1个2号物品 与 2个3号物品
#    2号武器备注栏 <break i1 w1> 则分解成 1个1号物品 与 1个1号武器
#
# - 注：每次只会分解 1 个当前物品
#--------------------------------------------------------------------------
# ○ 物品合成
#--------------------------------------------------------------------------
# - 在 数据库-物品/武器/护甲 备注栏中填写下式，
#   来定义当前物品为材料之一时的合成公式（可多个）
#
#      <compose 物品标志字符 to 物品标志字符>
#
#   其中 物品标志字符 均可重复填入多组，用空格隔开
#
# - 示例：
#    1号物品备注栏 <compose 3i1 i2 to i3> 则输入 3个1号物品 与 1个2号物品时，
#      将合成出 1个3号物品
#    5号物品备注栏 <compose i1 5 to i2 3i3 4> 则输入 1个1号物品 与 1个5号物品时，
#      将合成出 1个2号物品、3个3号物品与1个4号物品
#
# - 注：由于只读取全部合成材料的备注栏，因此请不要将合成公式写在合成产物的备注栏内
#--------------------------------------------------------------------------
# ○ 简易UI
#--------------------------------------------------------------------------
# - 本插件为菜单中的物品栏绑定了简单的按键交互，以进行物品合成与分解
#
# - 物品分解：
#  ·当 trigger_break? 返回true时（默认按下A键），将触发当前选中物品的分解
#      并立即刷新物品栏
#
# - 物品合成：
#  ·当 trigger_compose? 返回true时（默认按下S键），将进入合成模式，
#      并将1个当前物品加入材料列表中
#  ·当再次按下S键，若当前物品未在材料列表中，将其加入材料列表
#      若已经在材料列表中，将其移出（若此时材料列表为空，则自动退出合成模式）
#  ·按下确定键，将判定合成，并清空材料列表，刷新物品栏，退出合成模式
#  ·按下取消键，将清空材料列表，退出合成模式
#
# - 局限：
#  ·每次只能分解1个物品
#  ·每种合成材料只能输入1个
#  ·合成材料的选择无法跨越类别
#    （供参考的修改方式：单列物品栏，只靠左右键动态切换类别，
#                       便可绕过默认下确认取消键切换类别，以保留当前的合成模式）
#==============================================================================

module ITEM_EX
#==============================================================================
# ○ 常量定义
#==============================================================================
  #--------------------------------------------------------------------------
  # ● 满足触发物品分解的条件？
  #--------------------------------------------------------------------------
  def self.trigger_break?
    Input.trigger?(:X)
  end
  #--------------------------------------------------------------------------
  # ● 满足触发物品合成的条件？
  #--------------------------------------------------------------------------
  def self.trigger_compose?
    Input.trigger?(:Y)
  end
#==============================================================================
# ○ Core
#==============================================================================
  #--------------------------------------------------------------------------
  # ● 物品分解
  #  返回： { item => num }
  #--------------------------------------------------------------------------
  def self.break_down(item)
    return if item.nil?
    item.note =~ /<break ?(.*?)>/mi
    return parse_item_list_str($1) if $1
    return {}
  end
  #--------------------------------------------------------------------------
  # ● 物品合成
  #  输入： { item => num }
  #  返回： { item => num }
  #--------------------------------------------------------------------------
  def self.compose(items)
    inputs = []; rules = {} # { array => hash }
    items.each do |item, n| # 在每个材料的备注栏中搜索规则
      item.note.scan(/<compose ?(.*?) ?to ?(.*?)>/mi).each do |params|
        array = parse_item_list_str(params[0], false)
        result = parse_item_list_str(params[1])
        rules[ sort_item_array(array) ] = result
      end
      n.times { inputs.push(get_item_str(item)) }
    end
    return rules[ sort_item_array(inputs) ] # { item => num } or nil
  end
  #--------------------------------------------------------------------------
  # ● 物品标志字符数组排序
  #--------------------------------------------------------------------------
  def self.sort_item_array(array)
    array.sort_by! { |e| [e[0], e.to_i] }
  end
  #--------------------------------------------------------------------------
  # ● 解析物品标志字符
  #--------------------------------------------------------------------------
  def self.parse_item_list_str(str, output_hash = true)
    items = output_hash ? {} : []
    str.split(" ").each do |s|
      s =~ /(\d+)?([iwa])?(\d+)/i
      num = $1.nil? ? 1 : $1.to_i
      type = $2.nil? ? 'i' : $2
      obj = get_item_obj(type, $3.to_i)
      if output_hash
        items[obj] ||= 0
        items[obj] += num
      else
        items.push(get_item_str(obj))
      end
    end
    return items
  end
#==============================================================================
# ○ 通用
#==============================================================================
  #--------------------------------------------------------------------------
  # ● 由物品标志字符获取指定对象
  #--------------------------------------------------------------------------
  def self.get_item_obj(type, id)
    case type
    when 's'; obj = $data_skills[id]
    when 'i'; obj = $data_items[id]
    when 'w'; obj = $data_weapons[id]
    when 'a'; obj = $data_armors[id]
    end
    return obj
  end
  #--------------------------------------------------------------------------
  # ● 由指定对象获取物品标志字符
  #--------------------------------------------------------------------------
  def self.get_item_str(item)
    type = ''
    case item.class
    when RPG::Skill; type = 's'
    when RPG::Item;  type = 'i'
    when RPG::Weapon;type = 'w'
    when RPG::Armor; type = 'a'
    end
    return type + item.id.to_s
  end
#==============================================================================
# ○ Scene
#==============================================================================
  #--------------------------------------------------------------------------
  # ● 绑定物品窗口
  #--------------------------------------------------------------------------
  def self.item_window=(w)
    @item_window = w
  end
  #--------------------------------------------------------------------------
  # ● 更新
  #--------------------------------------------------------------------------
  def self.update
    return if !@item_window.active
    ITEM_EX.process_break if trigger_break?
    ITEM_EX.process_compose if trigger_compose?
  end
  #--------------------------------------------------------------------------
  # ● 处理物品分解
  #--------------------------------------------------------------------------
  def self.process_break
    return if $game_temp.item_compose_selected
    item = @item_window.item
    items = ITEM_EX.break_down(item)
    return Sound.play_buzzer if items.empty?
    index = @item_window.index
    $game_party.gain_item(item, -1)
    items.each { |i, c| $game_party.gain_item(i, c) }
    @item_window.refresh
    @item_window.index = index
  end
  #--------------------------------------------------------------------------
  # ● 处理物品合成
  #--------------------------------------------------------------------------
  def self.process_compose
    if $game_temp.item_compose_selected.nil?
      $game_temp.item_compose_selected = {}
    end
    item = @item_window.item
    if $game_temp.item_compose_selected[item]
      $game_temp.item_compose_selected.delete(item)
      if $game_temp.item_compose_selected.empty?
        process_compose_cancel
      end
    else
      $game_temp.item_compose_selected[item] ||= 0
      $game_temp.item_compose_selected[item] += 1
    end
    @item_window.redraw_current_item
  end
  #--------------------------------------------------------------------------
  # ● 物品合成确认
  #--------------------------------------------------------------------------
  def self.process_compose_ok
    items = ITEM_EX.compose($game_temp.item_compose_selected)
    if items
      $game_temp.item_compose_selected.each do |i, c|
        $game_party.gain_item(i, -c)
      end
      items.each { |i, c| $game_party.gain_item(i, c) }
    else
      Sound.play_buzzer
    end
    process_compose_cancel
  end
  #--------------------------------------------------------------------------
  # ● 物品合成取消
  #--------------------------------------------------------------------------
  def self.process_compose_cancel
    $game_temp.item_compose_selected = nil
    @item_window.refresh
    @item_window.activate
  end
end
#==============================================================================
# ○ Game_Temp
#==============================================================================
class Game_Temp
  attr_accessor :item_compose_selected
  #--------------------------------------------------------------------------
  # ● 初始化
  #--------------------------------------------------------------------------
  alias eagle_item_ex_init initialize
  def initialize
    eagle_item_ex_init
    @item_compose_selected = nil
  end
end
#==============================================================================
# ○ Window_ItemList
#==============================================================================
class Window_ItemList < Window_Selectable
  #--------------------------------------------------------------------------
  # ● 绘制项目
  #--------------------------------------------------------------------------
  alias eagle_item_ex_draw_item draw_item
  def draw_item(index)
    item = @data[index]
    if item && $game_temp.item_compose_selected &&
       $game_temp.item_compose_selected[item]
      rect = item_rect(index)
      contents.gradient_fill_rect(rect,
        Color.new(0,0,0,0), Color.new(255,247,38,120))
    end
    eagle_item_ex_draw_item(index)
  end
end
#==============================================================================
# ○ Scene_Item
#==============================================================================
class Scene_Item < Scene_ItemBase
  #--------------------------------------------------------------------------
  # ● 开始
  #--------------------------------------------------------------------------
  alias eagle_item_ex_start start
  def start
    eagle_item_ex_start
    ITEM_EX.item_window = @item_window
  end
  #--------------------------------------------------------------------------
  # ● 更新
  #--------------------------------------------------------------------------
  def update
    super
    ITEM_EX.update
  end
  #--------------------------------------------------------------------------
  # ● 物品“确定”
  #--------------------------------------------------------------------------
  alias eagle_item_ex_on_item_ok on_item_ok
  def on_item_ok
    if $game_temp.item_compose_selected
      ITEM_EX.process_compose_ok
    else
      eagle_item_ex_on_item_ok
    end
  end
  #--------------------------------------------------------------------------
  # ● 物品“取消”
  #--------------------------------------------------------------------------
  alias eagle_item_ex_on_item_cancel on_item_cancel
  def on_item_cancel
    if $game_temp.item_compose_selected
      ITEM_EX.process_compose_cancel
    else
      eagle_item_ex_on_item_cancel
    end
  end
end
