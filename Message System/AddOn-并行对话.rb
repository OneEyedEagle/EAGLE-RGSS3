#==============================================================================
# ■ Add-On 并行对话 by 老鹰（http://oneeyedeagle.lofter.com/）
# ※ 本插件需要放置在【对话框扩展 by老鹰】之下
#==============================================================================
$imported ||= {}
$imported["EAGLE-MessagePara"] = true
#==============================================================================
# - 2020.2.14.13 优化if与rb标签对编写方式
#==============================================================================
# - 本插件利用 对话框扩展 中的工具生成新的并行显示对话
#--------------------------------------------------------------------------
# ○ 编写“标签序列”
#--------------------------------------------------------------------------
# - 由指定的标签/标签对进行任意排列而组成的字符串，并逐个解析执行
# - 注意：
#    ·在解析的准备阶段，将应用 $game_message 的全部转义符参数作为并行对话框的初值
#    ·所有标签均大小写敏感，在默认情况下，全部为小写字母
#
# - 可用标签一览：
#    <msg>...</msg>  → 预设对话文本，当执行该标签对时，解析将暂停，直至对话框关闭
#         其中...替换成所需的对话文本
#
#    <face face_name [face_index]>  → 预设之后对话框所显示脸图的参数
#         其中 face_name 替换成 Graphics/Faces 目录下的脸图文件名，
#            文件名可省略后缀，但不可含有空格
#         其中 face_index 替换成脸图的序号id（0-7）（该项可省略，默认重置为 0）
#
#    <msgp param_str>  → 预设之后对话框的参数
#         其中 param_str 替换成 变量名+参数值 的字符串（同 对话框扩展 中）
#         可设置变量一览：
#           bg → 对话框的背景类型id（0普通，1暗色，2透明）（同VA默认）
#           pos → 设置对话框的显示位置类型id（0居上，1居中，2居下）（同VA默认）
#           w → 设置对话框绘制完成后、关闭前的等待帧数（nil为不自动关闭）
#           t → 设置对话框关闭后、下一次对话开启前的等待帧数
#           z → 设置对话框的z值（默认100）
#         示例： <msgp w10> → 之后的对话框在绘制完成后，均额外等待10帧才关闭
#
#    <anim chara_index animation_id[ wait]>  → 显示动画（仅在地图上有效）
#          其中 chara_index 为指定的事件/角色的序号
#            正数 代表地图事件中 指定ID 的事件
#             0 代表当前并行对话绑定的事件（仅地图上事件页注释所激活的并行对话有效）
#            负数 代表玩家队伍中 数据库ID 为该负数绝对值的角色，若不存在则取队首
#          其中 animation_id 为数据库中指定动画的ID号（从1开始）
#          其中[ wait] 为可选项，若有数值传入，则代表需要等待至显示结束
#
#    <balloon chara_index balloon_id[ wait]>  → 显示心情气泡（仅在地图上有效）
#          其中 balloon_id 为心情气泡的ID号（从1开始）
#
#    <wait count> → 直接等待 count 帧数
#
#    <break> → 直接结束当前序列
#
#    <call list_name>  → 呼叫预设的“标签序列”
#         在文本文件预设的序列中查找名为 list_name 的序列，并开始解析它
#
#    <if>cond_str</if> → 如果 eval(cond_str) 返回 false，则跳过下一个标签
#         可用 s 代替 $game_switches， v 代替 $game_variables
#              p 代替 $game_player， e 代替 当前事件 或 当前敌人
#
#    <rb>str</rb> → 执行脚本 eval(str)
#
#--------------------------------------------------------------------------
# ○ 呼叫“标签序列”
#--------------------------------------------------------------------------
# - 利用下述脚本启动立即更新、只执行一遍的标签序列
#
#        MESSAGE_PARA.add(name, list_str[, ensure_fin])
#
#    其中 name 为任意的唯一标识符（若有重名，则先前存在的会被删除）
#       推荐使用 Symbol 或 String 类型
#    其中 list_str 为“标签序列”字符串（注意！转义符需要用 \\ 代替 \）
#    其中 ensure_fin 传入 true 时，将保证当前对话序列完全显示【可选】
#      （场景切换时只暂停，之后将继续）
#
#   示例：MESSAGE_PARA.add(:test, "<call test1><msg>...</msg>")
#      → 生成一个占位:test的“标签序列”，内容如字符串，并开始更新
#
#--------------------------------------------------------------------------
# ○ 预设“标签序列”
#--------------------------------------------------------------------------
# - 利用脚本将指定的“标签序列”字符串以指定名称存入预设
#
#        MESSAGE_PARA.reserve(name, list_str)
#
#    其中 name 为任意的唯一标识符（将覆盖原有的预设）
#    其中 list_str 为“标签序列”字符串（注意！转义符需要用 \\ 代替 \）
#
#--------------------------------------------------------------------------
# ○ 呼叫预设的“标签序列”
#--------------------------------------------------------------------------
# - 利用脚本 MESSAGE_PARA.call(name, [, ensure_fin]) 呼叫预设中 name 名称的序列
#
#--------------------------------------------------------------------------
# ○ 文本文件中预设“标签序列”
#--------------------------------------------------------------------------
# - 在指定的文本文件中，按 <list name>...</list> 填写
#     其中 name 替换成该“标签序列”的唯一名称，便于进行调用
#     其中 ... 替换成“标签序列”（转义符正常写法）
#
# - 注意：
#    ·文本文件的编码必须为 UTF-8
#    ·文本文件不局限于.txt，只要其中只包含UTF-8编码的文本，可以为任意后缀名
#    ·由于技术受限，暂时无法读取VA加密档案中的文本文件，请不要放置于加密路径下
#      若已经有了能够读取加密档案路径下纯文本文件的方法，请替换全部EAGLE.load_text
#
#--------------------------------------------------------------------------
# ○ 地图事件页中设置“标签序列”
#--------------------------------------------------------------------------
# - 事件页第一个指令为 注释 时，按下述格式填入该事件页的“标签序列”：
#
#        <list[ {cond}][ params]>...</list>
#
#   其中 ... 替换成“标签序列”（转义符正常写法）
#   其中 {cond} 替换成触发条件，若被 eval 后返回 false，则不触发
#     可用 s 代替 $game_switches， v 代替 $game_variables
#          p 代替 $game_player， e 代替 $game_map.events 或 $game_troop.members
#   其中 params 替换成 变量名+参数值 的字符串（可选）
#      可设置变量一览：
#       type → 设置该组并行对话的类型
#             （0玩家接近事件时触发，1自动触发，2鼠标停留触发）
#    （玩家接近时触发）（每次玩家接近只触发一次）
#       d → 玩家与事件的距离（x差值的绝对值+y差值的绝对值）小于等于d时触发
#    （自动触发）
#       tc → 第一次触发前的等待帧数
#       t → 显示完成后的等待帧数（nil代表不再重复显示）
#    （鼠标停留触发【需 鼠标系统】）
#       d → 与鼠标（所在格子）距离小于等于d时触发
#
#   示例（无参数）：
#      <list><msg>第一句台词</msg><msg>第二句台词</msg></list>
#      → 为该事件页添加 EVENT_MSG_TYPE_ID_DEFAULT 类型的对话组，
#         使用当前对话框的参数，依次显示这两句台词
#
#   示例（含参数）：
#      <list {s[1]}>...</list> → 当1号开关关闭时，不触发该并行对话
#      <list type0d3>...</list> → 设置玩家与事件间的距离不大于3时触发
#      <list type1t60>...</list> → 设置为自动触发，两次触发间隔60帧
#
# - 注意：
#    ·若文本量超出单个注释窗口，可以拆分成多个连续的 注释 指令，脚本将一并读取
#    ·对于每个事件，同时只会执行一个“标签序列”
#
#--------------------------------------------------------------------------
# ○ 注意
#--------------------------------------------------------------------------
#  ·进行 场所移动 / Scene切换 时，会自动结束全部“标签序列”
#      除了 ensure_fin 设置为 true 的序列
#  ·打开S_ID_NO_MSG号开关时，会自动结束全部“标签序列”并禁止产生新的
#==============================================================================

#==============================================================================
# ○ 【设置部分】
#==============================================================================
module MESSAGE_PARA
  #--------------------------------------------------------------------------
  # ●【常量】当该ID号开关打开时，关闭全部并行对话，并且不再生成新对话
  # type_id => type_sym
  #--------------------------------------------------------------------------
  S_ID_NO_MSG = 0
  #--------------------------------------------------------------------------
  # ●【常量】对话框的参数预设
  #--------------------------------------------------------------------------
  PARA_MESSAGE_PARAMS = {
    :bg => 0, # 对话框背景类型id
    :pos => 2, # 对话框位置类型id
    :w => 40, # 对话完成后、关闭前的等待帧数
    :t => 1, # 当前对话框关闭后的等待帧数
    :z => 100, # 对话框的z值
  }
  #--------------------------------------------------------------------------
  # ●【常量】预设文本文件的路径（用 / 分隔）与文件名（含后缀名）的数组
  #--------------------------------------------------------------------------
  FILES_MSG_LIST = ["Eagle/PARA.eagle"]
  #--------------------------------------------------------------------------
  # ●【常量】事件页注释里的并行对话类型
  # type_id => type_sym
  #--------------------------------------------------------------------------
  EVENT_MSG_ID_TO_TYPE = {
    0 => :near,
    1 => :auto,
    2 => :mouse,
  }
  #--------------------------------------------------------------------------
  # ●【常量】事件页默认并行对话类型id
  #--------------------------------------------------------------------------
  EVENT_MSG_TYPE_ID_DEFAULT = 0
  #--------------------------------------------------------------------------
  # ●【常量】事件页注释里的并行对话队列参数
  #--------------------------------------------------------------------------
  EVENT_PARAMS = {
    :near => { # id为0时“玩家接近触发”
      :d => 2, # 与玩家距离小于等于d时触发
    },
    :auto => { # id为1时“自动触发”
      :tc => 10, # 第一次触发前的等待帧数
      :t => 180, # 循环触发后的等待帧数
    },
    :mouse => { # id为2时“鼠标停留触发”
      :d => 0, # 与鼠标（所在格子）距离小于等于d时触发
    },
  }
end
#==============================================================================
# ○ 【读取部分】
#==============================================================================
module EAGLE
  #--------------------------------------------------------------------------
  # ● 读取事件页开头的注释组
  #--------------------------------------------------------------------------
  def self.event_comment_head(command_list)
    return "" if command_list.nil? || command_list.empty?
    t = ""; index = 0
    while command_list[index].code == 108 || command_list[index].code == 408
      t += command_list[index].parameters[0]
      index += 1
    end
    t
  end
  #--------------------------------------------------------------------------
  # ● 读取TXT文本
  #--------------------------------------------------------------------------
  def self.load_text(filename)
    text = ""
    File.open(filename, 'r') { |f| f.each_line { |l| text += l } }
    text.encode("UTF-8")
  end
end
#==============================================================================
# ○ 并行对话模块
#==============================================================================
module MESSAGE_PARA
  #--------------------------------------------------------------------------
  # ● 初始化
  #--------------------------------------------------------------------------
  def self.init
    @lists = {} # 存储当前正在更新的并行对话列表
    @lock_count = [] # 当前锁定类型汇总
    @lists_strs = {} # 存储预读取的全部对话序列 name_sym => list_msg
    FILES_MSG_LIST.each do |filename|
      @lists_strs.merge!( parse_list_file(filename) )
    end
  end
  #--------------------------------------------------------------------------
  # ● 解析含“标签序列”的文本文件
  #--------------------------------------------------------------------------
  # hash - 存储解析出的全部 name => [cond_string, 并行对话文本list_msg]
  def self.parse_list_file(filename)
    hash = {}
    text = EAGLE.load_text(filename) rescue ""
    text.scan(/<list ?(.*?)>(.*?)<\/list>/m).each do |params|
      hash[ params[0].to_sym ] = params[1]
    end
    hash
  end
  #--------------------------------------------------------------------------
  # ● 读取指定的“标签序列”字符串
  #--------------------------------------------------------------------------
  def self.get_list_str(sym)
    @lists_strs[sym] || ""
  end
  #--------------------------------------------------------------------------
  # ● 呼叫“标签序列”
  #--------------------------------------------------------------------------
  # list_str - "<msg params>foo</msg><msg params>foo</msg>"
  def self.add(id, list_str, ensure_fin = false)
    @lists[id].dispose if @lists[id]
    @lists[id] = MessagePara_List.new(id, list_str)
    @lists[id].f_ensure_fin = ensure_fin
    return true
  end
  #--------------------------------------------------------------------------
  # ● 保存“标签序列”到预设
  #--------------------------------------------------------------------------
  def self.reserve(id, list_str)
    @lists_strs[id] = list_str
  end
  #--------------------------------------------------------------------------
  # ● 呼叫预设的“标签序列”
  #--------------------------------------------------------------------------
  def self.call(name_sym, ensure_fin = false)
    name_sym = name_sym.to_sym if !name_sym.is_a?(Symbol)
    v = get_list_str(name_sym)
    return if v == ""
    add(name_sym, v, ensure_fin)
  end
  #--------------------------------------------------------------------------
  # ● 指定对话组存在？
  #--------------------------------------------------------------------------
  def self.list_exist?(id)
    @lists.has_key?(id)
  end
  #--------------------------------------------------------------------------
  # ● 直接结束
  #--------------------------------------------------------------------------
  def self.list_finish(id)
    return if !list_exist?(id)
    return if @lists[id].finish?
    @lists[id].finish
  end
  #--------------------------------------------------------------------------
  # ● 全部结束
  #--------------------------------------------------------------------------
  def self.all_finish
    @lists.each { |id, l| l.finish }
  end
  #--------------------------------------------------------------------------
  # ● 全部结束（跳过需要显示完的list）
  #--------------------------------------------------------------------------
  def self.all_finish_sys
    @lists.each do |id, l|
      next l.halt if l.f_ensure_fin
      l.finish
    end
  end
  #--------------------------------------------------------------------------
  # ● 全部继续
  #--------------------------------------------------------------------------
  def self.all_go_on
    @lists.each { |id, l| l.go_on }
  end
  #--------------------------------------------------------------------------
  # ● 更新
  #--------------------------------------------------------------------------
  def self.update
    update_lock
    @lists.each { |id, l| l.update }
    @lists.delete_if { |id, l| l.finish? }
  end
  #--------------------------------------------------------------------------
  # ● 更新锁定
  #--------------------------------------------------------------------------
  def self.update_lock
    if $game_switches[S_ID_NO_MSG]
      return if lock?
      all_finish_sys
      lock
    else
      return if !lock?
      unlock
    end
  end
  #--------------------------------------------------------------------------
  # ● 锁定
  #--------------------------------------------------------------------------
  def self.lock(type = :switch)
    @lock_count.push(type)
  end
  #--------------------------------------------------------------------------
  # ● 解锁
  #--------------------------------------------------------------------------
  def self.unlock(type = :switch)
    @lock_count.delete(type)
  end
  #--------------------------------------------------------------------------
  # ● 锁定？
  #--------------------------------------------------------------------------
  def self.lock?
    !@lock_count.empty?
  end
  #--------------------------------------------------------------------------
  # ● 解析含“标签序列”的字符串（地图事件页用）
  #--------------------------------------------------------------------------
  # hash - 存储解析出的全部 name => 并行对话文本list_msg
  def self.parse_event_list_str(text)
    s = $game_switches; v = $game_variables; p = $game_player
    e = $game_map.events if SceneManager.scene_is?(Scene_Map)
    e = $game_troop.members if SceneManager.scene_is?(Scene_Battle)
    hash = {}
    text.scan(/<list ?(\{.*?\})? ?(.*?)>(.*?)<\/list>/m).each do |params|
      next if params[0] && eval(params[0]) == false
      hash[ params[1] ] = params[2]
    end
    hash
  end
  #--------------------------------------------------------------------------
  # ● 初始化参数组（地图事件页用）
  #--------------------------------------------------------------------------
  def self.event_init_params(hash)
    type = EVENT_MSG_ID_TO_TYPE[ (hash[:type] || EVENT_MSG_TYPE_ID_DEFAULT) ]
    hash = hash.merge(EVENT_PARAMS[type]) { |k, v1, v2| v1 }
    hash[:type] = type
    hash[:active] = false # 已经触发？
    hash
  end
end
#==============================================================================
# ○ 并行对话列表
#==============================================================================
class MessagePara_List # 该list中每一时刻只显示一个对话框
  attr_reader   :game_message
  attr_accessor  :f_ensure_fin
  #--------------------------------------------------------------------------
  # ● 初始化对象
  #--------------------------------------------------------------------------
  def initialize(id, list_str)
    @id = id
    @list_str = list_str   # 待处理的标签队列
    @game_message = $game_message.clone
    @face = ["", 0]
    @params = MESSAGE_PARA::PARA_MESSAGE_PARAMS.dup
    @params[:id] = id
    @window = nil  # 当前正在处理的window
    @f_ensure_fin = false # 保证必定显示完？（场景切换时只暂时暂停并关闭）
    @fiber = Fiber.new { fiber_main }
  end
  #--------------------------------------------------------------------------
  # ● 更新
  #--------------------------------------------------------------------------
  def update
    @fiber.resume if @fiber
  end
  #--------------------------------------------------------------------------
  # ● 更新线程
  #--------------------------------------------------------------------------
  def fiber_main
    parse_list while !@list_str.empty?
    @fiber = nil
  end
  #--------------------------------------------------------------------------
  # ● 解析序列字符串
  #--------------------------------------------------------------------------
  def parse_list
    tag_name, tag_str = parse_next_tag
    method_name = "tag_" + tag_name
    send(method_name, tag_str) if respond_to?(method_name)
  end
  #--------------------------------------------------------------------------
  # ● 获取当前绑定的事件
  #--------------------------------------------------------------------------
  def get_bind_event
    if @id.is_a?(Integer)
      return $game_map.events[@id] if SceneManager.scene_is?(Scene_Map)
      return $game_troop.members[@id] if SceneManager.scene_is?(Scene_Battle)
    end
    return nil
  end
  #--------------------------------------------------------------------------
  # ● 获取地图上的指定角色
  #--------------------------------------------------------------------------
  def get_character(index)
    return nil if !SceneManager.scene_is?(Scene_Map)
    if index > 0
      return $game_map.events[index]
    elsif index == 0
      return get_bind_event
    elsif index < 0
      id = index.abs
      $game_player.followers.each { |f| return f.actor if f.actor && f.actor.actor.id == id }
      return $game_player
    end
  end
  #--------------------------------------------------------------------------
  # ● 解析下一个标签（移除首位的非标签内容）
  #--------------------------------------------------------------------------
  def parse_next_tag
    i = 0; s = @list_str.size
    while @list_str[i] != '<'
      i += 1
      return @list_str.clear if i == s
    end
    @list_str = @list_str[i..-1]
    @list_str.slice!(/<(.*?)>/)
    str = $1
    # tag_name 为标签中的标识符
    tag_name = str.slice!(/\w+/)
    # tag_str 为标签中标识符以外的字符
    tag_str = str.lstrip # 去除多余空格
    return tag_name, tag_str
  end
  #--------------------------------------------------------------------------
  # ● 标签：开启对话框
  #--------------------------------------------------------------------------
  def tag_msg(tag_str)
    @list_str.slice!(/^(.*?)<\/msg>/m)
    set_new_window($1)
    while @game_message.visible
      @window.update
      Fiber.yield
    end
    dispose
  end
  #--------------------------------------------------------------------------
  # ● 标签：预设脸图参数
  #--------------------------------------------------------------------------
  def tag_face(tag_str)
    ps = tag_str.split(' ')
    @face[0] = ps[0]
    @face[1] = (ps[1] ? ps[1].to_i : 0)
  end
  #--------------------------------------------------------------------------
  # ● 标签：预设对话框参数
  #--------------------------------------------------------------------------
  def tag_msgp(tag_str)
    MESSAGE_EX.parse_param(@params, tag_str) # 解析对话框参数
  end
  #--------------------------------------------------------------------------
  # ● 标签：呼叫预定序列
  #--------------------------------------------------------------------------
  def tag_call(tag_str)
    s = MESSAGE_PARA.get_list_str(tag_str.to_sym)
    @list_str = s + @list_str if s != ""
  end
  #--------------------------------------------------------------------------
  # ● 标签：显示动画
  #--------------------------------------------------------------------------
  def tag_anim(tag_str)
    ps = tag_str.split(' ')
    character = get_character(ps[0].to_i)
    return if character.nil?
    character.animation_id = ps[1].to_i
    Fiber.yield while character.animation_id > 0 if ps[2]
  end
  #--------------------------------------------------------------------------
  # ● 标签：显示心情
  #--------------------------------------------------------------------------
  def tag_balloon(tag_str)
    ps = tag_str.split(' ')
    character = get_character(ps[0].to_i)
    return if character.nil?
    character.balloon_id = ps[1].to_i
    Fiber.yield while character.balloon_id > 0 if ps[2]
  end
  #--------------------------------------------------------------------------
  # ● 标签：等待
  #--------------------------------------------------------------------------
  def tag_wait(tag_str)
    wait_c = tag_str.to_i
    wait_c.times { Fiber.yield }
  end
  #--------------------------------------------------------------------------
  # ● 标签：结束
  #--------------------------------------------------------------------------
  def tag_break(tag_str)
    finish
  end
  #--------------------------------------------------------------------------
  # ● 标签：判定，若返回false，则跳过下一指令
  #--------------------------------------------------------------------------
  def tag_if(tag_str)
    @list_str.slice!(/^(.*?)<\/if>/m)
    parse_next_tag if(eval_str($1) == false)
  end
  #--------------------------------------------------------------------------
  # ● 标签：脚本
  #--------------------------------------------------------------------------
  def tag_rb(tag_str)
    @list_str.slice!(/^(.*?)<\/rb>/m)
    eval_str($1)
  end
  #--------------------------------------------------------------------------
  # ● 执行字符串
  #--------------------------------------------------------------------------
  def eval_str(str)
    s = $game_switches; v = $game_variables; p = $game_player
    e = get_bind_event
    eval(str)
  end
  #--------------------------------------------------------------------------
  # ● 生成对话框
  #--------------------------------------------------------------------------
  def set_new_window(text)
    @game_message.clear
    @game_message.add(text)
    @game_message.face_name = @face[0]
    @game_message.face_index = @face[1]
    @game_message.background = @params[:bg]
    @game_message.position = @params[:pos]
    @game_message.visible = true
    @game_message.win_params[:z] = @params[:z]
    @game_message.pause_params[:v] = 0
    @window = Window_Message_Para.new(self, @params)
  end
  #--------------------------------------------------------------------------
  # ● 对话暂停与继续
  #--------------------------------------------------------------------------
  def halt
    @window.halt if @window
  end
  def go_on
    @window.go_on if @window
  end
  #--------------------------------------------------------------------------
  # ● 释放
  #--------------------------------------------------------------------------
  def dispose
    @window.dispose if @window
    @window = nil
  end
  #--------------------------------------------------------------------------
  # ● 结束？
  #--------------------------------------------------------------------------
  def finish?
    @fiber == nil
  end
  #--------------------------------------------------------------------------
  # ● 直接结束
  #--------------------------------------------------------------------------
  def finish
    @list_str.clear
    @window.finish if @window
  end
end
#==============================================================================
# ○ 并行对话框
#==============================================================================
class Window_Message_Para < Window_Message
  #--------------------------------------------------------------------------
  # ● 初始化对象
  #--------------------------------------------------------------------------
  def initialize(list, para_params)
    @list = list
    @para_params = para_params
    super()
  end
  #--------------------------------------------------------------------------
  # ● 获取主参数
  #--------------------------------------------------------------------------
  def game_message
    @list.game_message
  end
  #--------------------------------------------------------------------------
  # ● 更新纤程
  #--------------------------------------------------------------------------
  def update_fiber
    if @fiber
      return if @para_params[:halt]
      @fiber.resume
    elsif game_message.busy? && !game_message.scroll_mode
      @fiber = Fiber.new { fiber_main }
      @fiber.resume
    else
      game_message.visible = false
    end
  end
  #--------------------------------------------------------------------------
  # ● 暂停更新
  #--------------------------------------------------------------------------
  def halt
    @para_params[:halt] = true
  end
  #--------------------------------------------------------------------------
  # ● 继续更新
  #--------------------------------------------------------------------------
  def go_on
    @para_params[:halt] = false
  end
  #--------------------------------------------------------------------------
  # ● 强制结束当前对话框的更新
  #--------------------------------------------------------------------------
  def finish
    @fiber_para = nil
    @input_wait_c = 0
  end
  #--------------------------------------------------------------------------
  # ● 处理纤程的主逻辑
  #--------------------------------------------------------------------------
  def fiber_main
    game_message.visible = true
    update_background
    update_placement
    @fiber_para = Fiber.new { process_all_text; @fiber_para = nil }
    process_input
    @gold_window.close
    close_and_wait
    game_message.visible = false
    @fiber = nil
  end
  #--------------------------------------------------------------------------
  # ● 输入处理
  #--------------------------------------------------------------------------
  def process_input
    @input_wait_c = @para_params[:w]
    while @fiber_para || @input_wait_c.nil? || @input_wait_c > 0
      Fiber.yield
      next @fiber_para.resume if @fiber_para
      @input_wait_c -= 1 if @input_wait_c
    end
  end
  #--------------------------------------------------------------------------
  # ● 处理输入等待
  #--------------------------------------------------------------------------
  def input_pause
  end
  #--------------------------------------------------------------------------
  # ● 监听“确定”键的按下，更新快进的标志
  #--------------------------------------------------------------------------
  def update_show_fast
  end
  #--------------------------------------------------------------------------
  # ● 获取pop的弹出对象（需要有x、y方法）
  #--------------------------------------------------------------------------
  def eagle_get_pop_obj
    id = game_message.pop_params[:id]
    if @in_map && id == 0
      @pop_on_map_chara = true
      return $game_map.events[@para_params[:id]]
    end
    super
  end
end
#==============================================================================
# ○ 绑定
#==============================================================================
class << DataManager
  #--------------------------------------------------------------------------
  # ● 初始化模块
  #--------------------------------------------------------------------------
  alias eagle_message_para_init init
  def init
    MESSAGE_PARA.init
    eagle_message_para_init
  end
end

#==============================================================================
# ○ Game_Player
#==============================================================================
class Game_Player
  #--------------------------------------------------------------------------
  # ● 预定场所移动的位置
  #     d : 移动后的方向（2,4,6,8）
  #--------------------------------------------------------------------------
  alias eagle_message_para_reserve_transfer reserve_transfer
  def reserve_transfer(map_id, x, y, d = 2)
    eagle_message_para_reserve_transfer(map_id, x, y, d)
    MESSAGE_PARA.lock(:player)
    MESSAGE_PARA.all_finish_sys
  end
  #--------------------------------------------------------------------------
  # ● 执行场所移动
  #--------------------------------------------------------------------------
  alias eagle_message_para_perform_transfer perform_transfer
  def perform_transfer
    eagle_message_para_perform_transfer
    MESSAGE_PARA.all_go_on
    MESSAGE_PARA.unlock(:player)
  end
end
#==============================================================================
# ○ Scene_Base
#==============================================================================
class Scene_Base
  #--------------------------------------------------------------------------
  # ● 开始后处理
  #--------------------------------------------------------------------------
  alias eagle_message_para_post_start post_start
  def post_start
    eagle_message_para_post_start
    MESSAGE_PARA.all_go_on
    MESSAGE_PARA.unlock(:scene_end)
  end
  #--------------------------------------------------------------------------
  # ● 基础更新
  #--------------------------------------------------------------------------
  alias eagle_message_para_update_basic update_basic
  def update_basic
    eagle_message_para_update_basic
    MESSAGE_PARA.update
  end
  #--------------------------------------------------------------------------
  # ● 结束前处理
  #--------------------------------------------------------------------------
  alias eagle_message_para_pre_terminate pre_terminate
  def pre_terminate
    MESSAGE_PARA.lock(:scene_end)
    MESSAGE_PARA.all_finish_sys
    eagle_message_para_pre_terminate
  end
end

#==============================================================================
# ○ 地图事件的并行对话
#==============================================================================
class Game_Event < Game_Character
  #--------------------------------------------------------------------------
  # ● 设置事件页
  #--------------------------------------------------------------------------
  alias eagle_message_para_setup_page setup_page
  def setup_page(new_page)
    eagle_message_para_setup_page(new_page)
    set_para_message
  end
  #--------------------------------------------------------------------------
  # ● 设置注释中的“标签序列”
  #--------------------------------------------------------------------------
  def set_para_message
    @eagle_message_para = {} # type => [list_str, list_params] # 每种一个
    t = EAGLE.event_comment_head(@list)
    hash = MESSAGE_PARA.parse_event_list_str(t) # params => list_str
    hash.each do |key, value|
      hash_ = {}; MESSAGE_EX.parse_param(hash_, key)
      hash_ = MESSAGE_PARA.event_init_params(hash_)
      @eagle_message_para[hash_[:type]] = [value, hash_]
    end
  end
  #--------------------------------------------------------------------------
  # ● 更新
  #--------------------------------------------------------------------------
  alias eagle_message_para_update update
  def update
    eagle_message_para_update
    return if MESSAGE_PARA.lock?
    @eagle_message_para.each do |type, param|
      flag = method("check_message_para_#{type}").call(param[1])
      add_para_message(flag, param[0], param[1])
    end
  end
  #--------------------------------------------------------------------------
  # ● 新增一个“标签序列”（在一次激活后，不重复处理）
  #--------------------------------------------------------------------------
  def add_para_message(flag, list_msg, list_params)
    if flag # flag 为 true 代表满足对话生成条件
      if !list_params[:active] # 防止二次覆盖
        list_params[:active] = true
        MESSAGE_PARA.add(@id, list_msg)
      end
    else
      if list_params[:active]
        list_params[:active] = false
        MESSAGE_PARA.list_finish(@id)
      end
    end
  end
  #--------------------------------------------------------------------------
  # ● 检查“玩家邻近”的并行对话
  #--------------------------------------------------------------------------
  def check_message_para_near(list_params)
    d = distance_x_from($game_player.x).abs + distance_y_from($game_player.y).abs
    d <= list_params[:d]
  end
  #--------------------------------------------------------------------------
  # ● 检查“自动执行”的并行对话
  #--------------------------------------------------------------------------
  def check_message_para_auto(list_params)
    # 若已经生成，则保证一直满足条件让它更新
    return true if MESSAGE_PARA.list_exist?(@id)
    return false if list_params[:tc].nil?
    list_params[:tc] -= 1
    if list_params[:tc] <= 0
      list_params[:tc] = list_params[:t]
      return true
    end
    return false
  end
  #--------------------------------------------------------------------------
  # ● 检查“鼠标停留”的并行对话
  #--------------------------------------------------------------------------
  def check_message_para_mouse(list_params)
    x_ = Mouse.x / 32 + $game_map.display_x
    y_ = Mouse.y / 32 + $game_map.display_y
    d = distance_x_from(x_).abs + distance_y_from(y_).abs
    d <= list_params[:d]
  end
end

class Scene_Map < Scene_Base
  #--------------------------------------------------------------------------
  # ● 开始后处理
  #--------------------------------------------------------------------------
  alias eagle_message_para_map_post_start post_start
  def post_start
    eagle_message_para_map_post_start
    $game_map.events.each { |id, e| e.set_para_message }
  end
end
