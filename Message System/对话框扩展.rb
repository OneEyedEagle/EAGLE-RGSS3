#=============================================================================
# ■ 对话框扩展 by 老鹰（http://oneeyedeagle.lofter.com/）
#=============================================================================
$imported ||= {}
$imported["EAGLE-MessageEX"] = true
#=============================================================================
# - 2020.10.8.19 新增显示隐藏的扩展方法
#=============================================================================
# 【兼容模式】
#
# - 本模式用于与其他对话框兼容，确保其他对话框能够正常使用
#
# - 若此常量被设为 true，则本对话框不再默认生效
#
# - 只有当 $game_message.eagle_message 被赋值为 true 时，
#   本对话框才会在地图/战斗中生效，且覆盖默认对话框
#----------------------------------------------------------------------------
EAGLE_MSG_EX_COMPAT_MODE = false
#----------------------------------------------------------------------------
# ● 转义符释义
#----------------------------------------------------------------------------
# - 对话框中对于 \code[param] 类型的转义符，传入param串、并执行code相对应的指令
# - code 指令名解析：
#     下述列举出的转义符（英文字符组合）
# - param 变量参数字符串解析：
#     param 由 变量名（字母组合）+ 参数值（整数或nil（用$代表传入nil）） 重复构成
#    当传入 无变量名 的 参数值 时，将存入其【默认】变量
#    而未被传入值的 变量 ，将读取上一次所设置的通用值
#   （带有【重置】的变量，每一次进行转义符设置时，都会先重置为预设值）
# - 示例：
#     \foo[1b-1tc0d$] 【默认】变量名称 a
#    → 调用 foo 所对应的指令，并给所有变量传入预设值
#      再给 a 变量传入值 1，b 变量传入值 -1，tc 变量传入值 0，d 变量传入值 nil
# - 注意：
#    ·转义符的全部内容（\code[param]）均不会被绘制
#    ·指令和变量参数字符串的大小写差异不会影响读取
#    ·转义符会在绘制到达时生效
#      但若有【预先】，则会在绘制开始前生效（绘制到达时不会再次生效）
#      但若有【结尾】，则只在全部文字绘制完成后生效
#----------------------------------------------------------------------------
# ● 转义符及其变量列表
#----------------------------------------------------------------------------
# - 文本替换类
#     此类别的转义符将会在绘制开始前，预先进行目标文本的替换
#     将按照下面的排列顺序进行先后替换，因此请注意相互之间的嵌套模式
#
#  \conv[string] → 替换成 CONVERT_ESCAPE 中设置的 string 符号对应的文本内容
#
#  \rb{string} → 替换成 eval(string) 的返回结果
#    【注意】该转义符使用花括号，同时 string 中不可以出现花括号
#    可用 s 代替 $game_switches ，用 v 代替 $game_variables
#
#  \info[type+id] → 替换成指定数据库对象的 图标+名称 的文本
#    type → 数据库对象的类型（s代表技能，i代表物品，w代表武器，a代表防具）
#    id → 数据库对象的序号
#    示例：\info[i16] → 绘制 16号物品 的 图标+名称
#
#  \nl → 替换成换行转义符 \n（效果等同编辑器中的手动回车）
#    （由于编辑器自身限制，部分文本框无法识别输入的\n，因此添加该转义符）
#
#----------------------------------------------------------------------------
# - 绘制类
#     此类别的转义符将被视为绘制内容，与通常文字一样占用绘制空间
#
#  \pic[filename|param] → 在当前位置绘制指定名称的图片
#   【其中 filename 为图片的名称，可省略后缀名】
#     （图片存放于 Grphics/Pictures 目录下）
#   【其中 param 为变量参数字符串，可不写】
#      w → 指定绘制图片的宽度（默认与原图一致，若不同则利用stretch_blt进行缩放）
#      h → 指定绘制图片的高度
#      opa → 【默认】指定绘制图片的不透明度
#    示例： \pic[猫猫快乐] → 在转义符所在位置绘制目录下名称为 猫猫快乐 的图片
#    示例： \pic[猫猫疑惑|w50h50]
#          → 在转义符所在位置绘制目录下名称为 猫猫疑惑 的图片，且指定宽度高度为50
#
#----------------------------------------------------------------------------
# - 控制类
#     对于带有 是否 描述的bool变量，数字0 代表 false，正数（推荐数字1）代表 true
#     对于未说明 nil 效果的变量，请尽量不要传入 nil（传入符号$代表传入nil）
#
#  \c[id] → 变更文字的绘制颜色，扩展了默认的\c[id]转义符
#            其中 id 可传入 TEXT_COLORS 常量中所设置的字符串，将匹配其对应的颜色
#            如 \c[pink] 将使用 "pink" 所对应的 Color 作为文字颜色
#            若匹配失败，将执行 id.to_i 转为数字，选择窗口皮肤的索引颜色
#
#  \font[param] → 设置单个字的绘制选项（默认取Font模块的设定）
#    size → 【默认】字体大小
#    i → 是否斜体（font.italic）
#    b → 是否加粗（font.bold）
#    s → 是否添加阴影（font.shadow）
#    ca → 文字的不透明度（0~255）
#    o → 是否添加边框（font.outline）
#    or/og/ob/oa → 设置边框颜色RGBA（0~255）
#    p → 底部花纹的类型（0不绘制，1边框，2实心方框）
#    pc → 底部花纹的颜色索引号（具体查看 Window.png 右下角部分，同默认\c[id]转义符）
#    l → 是否绘制外发光（若开启，则强制关闭阴影和边框）
#    lc → 外发光的颜色索引号
#    lp → 外发光的强度
#    d → 是否绘制删除线
#    dc → 删除线的颜色索引号
#    u → 是否绘制下划线
#    uc → 下划线的颜色索引号
#
#  \win[param] → 对话框窗口的基本设置
#  （窗口属性相关）
#    z → 对话框的z值（仅正整数有效）（默认取va设置的200）
#    skin → 对话框所用windowskin的index（按常量设置进行 index → skin名称 映射）
#    bg → 对话框背景图片的index（按常量设置进行 index → 图片名称 映射）
#        （只有当事件指令-显示文字-窗口背景为普通窗口时，才生效）
#        （若读取成功，将不显示窗口皮肤；若读取失败，仍绘制窗口皮肤）
#    bgo → 对话框背景图片与对话框的对齐原点（对应九宫格小键盘）
#        （默认背景图片的左上角与对话框左上角对齐7）
#  （窗口位置相关）
#    o → 【默认】对话框的显示原点的位置类型（对应九宫格小键盘）（默认左上角7）
#    x/y → 对话框显示原点的屏幕坐标（默认nil，取va设置）
#    do → 基于屏幕的九宫格划分，对话框显示原点的屏幕坐标类型（覆盖x/y）
#        （参考九宫格小键盘，有效值为-1~-9）
#    dx/dy → x、y坐标的补足偏移量（默认0）
#    fix → 是否修正对话框位置（保证对话框完整显示在屏幕内）
#  （窗口大小相关）
#    w → 窗口内容的固定宽度（不含边框）（默认0不设置）（优先级高于dw和fw）
#    dw → 窗口内容宽度是否随文字绘制而动态变更（默认false）
#    fw → 窗口内容宽度是否指定为全部文字绘制完成时的所需宽度值（优先级高于dw）
#    wmin/wmax → 窗口内容宽度的上下限（启用dw/fw时生效）（默认0不设置）
#    h → 窗口内容的固定高度（不含边框）（默认0不设置）（优先级高于dh和fh）
#       （若小于对话框的 line_height 方法值，则识别为行数，并进行二次计算）
#    dh → 窗口内容高度是否随文字绘制而动态变更（默认false）（不翻页）
#    fh → 窗口内容高度是否指定为全部文字绘制完成时的所需高度值（优先级高于dh）
#    hmin/hmax → 窗口内容高度的上下限（启用dh/fh时生效）（若小于行高，则修正为行数）
#  （文本显示相关）
#    se → 启用的打字音类型index（默认0，按常量设置进行 index → 声效SE设置 映射）
#    ali → 文本的对齐方式（0左对齐，1居中对齐，2右对齐；默认0）
#    ck → 缩减的字符间距值（默认0）
#    lh → 设置基础行高 line_height 值（默认0无效，取原方法值）
#    ld → 增加的行间距值（默认0）（默认行间距为0）（每一行行高将取其最大字号）
#    cwi → 单个文字绘制完成后的等待帧数（最小值0）
#    cwo → 单个文字移出开始后的等待帧数（最小值0）
#    cor → 全部文字移出的顺序类型（0正序，1逆序，2乱序，默认0）
#    cfast → 是否允许按键快进（默认true）
#    cdx/cdy/cdw → 文本绘制区域与窗口左侧/上侧/右侧padding的间距（默认0）
#
#  \pop[param] → 启用气泡类型对话框时的设置
#  （窗口属性相关）
#    skin → pop状态下对话框所用皮肤的index（按常量设置进行 index → skin名称 映射）
#         （默认nil，取win转义符中的skin变量的值）
#  （窗口位置相关）
#    id → 【重置】【默认】所绑定对象的id
#     【地图】传入 0 时取执行当前对话框的事件的id
#            传入 正数id 时取当前地图id号的事件，目标事件不存在时取当前事件
#            传入 负数id 时取队列中数据库id号的角色，目标角色不在队伍中时取队首角色
#     【战斗】传入 正数id 时取敌群中index序号为id的敌人，目标敌人不存在时pop无效
#            传入 负数id 时取我方参战角色中数据库id号的角色，目标角色不存在时pop无效
#    mx/my → 【重置】绑定到地图的 (mx, my) 处（同编辑器坐标）（格子中心为显示原点）
#           （当未设置id时，才会应用该变量）
#    do → 对话框相对于绑定对象的位置类型（默认8，即对话框位于目标顶部中间）
#         （基于绑定对象的九宫格小键盘位置，5代表目标中心）
#    o → 对话框显示原点类型
#         （若为nil，则为 10-do，即当do为8时，对话框显示原点为底部中点2）
#    d → 对话框显示原点远离绑定对象的中心点的像素值（依据do自动选择增减x或y）（默认0）
#    dx/dy → x、y方向上的补足偏移量（默认0）
#    fix → 是否进行位置修正（保证pop对话框完整显示在屏幕内）
#  （窗口大小相关）
#    w → pop对话框的内容固定宽度（覆盖win中的w）（默认0不设置）（优先级高于dw/fw）
#    h → pop对话框的内容固定高度（覆盖win中的h）
#       （若小于对话框的 line_height 方法值，则认定为行数，并进行二次计算）
#    dw → 是否随文字绘制而动态变更pop对话框的内容宽度（默认false）
#    fw → 是否指定为全部文字绘制完成时的所需宽度值（覆盖dw）
#    dh → 是否随文字绘制而动态变更pop对话框的内容高度（默认false）（不翻页）
#    fh → 是否指定为全部文字绘制完成时的所需高度值（覆盖dh）
#
#  \popt[param] → 【预先】指向性箭头的设置（当对话框为pop类型时才显示）
#    tag → 【默认】所用箭头图片的index（按常量设置进行 index → tag名称 映射）
#    td → 设置与所绑定对象的中心的远离偏移值（按pop的do自动设置xy）（默认0）
#
#  \face[param] → 脸图的动态设置
#    【注】脸图文件名包含 _数字1x数字2 时（其中为字母x），
#         将设置该脸图文件的规格为 行数（数字1）x列数（数字2）（默认2行x4列）
#     示例： face_actor_1x1.png → 该脸图规格为 1×1，含有一张脸图，只有index为0有效
#    i → 【重置】【默认】显示当前文件中指定序号的脸图（默认同va对话框传入参数）
#    ls/le → 【重置】定义脸图自动播放的开始index/结束index（-1时不启用自动播放）
#    lt → 循环播放时，每两帧之间的等待间隔帧数
#    lw → 循环播放时，每一次loop结束时的等待帧数（nil代表不循环）
#
#  \facep[param] → 【预先】脸图的基础设置
#    dir → 【默认】脸图的显示位置（0左侧，1右侧；默认0）
#    m → 是否镜像显示脸图（默认false）
#    it → 脸图淡入时所用帧数
#    ot → 脸图淡出时所用帧数
#    dx → 脸图在x方向上的偏移增量（默认0）
#    dy → 脸图在y方向上的偏移增量（默认0）
#    dw → 当嵌入对话框内时，脸图宽度的补足增量（默认0）
#    z → 脸图的z值增量（默认1，在对话框上面）（在对话框下面时，将不占用对话框宽度）
#
#  \facem[str|param] → 执行脸图动作
#                其中 str 替换成下列的脸图动作（英语字符串）
#                其中 |param 可选，替换为对应动作的变量参数字符串
#    【注】脸图动作期间，对话框不会暂停绘制，请自行调用 wait 转义符进行等待。
#          若在执行动作时，又呼叫了一些新的动作，
#          则在当前动作执行完成后，只会继续执行最后传入的一个动作。
#    jump → 脸图进行一次短暂跳跃（无可设置参数）
#            使用示例： \facem[jump] 脸图小幅度跳跃一次
#    move → 脸图移动到指定位置
#           x/y → 直接指定移动的目的地（以初始显示位置为原点）
#         dx/dy → 指定移动在当前坐标基础上的相对偏移量
#             t → 移动所需的时间（三次立方平滑）
#            使用示例： \facem[move|dx50] 脸图朝右侧移动50像素
#
#  \name[param] → 【预先】姓名框的设置
#    【注】param 中用 | 分隔 姓名字符串（其中转义符用<>代替[]）与 变量参数字符串
#      （若无变量参数的设置，可省略 | 符号）
#    skin → 姓名框所用皮肤的index（默认nil，同win中设置）
#    size → 姓名框文字大小
#    bg → 姓名框背景图片的index（按常量设置进行 index → 图片名称 映射）
#        （若读取成功，将不显示窗口皮肤；若读取失败，仍绘制窗口皮肤）
#    bgo → 姓名框背景图片与姓名框的对齐原点（对应九宫格小键盘）
#        （默认背景图片的左上角与姓名框左上角对齐7）
#    o → 姓名框的显示原点的类型（对应九宫格小键盘）（默认左上角7）
#    do → 基于对话框的九宫格位置，姓名框的显示原点所在位置（默认左上角7）
#    dx/dy → x、y坐标的补足偏移量
#    opa → 姓名框背景的不透明度（默认255）（文字的不透明度锁定为255）
#
#  \pause[param] → 等待按键时的帧动画的设置
#    pause → 【默认】等待按键帧动画的类型（按常量设置进行 index → pause参数组 映射）
#    o → 帧动画的显示原点位置类型（九宫格小键盘）（默认左上角7）
#    do → 基于对话框的九宫格位置，自身显示位置的类型（0时显示在文末）（默认2）
#    dx/dy → xy方向上的补足偏移值（默认0）
#    t → 每两帧之间的等待帧数（默认10）
#    v → 是否显示等待按键的帧动画（默认true）
#
#  \shake[param] → 对话框震动（与事件指令中的屏幕震动一致）并等待至结束
#    p → 震动的强度（默认5）
#    s → 震动的速度（默认5）
#    t → 【默认】震动的持续帧数（将补足平滑结束的帧数）（默认40）
#
#  \wait[param] → 等待
#   （注意：和默认的等待类型转义符保持一致，不会被快进跳过、期间不处理按键）
#    t → 【默认】等待的帧数
#
#  \auto[param] → 等待按键时，自动继续的设置
#    若使用了【组件-形状绘制 by老鹰】，则会在对话框右下角绘制简单的倒计时UI
#    t → 【默认】在t帧后自动结束按键等待，并继续事件处理（默认nil，不自动继续）
#    r → 是否为 t 参数附加【重置】属性，即每次对话框打开后不自动继续（默认false）
#
#  \ins → 【预先】当前对话框不再处理绘制间隔的等待（先完成打开，再绘制全部内容）
#
#  \hold → 【结尾】保留当前对话框，直至没有该指令的对话框关闭，关闭所有保留的对话框
#
#  \temp → 【结尾】当前对话框对转义符参数的变更不会被保留
#          （在当前显示文本指令结束前，转义符参数的修改仍然生效）
#
#  \close → 【结尾】当前对话框不再受 settings_changed? 影响，必定处理关闭
#
#----------------------------------------------------------------------------
# - 文字特效类
#     以下 param 传入 任意非0非空字符（如 1） 代表以预设值开启特效
#     只传入 0 代表关闭该特效
#    （除非标注【叠加】，否则多特效同时执行可能会造成奇怪效果）
#
#  \cin[param] → 开启文字移入的特效【独占】（移入完成时才进行其余特效更新）
#    r → 是否将以下全部变量的值变更为正负范围内的随机数？
#         比如传入的 vx5，则实际的 vx 为 -5 ~ 5 中随机一个值
#    t → 移入所用帧数（即移动到最终位置所用帧数）（不透明度从0平滑增加到255）
#    vzt/vz → 每zvt（最小值1）帧zoom放缩值增加vz的值（整数）
#    va → 每帧内angle的增值
#  （以下参数不受 r 的影响）
#    do → 移入前所在位置
#        （大于0时为对话框的九宫格位置，小于0时为屏幕九宫格位置，0时最终显示位置）
#    dx/dy → 移入前所在位置的偏移量
#          如：do5dx0dy0 就是文字从对话框中心位置移入到最终显示位置
#    vo → 每帧不透明度的增量（默认为 255/t）
#    rxt/rx → 每rxt（最小值1）帧src_rect的x偏移值增加rx像素的值（默认0）
#    ryt/ry → 每ryt（最小值1）帧src_rect的x偏移值增加ry像素的值（默认0）
#
#  \cout[param] → 开启文字移出的特效【独占】（移出时关闭其余特效更新）
#    r → 是否将以下全部变量的值变更为正负范围内的随机数？
#         比如传入的 vx5，则实际的 vx 为 -5 ~ 5 中随机一个值
#    t → 移出所用帧数（即移动到最终位置所用帧数）（不透明度从255平滑减小到0）
#    vzt/vz → 每zvt（最小值1）帧zoom放缩值增加vz的值（整数）
#    va → 每帧内angle的增值
#  （以下参数不受 r 的影响）
#    do → 移出后所在位置
#        （大于0时为对话框的九宫格位置，小于0时为屏幕九宫格位置，0时当前位置）
#    dx/dy → 移出后所在位置的偏移量
#          如：do5dx0dy0 就是文字移出到对话框中心位置
#    vo → 每帧不透明度的减量（默认为 255/t）
#    rxt/rx → 每rxt（最小值1）帧src_rect的x偏移值增加rx像素的值（默认0）
#    ryt/ry → 每ryt（最小值1）帧src_rect的x偏移值增加ry像素的值（默认0）
#
#  \uout[param] → 利用消散移出文字【需要前置Unravel_Bitmap插件】
#    n → 消散的粒子总数（大约）
#    d → 单个粒子的大小（直径/边长）
#    o → 单个粒子消失时的透明度变更最小值
#    dir → 整体消散方向类型（同九宫格小键盘）（1379-四角；5-四方向；46-左右向上）
#    s → 粒子形状类型（0-正方向；1-圆形；2-三角形）
#
#  \csin[param] → 开启正弦波浪扭曲特效
#    a → 正弦波浪的幅度（像素数）
#    l → 正弦波浪的频度（像素数）
#    s → 正弦波浪的动画速度（默认360）
#    p → 正弦波浪的相位角度（最大360°）（一般不需要设置）
#
#  \cwave[param] → 开启上下浮动特效
#    h → 上下浮动的最大偏移像素值
#    t → 每隔t帧进行一次1像素的偏移
#    vy → 起始时的y方向移动速度（正数为向下）
#
#  \cswing[param] → 开启左右摇摆特效（本质为精灵旋转）
#    d → 每次更新增加的角度值（0时随机取正负1）
#    t → 每次角度更新后等待t帧
#    a → 角度可到达的最大值（左右对称）
#    o → 摇摆不动点所在位置类型（键盘九宫格）
#
#  \czoom[param] → 开启缩放特效（本质为精灵缩放）
#    t → 在进行一次缩放变更后的等待帧数
#    dx → x方向的每次缩放增量（单位%，即 1 代表每t帧放大1%，zoom_x增加0.01）
#    dy → y方向的每次缩放增量（单位%，即 1 代表每t帧放大1%，zoom_y增加0.01）
#    o → 缩放不动点所在位置类型（键盘九宫格）
#    min → x和y方向上缩放总量的最小值
#          （在RGSS3中，负数的缩放量不会显示，推荐设置为自然数）
#          （在RGD中，负数的缩放量将反向显示，推荐设置为最大值的相反数）
#    max → x和y方向上缩放总量的最大值
#
#  \cshake[param] → 开启抖动特效
#    l/r/u/d → 设置 左右上下 四个方向的最大移动偏移值
#    vx/vy → 设置x、y方向上的初始移动速度（正数为向右、向下）（0为随机方向）
#    vxt/vyt → 设置x、y方向上移动一次后的等待帧数
#
#  \cflash[param] → 开启闪烁特效【叠加】
#    r/g/b/a → 闪烁的颜色（红、绿、蓝、不透明度）（默认255）（示例：r50g50b100a200）
#    d → 闪烁从开始到完成需要的帧数
#    t → 闪烁完成后的等待帧数
#
#  \cmirror[param] → 开启横轴镜像绘制（无设置参数）【叠加】
#
#  \cu[param] → 开启字符消散特效【叠加】【需要前置Unravel_Bitmap插件】
#    t → 每两次执行消散之间的间隔帧数（正整数）
#    其余同 \uout 的变量
#
#  \ctog[param] → 开启文字切换特效（本质为位图切换）
#    i → 使用 i 号对应的文字组（具体见 CTOG_CHARAS 常量，设置 i → 文字组）
#    n → 从文字组中挑选出 n 个字符作为切换文字（若为0，则取全部）
#    t → 文字切换一次后的等待帧数
#    r → 是否启用随机切换
#
#  \cgrad[param] → 开启文字渐变更新特效（本质为精灵color属性的叠加）
#    t → 颜色之间的渐变帧数
#    c → 【可重复填写】指定渐变颜色的索引号
#        从 当前颜色开始（默认0号颜色），按照传入顺序依次渐变
#        如 \cgrad[t60c1c10c17] 将会按照 0→1→10→17→1→10→17... 进行渐变
#
#  \cmc[param] → 叠加绘制文字
#    i → 使用 i 号对应的文字组（具体见 CMC_CHARAS 常量，设置 i → 文字组）
#    n → 从文字组中挑选出 n 个字符作为切换文字（若为0，则取全部）
#    c → 指定叠加绘制的文字的颜色索引号（-1时与原始文字颜色一致）
#
#----------------------------------------------------------------------------
# - 高级
#    此处放置高级处理，需要结合一定的脚本知识才能灵活运用
#
#  \eval{string} → 当绘制到该转义符时，执行 eval(string)，并丢弃返回值
#    【注意】该转义符使用花括号，同时 string 中不可以出现花括号
#    可用 s 代替 $game_switches ，用 v 代替 $game_variables
#    可用 msg 代表当前对话（Window_Message类的实例）
#      如 \eval{s[1]=true} 就是当文字绘制到该转义符时，打开1号开关，并继续绘制
#    【注意】由于文本替换类的转义符优先级最高，因此实际绘制文本不受这个的影响
#            即如果存在 \eval{v[1]=5}\v[1]，其中1号变量初值为0，
#            那么尽管在绘制过程中其值变为了5，但\v[1]显示的仍然为对话框打开时的值0
#
#  \set[sym] → 创建新分组，其唯一标识为 sym（字符串）
#
#  Window_Message类新增方法 chara_set(sym) { |s| do_something }
#     该方法能够用于对 sym 分组中的文字精灵进行逐个操作，
#     若 不传入sym 或 传入 0 或 传入 '0' 或传入 ""，则转为对全部文字精灵进行操作
#
#  \setm[sym|effect|param] → 对sym分组中的文字精灵，执行 effect特效，传入 param 参数
#      其中 sym 将被作为字符串，来索引对应分组
#      其中 effect 为 文字特效类转义符 中的转义符，比如 ctog
#      其中 param 为传入的文字特效的变量参数字符串，与 文字特效类 中所写一致
#                 若只传入 0，则为关闭该特效
#
#      如：\setm[0|ctog|0] 代表关闭全部文字精灵的ctog特效
#      如：\set[1]\ctog[1]测试用文字\ctog[0]\set[0]，\!第二句话\setm[1|ctog|0]
#            代表关闭 1 号组中 “测试用文字” 的 ctog 特效
#
#----------------------------------------------------------------------------
# - 扩展
#     此处放置整合其他插件效果的转义符，统一放置于 $game_message.ex_params 中
#
#  \cg[c1..] → 渐变描绘文本【需要前置Sion_GradientText插件】
#    变量参数字符串为按序排列的 c + Windowskin颜色索引号，无任何参数时取消渐变绘制
#    示例：\cg[c1c2c1] → 用 1号 2号 1号颜色由上至下进行渐变绘制
#    示例：\cg[] → 取消渐变绘制
#
#----------------------------------------------------------------------------
# ● 高级功能
#----------------------------------------------------------------------------
# - 自动换行
#
#   利用该脚本设置对话框自动换行的开启状态（默认 true）
#
#         $game_message.auto_wrap = true 或者 false
#
# · 若开启，当文字绘制到对话框边界padding处时，将进行自动换行
# · 只是非常基础的按单个文字切割的自动换行方式，会切割单词，不考虑标点符号
#----------------------------------------------------------------------------
# - 内容滚动
#
# · 当对话框的宽度或高度被固定时，
#    若所绘制的文字超出对话框范围，将自动开启内容滚动效果
#
# · 当进入 等待按键 状态时，按住 方向键 即可朝对应方向滚动浏览对话框全部内容
#----------------------------------------------------------------------------
# - 对话框Open/Close方式扩展
#
#   对话框的开启关闭方式已经得到了扩展：
#   利用该脚本设置对话框开启方式类型和关闭方式类型
#
#          $game_message.open_type = :ease 或 :fade 或 :default
#          $game_message.close_type = :ease 或 :fade 或 :default
#
# · 若赋值为 :default，则使用默认的上下打开关闭
#   若赋值为 :ease，则使用 动态缩放展开
#   若赋值为 :fade，则使用淡入淡出
#----------------------------------------------------------------------------
# - 并行处理子窗口
#
#   利用该脚本设置对话框与下一条指令的 选择框/数字输入框/物品选择框 并行处理
#
#         $game_message.para = true 或 false
#
# · 当赋值为 true 时，若对话框的下一条指令为 选择支/数字输入/物品选择，
#      则会在对话框打开、开始绘制文字时，同步打开并激活选择框/数字输入框/物品选择
#
# · 当子窗口的按键处理结束并关闭时，对话框将同步强制关闭
#    【注意】对话框中未被绘制的转义符可能不会生效！
#----------------------------------------------------------------------------
# - 预定绘制文本
#
#   利用该脚本存储文本，在下次打开对话框时，全部存储文本将按序插入到对话开头
#
#        $game_message.add_escape(param_string)
#
#   param_string 解析： 【String】型常量
#
# · 示例：
#     $game_message.add_escape("\\win[ali1]")
#        → 之后的对话框中 文本居中 绘制
#     $game_message.add_escape("\\pop[0]")
#        → 下一次的对话框为pop类型，绑定在当前执行对话框的事件上
#
# · 注意：
#    ·由于解析问题，在 param_string 中请将 "\" 替换成 "\\"
#    ·当存在多条预定文本，将按照预定时间的先后顺序，依次放入下一次对话框的开头
#    ·预定的字符串只会被放入对话框一次
#    ·不会去除 param_string 中的非转义符文本
#----------------------------------------------------------------------------
# - 参数重置
#
#   利用该脚本重置指定转义符的指定变量（用预设值覆盖）
#
#        $game_message.reset_params(param_sym, code_string)
#
# · param_sym 解析： 【Symbol】型常量
#   【注意】若传入的 param_sym 为 nil，则将重置以下所有类型
#     :font → 重置关于字体的设置
#     :win  → 重置关于对话框的设置
#     :pop  → 重置关于pop类型对话框与pop的tag类型的设置
#     :face → 重置关于脸图显示的设置
#     :name → 重置关于姓名框的设置
#     :pause- 重置关于pause等待按键的精灵的设置
#     :chara → 重置关于文字特效的设置（其参数为文字特效转义符）
#     :ex → 重置扩展类转义符为预设的变量参数（其参数为扩展类转义符）
#
# · code_string 解析： 【String】型常量
#     可利用 | 将多个变量进行分割
#     若未传入该参数，则将重置全部变量
#
# · 示例：
#     $game_message.reset_params(:font, "i") → 重置字体是否斜体的参数
#     $game_message.reset_params(:win, "x|y") → 重置对话框的xy坐标（取默认va设置）
#     $game_message.reset_params(:pop) → 清除pop转义符的全部设置
#     $game_message.reset_params(:chara, "cin")
#       → cin转义符的参数重置为 CHARA_PARAMS_INIT 中的:cin键值，
#         若常量中无该键，则取消cin特效
#----------------------------------------------------------------------------
# - 参数保存与读取
#
#   利用该脚本保存当前全部 param_sym 参数组的状态值
#   （当不传入 sym 时默认取 :default 类别）
#   （由于涉及内部对话框临时参数的实现方式，请不要用 :temp 类别）
#
#         $game_message.save_params(sym)
#
#   利用该脚本使 param_sym 所对应的变量组恢复到上一次的保存状态
#   （当不传入 sym 时默认取 :default 类别）
#
#         $game_message.load_params(param_sym, sym)
#
#   param_sym 解析：【Symbol】型常量
#      具体见 参数重置 中的解析
#
# · 示例：
#     $game_message.save_params
#     $game_message.load_params(:font)
#       → 按 :default 存储的状态，来恢复字体的全部参数
#     $game_message.save_params("测试")
#     $game_message.load_params(:pause, "测试")
#       → 按 "测试" 存储的状态，来恢复pause精灵的全部参数
#----------------------------------------------------------------------------
# ● 特别感谢
#----------------------------------------------------------------------------
# - 葱兔（http://onira.lofter.com/）
#=============================================================================

#=============================================================================
# ○ 【设置部分】
#=============================================================================
module MESSAGE_EX
  #--------------------------------------------------------------------------
  # ● 【设置】定义控制类转义符各参数的预设值
  # （对于bool型变量，0与false等价，1与true等价）
  #--------------------------------------------------------------------------
  FONT_PARAMS_INIT = {
  # \font[]
    :size => Font.default_size, # 字体大小
    :i => Font.default_italic, # 斜体绘制
    :b => Font.default_bold, # 加粗绘制
    :s => Font.default_shadow, # 阴影
    :ca => 255, # 不透明度
    :o => Font.default_outline, # 描边
    :or => Font.default_out_color.red,
    :og => Font.default_out_color.green,
    :ob => Font.default_out_color.blue,
    :oa => Font.default_out_color.alpha,
    :p => 0, # 底纹
    :pc => 0, # 底纹颜色index
    :l => 0, # 外发光
    :lc => 0, # 外发光颜色index
    :lp => 2, # 外发光强度
    :d => 0, # 删除线
    :dc => 0, # 删除线颜色index
    :u => 0, # 下划线
    :uc => 0, # 下划线颜色index
  }
  WIN_PARAMS_INIT = {
  # \win[]
    # 窗口属性相关
    :z => 200,
    :skin => 0, # 对话框所用windowskin的类型
    :bg => nil, # 对话框背景所用图片（覆盖窗口皮肤）
    :bgo => 7,  # 对话框背景图片与对话框的对齐原点
    # 窗口位置相关
    :o => 7, # 原点位置类型 默认为7左上角
    :x => nil, # 原点坐标xy
    :y => nil,
    :do => 0, # 相较于屏幕的九宫格位置（覆盖x/y的设置）
    :dx => 0, # 坐标偏移值xy
    :dy => 0,
    :fix => 1, # 是否进行位置修正，防止对话框跑出屏幕
    # 窗口大小相关
    :w => 0,
    :h => 0,
    :dw => 0, # 若为1，则代表宽度会依据文字动态调整
    :fw => 0, # 若为1，则窗口打开时即为文字绘制完成时所需宽度值
    :wmin => 0, # 设置宽度的上下限（当dw==1时生效）
    :wmax => 0, # （有脸图时宽度会自动增加脸图宽度）
    :dh => 0, # 若为1，则代表高度会依据文字动态调整
    :fh => 0, # 若为1，则窗口打开时即为文字绘制完成时所需高度值
    :hmin => 0, # 设置高度的上下限（当dh==1时生效）
    :hmax => 0,
    # 文本显示相关
    :se => 0, # 打字音类型（默认0，无声效）
    :ali => 0, # 设置文本对齐方式
    :ck => 0, # 缩减的字符间距值
    :lh => Font.default_size, # 基础行高
    :ld => 4, # 增加的行间距值
    :cwi => 2, # 单个文字绘制后的等待帧数（最小值0）
    :cwo => 0, # 单个文字开始移出后的等待帧数（最小值0）
    :cor => 0, # 全部文字移出的顺序类型
    :cfast => 1, # 是否允许快进
    :cdx => 0, # 文本左侧与窗口padding的间距
    :cdy => 0, # 文本上边距
    :cdw => 0, # 文本右边距
  # \auto[]
    :auto_t => nil,   # 在 t 帧后自动继续对话
    :auto_r => 0,  # 是否重置 t 参数
  }
  POP_PARAMS_INIT = {
  # \pop[]
    :skin => nil, # pop模式下所用skin类型
    :do => 8, # 对话框相对于绑定对象的位置（九宫格小键盘）
    :o => nil, # 对话框显示原点，若为nil，则取 10 - :do
    :d => 0, # 指定原点距离事件格子中心的偏移量
    :dx => 0,  # 指定x、y方向上的偏移量
    :dy => 0,
    :fix => 0, # 是否进行位置修正
    :w => 0, # 指定固定的宽度和高度（优先级高于win_params）
    :h => 0,
    :dw => 0, # 若为1，则代表宽度会依据文字动态调整
    :fw => 1, # 若为1，则窗口打开时将预绘制成文字区域最终大小
    :dh => 0, # 若为1，则代表高度会依据文字动态调整
    :fh => 1, # 若为1，则窗口打开时将预绘制成文字区域最终大小
  # \popt[]
    :tag => 1, # tag所用文件名index（0时表示不启用）
    :td => 3, # 与绑定事件格子中心位置的偏移值
  }
  FACE_PARAMS_INIT = {
  # \face[]
    :lt => 30, # 循环时，每两帧之间的间隔
    :lw => 60, # 循环后，等待帧数
  # \facep[]
    :dir => 0, # 脸图显示方向 1为右侧
    :m => 0, # 脸图镜像显示
    :it => 15, # 脸图移入所需帧数
    :ot => 10, # 脸图移出所需帧数
    :dx => 0, # 脸图x方向的偏移增量
    :dy => 0, # 脸图y方向的偏移增量
    :dw => 8, # 脸图显示宽度的补足量
    :z => 1, # 脸图z值增量
  }
  NAME_PARAMS_INIT = {
  # \name[]
    :o => 1, # 自身的显示原点位置
    :do => 7, # 相较于对话框的显示原点位置
    :dx => 0, # 位置的偏移增量
    :dy => 0,
    :opa => 255, # 背景不透明度
    :skin => nil, # 姓名框所用windowskin的类型（nil为与对话框一致）
    :size => Font.default_size, # 姓名框文字大小
    :bg => nil, # 姓名框背景所用图片index（覆盖窗口皮肤）
    :bgo => 7,  # 姓名框背景图片与姓名框的对齐原点
  }
  PAUSE_PARAMS_INIT = {
  # \pause[]
    :pause => 0,  # 源位图index
    :o => 4,  # 自身的显示原点类型
    :do => 0,  # 相对于对话框的显示位置（九宫格小键盘）（0时为在文末）
    :dx => 0,  # xy偏移值
    :dy => 0,
    :t => 7, # 每两帧之间的等待帧数
    :v => 1,  # 是否显示
  }
  #--------------------------------------------------------------------------
  # ● 【设置】定义初始激活的文字特效类转义符的变量参数字符串
  #--------------------------------------------------------------------------
  CHARA_PARAMS_INIT = {
  # 文字特效类转义符sym => 变量参数字符串"code_string"
    #:cin => "1",
  }
  #--------------------------------------------------------------------------
  # ● 【设置】定义文字特效类转义符各参数的初始值
  #--------------------------------------------------------------------------
  CIN_PARAMS_INIT = {
  # \cin[]
    :r => 0, # 随机取值？
    :t => 15, # 移入所用帧数
    :do => 0, # 移入前所在位置
              #（大于0时为对话框的九宫格位置，小于0时为屏幕九宫格位置，0时最终显示位置）
    :dx => 0, # 移入前所在位置的偏移量
    :dy => 0,
    :vz => 0,  # 每vzt帧zoom的增量
    :vzt => 1,
    :va => 0,  # 每帧角度增量
    :vo => 0,  # 每帧不透明度增量
    :rxt => 1, # 每rxt帧src_rect.x的增量
    :rx => 0,
    :ryt => 1, # 每ryt帧src_rect.y的增值
    :ry => 0,
  }
  COUT_PARAMS_INIT = {
  # \cout[]
    :r => 0, # 随机取值？
    :t => 15, # 移出所用帧数
    :do => 0, # 移出后所在位置
              #（大于0时为对话框的九宫格位置，小于0时为屏幕九宫格位置，0时当前位置）
    :dx => 0, # 移出后所在位置的偏移量
    :dy => 0,
    :vz => 0,  # 每vzt帧zoom的增量
    :vzt => 1,
    :va => 0,  # 每帧角度增量
    :vo => 0,  # 每帧不透明度减量
    :rxt => 1, # 每rxt帧src_rect.x的增量
    :rx => 0,
    :ryt => 1, # 每ryt帧src_rect.y的增值
    :ry => 0,
  }
  UOUT_PARAMS_INIT = {
  # \uout[]
    :n => 300, # 消散的粒子总数
    :d =>  2, # 消散的粒子的大小（直径/边长）
    :o =>  1, # 透明度变更量的最小值
    :dir => 4, # 消散方向类型
    :s =>  0, # 粒子的形状类型
  }
  CSIN_PARAMS_INIT = {
    :a => 6, # 幅度
    :l => 10, # 频度
    :s => 30, # 速度
    :p => 0, # 相位
  }
  CWAVE_PARAMS_INIT = {
  # \cwave[]
    :h  => 2,  # Y方向上的最大偏移值
    :t  => 4,  # 移动一像素所耗帧数
    :vy => -1, # 起始速度的Y方向分量（正数向下）
  }
  CSWING_PARAMS_INIT = {
  # \cswing[]
    :d => 0, # 每次更新增加的角度值（0时随机取正负1）
    :t => 1, # 每次角度更新后等待t帧
    :a => 15, # 角度可到达的最大值（左右对称）
    :o => 2, # 摇摆不动点所在位置类型（键盘九宫格）（2为底部中心）
  }
  CZOOM_PARAMS_INIT = {
  # \czoom[]
    :t => 0, # 在进行一次缩放变更后的等待帧数
    :dx => 2, # x方向的每次缩放增量（缩放总量在-100~100之间，整数）
    :dy => 0, # y方向的每次缩放增量
    :o => 5, # 缩放不动点所在位置类型（键盘九宫格）（5为中心）
    :min => 0, # xy缩放总量的最小值
    :max => 100, # xy缩放总量的最大值
  }
  CSHAKE_PARAMS_INIT = {
  # \cshake[]
    :l => 3,  # 距离所在原点的最大偏移量（左右上下）
    :r => 3,
    :u => 3,
    :d => 3,
    :vx  => 0,  # x的初始移动方向（0为随机方向）
    :vxt => 3,  # x方向移动一像素所耗帧数
    :vy  => 0,  # y的初始移动方向（0为随机方向）
    :vyt => 3,  # y方向移动一像素所耗帧数
  }
  CFLASH_PARAMS_INIT = {
  # \cflash[]
    :r => 255, # 闪烁颜色RGBA
    :g => 255,
    :b => 255,
    :a => 255,
    :d => 60,  # 闪烁帧数
    :t => 60,  # 闪烁后的等待时间
  }
  CMIRROR_PARAMS_INIT = {}
  CU_PARAMS_INIT = {
  # \cu[]
    :t => 10, # 每两次消散之间的时间间隔
    :n => 20, # 消散的粒子总数
    :d =>  2, # 消散的粒子的大小（直径/边长）
    :o =>  1, # 透明度变更量的最小值
    :dir => 4, # 消散方向类型
    :s =>  0, # 粒子的形状类型
  }
  CU_PARAM_DIR = { # 定义消散方向类型的id
    1 => :LD, 3 => :RD, 4 => :LR, 5 => :LRUD, 6 => :LR, 7 => :LU, 9 => :RU
  }
  CU_PARAM_S = { # 定义粒子形状类型的id
    0 => :S, # 正方形
    1 => :C, # 圆形（耗时）
    2 => :T  # 三角形
  }
  CTOG_PARAMS_INIT = {
  # \ctog[]
    :i => 0,  # 选取i号文字组
    :n => 0,  # 从文字组中选取n个字符
    :t => 5,  # 文字切换的等待帧数
    :r => 1,  # 是否随机选择下一个文字？
  }
  CTOG_CHARAS = { # 定义文字切换特效的文字组（若为数字，则取 IconSet 中的图标）
    0 => ['▀', '▄', '█', '▌', '✖'],
    1 => ['0','1','2','3','4','5','6','7','8','9'],
    2 => [376,377,378,379,380,381,382,383],
  }
  CGRAD_PARAMS_INIT = {
  # \cgrad[]
    :t => 60, # 颜色之间的切换帧数
  }
  CMC_PARAMS_INIT = {
  # \cmc[]
    :i => 0,  # 选取i号文字组
    :n => 0,  # 从文字组中选取n个字符（若为0，则取全部）
    :c => 10,  # 叠加绘制的文字的颜色索引号
  }
  CMC_CHARAS = { # 定义文字叠加绘制的文字组（若为数字，则取 IconSet 中的图标）
    0 => ['✖'],
    1 => [4],
  }

  #--------------------------------------------------------------------------
  # ● 【设置】定义初始激活的扩展类转义符的预设变量参数字符串
  #--------------------------------------------------------------------------
  EX_PARAMS_INIT = {
  # 渐变绘制转义符 \cg => "颜色索引字符串",
    :cg => "",
  }
  #--------------------------------------------------------------------------
  # ● 【设置】定义新游戏开始时对话框预定的转义字符串
  # （由于解析问题，字符串中请将 "\" 替换成 "\\"）
  #--------------------------------------------------------------------------
  ESCAPE_STRING_INIT = ""
  #--------------------------------------------------------------------------
  # ● 【设置】定义 文字颜色标识符 → 文字颜色Color 的映射
  #  对于 \c[id] 转义符，其中的 id 可以是任意字符串，也可以是数字
  #  先判定在该 Hash 中是否存在对应，若没有，则会转化为数字并匹配窗口皮肤中的颜色索引
  #--------------------------------------------------------------------------
  TEXT_COLORS = {
    "pink" => Color.new(255, 187, 217),
  }
  #--------------------------------------------------------------------------
  # ● 【设置】定义\conv[string]转义符与替换后的字符串
  # （由于解析问题，字符串中请将 "\" 替换成 "\\"）
  # （在添加了预定转义符字符串于文本开头后，将对全部文本检查替换）
  # （如果目标转义符是用 <> 代替 []，如姓名框中的内容，则将 "\" 替换成 "\e"）
  #--------------------------------------------------------------------------
  CONVERT_ESCAPE = {
  # String => String,
    "系统" => "\\win[ali1dw1dh1o5do-5dx0dy0]\\pause[do2o5]\\temp",
    "底部" => "\\win[ali0dw1dh1o2do-2dx0dy-60]\\pause[do0o4]\\temp",
    "顶部" => "\\win[ali0dw1dh1o8do-8dx0dy60]\\pause[do0o4]\\temp",
  }
  #--------------------------------------------------------------------------
  # ● 【设置】定义在所有姓名框的名字字符串的最前面增加的转义字符串
  # （具体见draw_text_ex所支持的转义符）（\c[]转义符支持 TEXT_COLORS 扩展）
  # （由于解析问题，字符串中请将 "\" 替换成 "\e" ，并用 <> 代替 []）
  #--------------------------------------------------------------------------
  ESCAPE_STRING_NAME_PREFIX = "\ec<9>"
  #--------------------------------------------------------------------------
  # ● 【设置】定义 index → 窗口皮肤文件名 的映射
  # （其中 index 必须为整数）
  # （图片存储于 Graphics/System 目录下）
  #--------------------------------------------------------------------------
  INDEX_TO_WINDOWSKIN = {
    0 => "Window", # 默认所用皮肤名称
  }
  #--------------------------------------------------------------------------
  # ● 【设置】定义 index → 窗口背景图片名 的映射
  # （图片的左上角会与对话框的左上角对齐）
  # （其中 index 必须为整数）
  # （图片存储于 Graphics/System 目录下）
  #--------------------------------------------------------------------------
  INDEX_TO_WINDOW_BG = { # 对话框背景
    # 数字 => "背景图片名称"
  }
  INDEX_TO_NAME_BG = { # 姓名框背景
    # 数字 => " 背景图片名称"
  }
  #--------------------------------------------------------------------------
  # ● 【设置】定义 index → 打字音效 的映射
  # （音效存储于 Audio/SE 目录下）
  #--------------------------------------------------------------------------
  INDEX_TO_SE = {
  #index => SE文件名, 音量, 音调
    0 => ["", 80, 100], # 默认设置，不推荐修改
    1 => ["Cursor1", 40, 150],
  }
  #--------------------------------------------------------------------------
  # ● 【设置】定义 index → 指向性箭头文件名 的映射
  # （其中 index 为正整数；为 0 时代表不启用tag）
  # （图片存储于 Graphics/System 目录下）
  # 【Tag图片解析】任意大小，3帧×3帧规格
  #    7 8 9
  #    4 5 6  ← pop对话框的原点位置类型 与 对应所用的tag位图区域
  #    1 2 3
  # （比如 pop对话框的原点类型为 2 时，tag显示在对话框底部中央，图像使用2号区域）
  # 【注意】tag的存在不会使pop对话框产生额外偏移，请利用pop参数d/dx/dy自行移动
  #--------------------------------------------------------------------------
  INDEX_TO_WINDOWTAG = {
    1 => "Window_Tag", # 默认所用tag名称
  }
  #--------------------------------------------------------------------------
  # ● 【设置】定义 窗口皮肤index → Tag图片index 的映射
  #  当使用窗口皮肤时，将必定使用此处设置的Tag图片
  #--------------------------------------------------------------------------
  WINDOWSKIN_TO_WINDOWTAG = {
    -1 => 1,
  }
  #--------------------------------------------------------------------------
  # ● 【设置】定义 index → 等待按键帧动画参数组 的映射
  # （其中 index 必须为整数）
  # （图片存储于 Graphics/System 目录下）
  # 【注意】帧动画统一从左上开始计为0号位置，并按行优先从左往右遍历
  #--------------------------------------------------------------------------
  INDEX_TO_PAUSE = {
  #         文件名 范围（nil则为整张图） 一行中的帧数 一列中的帧数
  #index=>[String, Rect, Integer, Integer]
   -1 => ["", nil, 1, 1], # 不显示
    0 => ["Window", Rect.new(96,64,32,32), 2, 2], # 默认 使用皮肤窗口里的箭头
  }
  #--------------------------------------------------------------------------
  # ● 【设置】是否屏蔽默认的输入等待的箭头显示
  # （位于底部中央的4帧动画）
  #--------------------------------------------------------------------------
  NO_DEFAULT_PAUSE = true
  #--------------------------------------------------------------------------
  # ● 【设置】跳过对话判定成功？
  #  返回值等于 true 时，会进行跳过当前对话框的处理（中断绘制并强行关闭）
  # （请注意，该跳过会直接忽略掉还未被绘制的转义符，可能存在奇怪问题）
  #--------------------------------------------------------------------------
  def self.skip?
    false #Input.trigger?(:CTRL)
  end
  #--------------------------------------------------------------------------
  # ● 【设置】执行切换对话框的显隐？
  #  返回值等于 true 时，会切换对话框的显示/隐藏
  # （文字将执行其移入移出效果）
  #--------------------------------------------------------------------------
  def self.toggle_visible?
    false #Input.trigger?(:A)
  end
  #--------------------------------------------------------------------------
  # ● 【计算】获取缓动函数的返回值
  #  type 为该函数被调用的场景
  #  x 为缓动函数的 当前时间/总时间 的比值（0~1之间小数）
  #  若使用了【组件-缓动函数 by老鹰】，则可以调用其中的缓动函数
  #--------------------------------------------------------------------------
  def self.ease_value(type, x)
    if $imported["EAGLE-EasingFunction"]
      case type
      when :msg_xywh
        return EasingFuction.call("easeOutBack", x)
      when :face_xy
        return EasingFuction.call("easeOutElastic", x)
      when :chara_xy
        return EasingFuction.call("easeOutExpo", x)
      end
    end
    return 1 - 2**(-10 * x)
  end
end

#=============================================================================
# ○ 读取设置
#=============================================================================
module MESSAGE_EX
  #--------------------------------------------------------------------------
  # ● 获取指定转义符的基础设置
  #--------------------------------------------------------------------------
  def self.get_default_params(param_sym)
    MESSAGE_EX.const_get("#{param_sym.to_s.upcase}_PARAMS_INIT".to_sym) rescue {}
  end
  #--------------------------------------------------------------------------
  # ● 读取指定文字组
  #--------------------------------------------------------------------------
  def self.get_charas_array(sym, index, num)
    h = MESSAGE_EX.const_get("#{sym.to_s.upcase}_CHARAS".to_sym) rescue {}
    array = h[index]
    return [] if array.nil?
    return array if num == 0
    return array.sample(num)
  end
  #--------------------------------------------------------------------------
  # ● 获取\conv[string]的替换字符串
  #--------------------------------------------------------------------------
  def self.get_conv(s)
    CONVERT_ESCAPE[s] || ""
  end
  #--------------------------------------------------------------------------
  # ● 获取姓名框绘制内容的前缀
  #--------------------------------------------------------------------------
  def self.get_name_prefix
    ESCAPE_STRING_NAME_PREFIX
  end
  #--------------------------------------------------------------------------
  # ● 读取对应的 windowskin 位图
  #--------------------------------------------------------------------------
  def self.windowskin(index)
    begin
      return Cache.system(INDEX_TO_WINDOWSKIN[index])
    rescue
      return Cache.system(INDEX_TO_WINDOWSKIN[0])
    end
  end
  #--------------------------------------------------------------------------
  # ● 读取对应的 bg 位图
  #--------------------------------------------------------------------------
  def self.windowbg(index, w = nil, h = nil)
    Cache.system(INDEX_TO_WINDOW_BG[index]) rescue nil
  end
  def self.namebg(index, w = nil, h = nil)
    Cache.system(INDEX_TO_NAME_BG[index]) rescue nil
  end
  #--------------------------------------------------------------------------
  # ● 播放对应的SE
  #--------------------------------------------------------------------------
  def self.se(index)
    params = INDEX_TO_SE[index] || INDEX_TO_SE[0]
    return if params[0] == ""
    volume = params[1] || INDEX_TO_SE[0][1]
    pitch = params[2] || INDEX_TO_SE[0][2]
    Audio.se_play("Audio/SE/" + params[0], volume, pitch)
  end
  #--------------------------------------------------------------------------
  # ● 读取对应的 tag 位图
  #--------------------------------------------------------------------------
  def self.windowtag(index)
    begin
      return Cache.system(INDEX_TO_WINDOWTAG[index])
    rescue
      return Cache.empty_bitmap
    end
  end
  #--------------------------------------------------------------------------
  # ● 重设tag
  #  i => 具体在tag位图上的帧序号，九宫格顺序排列
  #  o => tag位图的显示原点，理论上为pop对话框的do
  #  _do => tag位图的显示位置原点，理论上为pop对话框的o
  #--------------------------------------------------------------------------
  def self.set_windowtag(window, sprite, i, o, _do)
    w = sprite.src_rect.width; h = sprite.src_rect.height # 单个tag的宽度和高度
    sprite.src_rect.x = w * (2 - (9 - i) % 3)
    sprite.src_rect.y = h * ((9 - i) / 3)
    self.reset_xy_dorigin(sprite, window, _do)
    self.reset_xy_origin(sprite, o)
  end
  #--------------------------------------------------------------------------
  # ● 读取 pause 按键等待精灵的信息组
  #--------------------------------------------------------------------------
  def self.pause_params(index)
    INDEX_TO_PAUSE[index] || INDEX_TO_PAUSE[0]
  end
  #--------------------------------------------------------------------------
  # ● 读取绘制图片时的图片名称
  #--------------------------------------------------------------------------
  def self.get_pic_file(filename)
    filename
  end
#==============================================================================
# ○ 共享方法
#==============================================================================
  #--------------------------------------------------------------------------
  # ● 获取指定对象的信息文本
  #--------------------------------------------------------------------------
  def self.get_data_info(type, id)
    case type
    when 's'; obj = $data_skills[id]
    when 'i'; obj = $data_items[id]
    when 'w'; obj = $data_weapons[id]
    when 'a'; obj = $data_armors[id]
    end
    return "\ei[#{obj.icon_index}]#{obj.name}" if obj
    return ""
  end
  #--------------------------------------------------------------------------
  # ● 解析字符串参数
  #--------------------------------------------------------------------------
  def self.parse_param(param_hash, param_text, default_type = "default")
    param_text = param_text.downcase rescue ""
    # 只有首位是省略名字的参数设置
    t = param_text.slice!(/^\-?\d+/)
    param_hash[default_type.to_sym] = t.to_i if t && t != ""
    while(param_text != "")
      t = param_text.slice!(/^[a-z]+/)
      if param_text[0] == "$"
        param_text[0] = ''
        next param_hash[t.to_sym] = nil
      end
      param_hash[t.to_sym] = (param_text.slice!(/^\-?\d+/)).to_i
    end
  end
  #--------------------------------------------------------------------------
  # ● 获取文本颜色
  #--------------------------------------------------------------------------
  def self.text_color(n, windowskin = Cache.system("Window"))
    return TEXT_COLORS[n] if TEXT_COLORS[n]
    n_ = n.to_i
    windowskin.get_pixel(64 + (n_ % 8) * 8, 96 + (n_ / 8) * 8)
  end
  #--------------------------------------------------------------------------
  # ● 将指定值变更为布尔量
  #--------------------------------------------------------------------------
  def self.check_bool(v)
    return true if v == true
    return false if v.nil? || v == false || v == 0
    return true
  end
  #--------------------------------------------------------------------------
  # ● 应用font参数到font对象上
  #--------------------------------------------------------------------------
  def self.apply_font_params(font, params)
    font.size = params[:size]
    font.italic = MESSAGE_EX.check_bool(params[:i])
    font.bold = MESSAGE_EX.check_bool(params[:b])
    font.shadow = MESSAGE_EX.check_bool(params[:s])
    font.color.alpha = params[:ca]
    font.outline = MESSAGE_EX.check_bool(params[:o])
    font.out_color.set(params[:or],params[:og],params[:ob],params[:oa])
    params[:l] = MESSAGE_EX.check_bool(params[:l])
    params[:lc] ||= 0
    params[:lp] ||= 2
    params[:d] = MESSAGE_EX.check_bool(params[:d])
    params[:dc] ||= 0
    params[:u] = MESSAGE_EX.check_bool(params[:u])
    params[:uc] ||= 0
  end
  #--------------------------------------------------------------------------
  # ● 重置指定精灵的显示原点
  #--------------------------------------------------------------------------
  def self.reset_sprite_oxy(obj, o)
    case o # 固定不动点的位置类型 以九宫格小键盘察看
    when 1
      obj.ox = 0
      obj.oy = obj.height
    when 2
      obj.ox = obj.width / 2
      obj.oy = obj.height
    when 3
      obj.ox = obj.width
      obj.oy = obj.height
    when 4
      obj.ox = 0
      obj.oy = obj.height / 2
    when 5
      obj.ox = obj.width / 2
      obj.oy = obj.height / 2
    when 6
      obj.ox = obj.width
      obj.oy = obj.height / 2
    when 7 # 【默认】显示原点为左上角
      obj.ox = 0
      obj.oy = 0
    when 8
      obj.ox = obj.width / 2
      obj.oy = 0
    when 9
      obj.ox = obj.width
      obj.oy = 0
    end
  end
  #--------------------------------------------------------------------------
  # ● 重置指定对象的显示原点位置
  #--------------------------------------------------------------------------
  def self.reset_xy_origin(obj, o)
    case o  # 固定不动点的位置类型 以九宫格小键盘察看
    when 1
      obj.y = obj.y - obj.height
    when 2
      obj.x = obj.x - obj.width / 2
      obj.y = obj.y - obj.height
    when 3
      obj.x = obj.x - obj.width
      obj.y = obj.y - obj.height
    when 4
      obj.y = obj.y - obj.height / 2
    when 5
      obj.x = obj.x - obj.width / 2
      obj.y = obj.y - obj.height / 2
    when 6
      obj.x = obj.x - obj.width
      obj.y = obj.y - obj.height / 2
    when 7; return # 【默认】显示原点为左上角
    when 8
      obj.x = obj.x - obj.width / 2
    when 9
      obj.x = obj.x - obj.width
    end
  end
  #--------------------------------------------------------------------------
  # ● 重置指定对象依据另一对象小键盘位置的新位置
  #--------------------------------------------------------------------------
  def self.reset_xy_dorigin(obj, obj2, o) # 左上角和左上角对齐
    if o < 0 # o小于0时，将obj2重置为全屏
      obj2 = Rect.new(0,0,Graphics.width,Graphics.height)
      o = o.abs
    end
    case o
    when 1,4,7; obj.x = obj2.x
    when 2,5,8; obj.x = obj2.x + obj2.width / 2
    when 3,6,9; obj.x = obj2.x + obj2.width
    end
    case o
    when 1,2,3; obj.y = obj2.y + obj2.height
    when 4,5,6; obj.y = obj2.y + obj2.height / 2
    when 7,8,9; obj.y = obj2.y
    end
  end
  #--------------------------------------------------------------------------
  # ● 基于指定位图，计算文本块所占宽高
  # （只进行 \\ 到 \e 的文本替换、忽略除\i以外的全部转义符、未考虑字号变化）
  #  k → 字符间距  ld → 行间距
  #--------------------------------------------------------------------------
  def self.calculate_text_wh(bitmap, text, k = 0, ld = 0)
    text_clone = text.dup; array_width = []; array_height = []
    # 转义符替换
    text_clone.gsub!(/\\/)      { "\e" }
    text_clone.gsub!(/\e\e/)    { "\\" }
    text_clone.gsub!(/\e[\.\|\^\!\$<>\{|\}]/i) { "" }
    text_clone.gsub!(/\e\w+\[(\d|\w)+\]/i) { "" } # 清除掉全部的\w[wd]格式转义符
    # 每一行计算宽度高度
    text_clone.each_line do |line|
      icon_count = 0; line.gsub!(/\ei\[\d+\]/i){ icon_count += 1; "" }
      r = bitmap.text_size(line)
      w = r.width + icon_count * 24 + (line.length - 1 + icon_count) * k
      array_width.push(w)
      h = icon_count > 0 ? [r.height, 24].max : r.height
      array_height.push(h)
    end
    return [array_width.max, array_height.inject{|sum, v| sum = sum + v + ld}]
  end
end # end of MESSAGE_EX

#==============================================================================
# ○ 定义能够响应的文字特效
#==============================================================================
module MESSAGE_EX::CHARA_EFFECTS
  #--------------------------------------------------------------------------
  # ● 移入移出特效预定
  #--------------------------------------------------------------------------
  def eagle_chara_effect_cin(param = '')
  end
  def eagle_chara_effect_cout(param = '')
  end
  #--------------------------------------------------------------------------
  # ● 正弦扭曲特效预定
  #--------------------------------------------------------------------------
  def eagle_chara_effect_csin(param = '')
  end
  #--------------------------------------------------------------------------
  # ● 波浪特效预定
  #--------------------------------------------------------------------------
  def eagle_chara_effect_cwave(param = '')
  end
  #--------------------------------------------------------------------------
  # ● 摇摆特效预定
  #--------------------------------------------------------------------------
  def eagle_chara_effect_cswing(param = '')
  end
  #--------------------------------------------------------------------------
  # ● 缩放特效预定
  #--------------------------------------------------------------------------
  def eagle_chara_effect_czoom(param = '')
  end
  #--------------------------------------------------------------------------
  # ● 抖动特效预定
  #--------------------------------------------------------------------------
  def eagle_chara_effect_cshake(param = '')
  end
  #--------------------------------------------------------------------------
  # ● 闪烁特效预定
  #--------------------------------------------------------------------------
  def eagle_chara_effect_cflash(param = '')
  end
  #--------------------------------------------------------------------------
  # ● 镜像特效预定
  #--------------------------------------------------------------------------
  def eagle_chara_effect_cmirror(param = '')
  end
  #--------------------------------------------------------------------------
  # ● 消散
  #--------------------------------------------------------------------------
  if defined?(Unravel_Bitmap)
  def eagle_chara_effect_uout(param = '')
  end
  def eagle_chara_effect_cu(param = '')
  end
  end
  #--------------------------------------------------------------------------
  # ● 文字切换特效预定
  #--------------------------------------------------------------------------
  def eagle_chara_effect_ctog(param = '')
  end
  #--------------------------------------------------------------------------
  # ● 文字渐变特效预定
  #--------------------------------------------------------------------------
  def eagle_chara_effect_cgrad(param = '')
  end
  #--------------------------------------------------------------------------
  # ● 文字叠加绘制预定
  #--------------------------------------------------------------------------
  def eagle_chara_effect_cmc(param = '')
  end
end

#=============================================================================
# ○ Game_Message
#=============================================================================
class Game_Message
  attr_reader   :params_need_apply # 存储需要被预定应用的符号（调用对应处理方法）
  attr_accessor :escape_strings # 存储预定要添加的字符串
  attr_accessor :chara_params # 存储文字特效预设 code_symbol => param_string
  attr_accessor :font_params, :win_params, :pop_params
  attr_accessor :face_params, :name_params, :pause_params, :ex_params
  attr_accessor :event_id, :child_window_w_des, :child_window_h_des
  attr_accessor :open_type, :close_type, :auto_wrap, :para, :no_input_pause
  attr_accessor :eagle_text # 存储实际绘制的文本（去除了预处理的转义符）
  attr_accessor :eagle_message # 兼容模式
  #--------------------------------------------------------------------------
  # ● 初始化对象
  #--------------------------------------------------------------------------
  alias eagle_message_ex_init initialize
  def initialize
    eagle_message_ex_init
    @temp_game_messages = {} # sym => game_message
    set_default_params
  end
  #--------------------------------------------------------------------------
  # ● 获取全部可保存params的符号的数组
  #--------------------------------------------------------------------------
  def eagle_params
    [:chara, :font, :win, :pop, :face, :name, :pause, :ex]
  end
  #--------------------------------------------------------------------------
  # ● 获取params的初始值
  #--------------------------------------------------------------------------
  def set_default_params
    eagle_params.each do |sym|
      self.send("#{sym}_params=".to_sym, MESSAGE_EX.get_default_params(sym).dup)
    end
    @params_need_apply = eagle_params.dup # 添加修改预定，用于应用初始值
    @escape_strings = [] # 存储等待执行的转义符字符串
  end
  #--------------------------------------------------------------------------
  # ● 检查params是否都存在（读档后调用，确保新增变量写入旧存档中）
  #--------------------------------------------------------------------------
  def check_params
    eagle_params.each do |sym|
      params = self.send("#{sym}_params".to_sym)
      def_params = MESSAGE_EX.get_default_params(sym).dup
      if params == nil
        self.send("#{sym}_params=".to_sym, def_params)
        add_apply(sym)
      else
        params = def_params.merge(params)
        self.send("#{sym}_params=".to_sym, params)
      end
    end
  end
  #--------------------------------------------------------------------------
  # ● 清除（每次对话框开启时被调用）
  #--------------------------------------------------------------------------
  alias eagle_message_ex_clear clear
  def clear
    @open_type ||= :ease # 对话框的打开模式
    @close_type ||= :ease # 对话框的关闭模式
    @auto_wrap ||= true # 开启自动换行？
    @para ||= false # 并行显示选择框？
    @no_input_pause ||= false # 不进入按键等待（扩展用）
    eagle_message_ex_clear
    @eagle_text = ""
    @event_id = 0 # 存储当前执行的Game_Interpreter的事件ID
    @child_window_w_des = 0 # 因子窗口嵌入而额外增加的宽高
    @child_window_h_des = 0
  end
  #--------------------------------------------------------------------------
  # ● 判定是否需要进入等待按键状态
  #--------------------------------------------------------------------------
  def input_pause?
    return false if @no_input_pause
    !(choice? || num_input? || item_choice?)
  end
  #--------------------------------------------------------------------------
  # ● 使用pop类型？
  #--------------------------------------------------------------------------
  def pop?
    @pop_params[:type] != nil
  end
  def pop_tag?
    @pop_params[:tag] > 0
  end
  #--------------------------------------------------------------------------
  # ● 使用脸图？
  #--------------------------------------------------------------------------
  def face?
    @face_params[:name] != ""
  end
  #--------------------------------------------------------------------------
  # ● 使用姓名框？
  #--------------------------------------------------------------------------
  def name?
    @name_params[:name] != ""
  end
  #--------------------------------------------------------------------------
  # ● 添加修改预定
  #--------------------------------------------------------------------------
  def add_apply(param_sym)
    return if @params_need_apply.include?(param_sym)
    @params_need_apply.push(param_sym)
  end
  #--------------------------------------------------------------------------
  # ● 清空预定修改
  #--------------------------------------------------------------------------
  def clear_applys
    @params_need_apply.clear
  end
  #--------------------------------------------------------------------------
  # ● 重置指定参数
  #--------------------------------------------------------------------------
  def reset_params(param_sym, code_string = nil)
    return eagle_params.each{|sym| reset_params(sym)} if param_sym.nil?
    return reset_params_c(code_string) if param_sym == :chara
    return reset_params_ex(code_string) if param_sym == :ex
    default_params = MESSAGE_EX.get_default_params(param_sym)
    if code_string.nil? # 直接清除全部参数
      new_params = default_params.dup
    else
      new_params = method( param_sym.to_s + "_params" ).call.dup # 获取旧的hash
      code_string.split("|").each { |c|
        new_params[c.to_sym] = default_params[c.to_sym]
      }
    end
    self.send((param_sym.to_s+"_params=").to_sym, new_params)
    add_apply(param_sym) # 添加修改预定，用于应用结果
  end
  #--------------------------------------------------------------------------
  # ● 重置指定文字特效
  #--------------------------------------------------------------------------
  def reset_params_c(code_string = nil)
    default_params = MESSAGE_EX.get_default_params(:chara)
    return @chara_params = default_params if code_string.nil?
    code_string.split("|").each { |c|
      if default_params[c.to_sym]
        @chara_params[c.to_sym] = default_params[c.to_sym]
      else
        @chara_params.delete(c.to_sym)
      end
    }
  end
  #--------------------------------------------------------------------------
  # ● 重置扩展转义符
  #--------------------------------------------------------------------------
  def reset_params_ex(code_string = nil)
    default_params = MESSAGE_EX.get_default_params(:ex)
    return @ex_params = default_params if code_string.nil?
    code_string.split("|").each { |c|
      if default_params[c.to_sym]
        @ex_params[c.to_sym] = default_params[c.to_sym]
      else
        @ex_params.delete(c.to_sym)
      end
    }
  end
  #--------------------------------------------------------------------------
  # ● 保存当前状态
  #--------------------------------------------------------------------------
  def save_params(sym = :default)
    @temp_game_messages[sym] = clone
  end
  #--------------------------------------------------------------------------
  # ● 读取保存状态
  #--------------------------------------------------------------------------
  def load_params(param_sym, sym = :default)
    return false if @temp_game_messages[sym].nil?
    return eagle_params.each{|psym| load_params(psym, sym)} if param_sym.nil?
    m = param_sym.to_s + "_params"
    self.send( (m+"=").to_sym, @temp_game_messages[sym].send(m.to_sym).clone )
    add_apply(param_sym) # 添加修改预定
    return true
  end
  #--------------------------------------------------------------------------
  # ● 参数拷贝
  #--------------------------------------------------------------------------
  def clone
    t = Game_Message.new
    t.visible = true
    eagle_params.each do |sym|
      m = "#{sym}_params"
      t.send("#{m}=".to_sym, method(m.to_sym).call.clone)
    end
    clone_ex(t)
    t
  end
  #--------------------------------------------------------------------------
  # ● 参数拷贝（方便扩展）
  #--------------------------------------------------------------------------
  def clone_ex(t)
    t.open_type = @open_type
    t.close_type = @close_type
    t.auto_wrap = @auto_wrap
  end
  #--------------------------------------------------------------------------
  # ● 下一次对话时要解析的转义符
  # 【由于解析问题，字符串中请将 "\" 替换成 "\e" 】
  #--------------------------------------------------------------------------
  def add_escape(string)
    @escape_strings.push(string)
  end
end

#=============================================================================
# ○ DataManager
#=============================================================================
class << DataManager
  #--------------------------------------------------------------------------
  # ● 设置新游戏
  #--------------------------------------------------------------------------
  alias eagle_message_ex_setup_new_game setup_new_game
  def setup_new_game
    eagle_message_ex_setup_new_game
    $game_message.add_escape(MESSAGE_EX::ESCAPE_STRING_INIT)
  end
end
#=============================================================================
# ○ Game_System
#=============================================================================
class Game_System
  #--------------------------------------------------------------------------
  # ● 读档后的处理
  #--------------------------------------------------------------------------
  alias eagle_message_ex_on_after_load on_after_load
  def on_after_load
    eagle_message_ex_on_after_load
    $game_message.check_params # 确保新增AddOn时，参数hash存在
  end
end
#=============================================================================
# ○ Game_Interpreter
#=============================================================================
class Game_Interpreter
  #--------------------------------------------------------------------------
  # ● 显示文字
  #--------------------------------------------------------------------------
  alias eagle_message_ex_command_101 command_101
  def command_101
    $game_message.event_id = @event_id
    eagle_message_ex_command_101
  end
end

#=============================================================================
# ○ Window_EagleMessage
#=============================================================================
class Window_EagleMessage < Window_Base
  include MESSAGE_EX::CHARA_EFFECTS
  attr_reader :eagle_charas_w, :eagle_charas_h, :eagle_chara_viewport
  #--------------------------------------------------------------------------
  # ● 获取主参数
  #--------------------------------------------------------------------------
  def game_message
    $game_message
  end
  #--------------------------------------------------------------------------
  # ● 重置指定对象的显示原点位置
  #--------------------------------------------------------------------------
  def eagle_reset_xy_origin(obj, o)
    MESSAGE_EX.reset_xy_origin(obj, o)
  end
  #--------------------------------------------------------------------------
  # ● 重置指定对象依据另一对象小键盘位置的新位置
  #--------------------------------------------------------------------------
  def eagle_reset_xy_dorigin(obj, obj2, o)
    MESSAGE_EX.reset_xy_dorigin(obj, obj2, o)
  end
  #--------------------------------------------------------------------------
  # ● 解析字符串参数
  #--------------------------------------------------------------------------
  def parse_param(param_hash, param_text, default_type = "default")
    MESSAGE_EX.parse_param(param_hash, param_text, default_type)
  end
  #--------------------------------------------------------------------------
  # ● 获取文字颜色
  #     n : 文字颜色编号（0..31）
  #--------------------------------------------------------------------------
  def text_color(n)
    MESSAGE_EX.text_color(n, self.windowskin)
  end

  #--------------------------------------------------------------------------
  # ● 初始化对象
  #--------------------------------------------------------------------------
  def initialize
    super(0, 0, window_width, window_height)
    create_all_windows
    eagle_message_init_assets
    eagle_message_init_params
    eagle_message_reset
    self.openness = 0
  end
  #--------------------------------------------------------------------------
  # ● 生成所有子窗口
  #--------------------------------------------------------------------------
  def create_all_windows
    @gold_window = Window_EagleMsgGold.new(self)
    @choice_window = Window_ChoiceList.new(self)
    @number_window = Window_NumberInput.new(self)
    @item_window = Window_KeyItem.new(self)
  end
  #--------------------------------------------------------------------------
  # ● 初始化组件
  # （在进行 clone 时，需要将该方法中的组件传递给拷贝窗口）
  #--------------------------------------------------------------------------
  def eagle_message_init_assets
    @back_sprite = Sprite.new # 显示背景图片的精灵
    @eagle_chara_viewport = Viewport.new # 文字精灵的显示区域
    @eagle_chara_sprites = [] # 存储全部的文字精灵
    @eagle_sprite_pop_tag = Sprite.new # 初始化pop状态下的tag精灵
    @eagle_sprite_face = nil # 初始化脸图精灵
    @eagle_window_name = Window_EagleMsgName.new(self) # 初始化姓名框窗口
    @eagle_sprite_pause = Sprite_EaglePauseTag.new(self) # 初始化等待按键的精灵
  end
  #--------------------------------------------------------------------------
  # ● 初始化参数（只会在 initialize 时执行一次）
  # （推荐将一些不需要传递给拷贝窗口的数据置于此处）
  #--------------------------------------------------------------------------
  def eagle_message_init_params
    self.back_opacity = 255     # 背景不透明度
    @fiber = nil                # 纤程
    @background = 0             # 背景类型
    @position = 2               # 显示位置
    @in_map = SceneManager.scene_is?(Scene_Map) # 地图场景中？
    @in_battle = SceneManager.scene_is?(Scene_Battle) # 战斗场景中？
    self.arrows_visible = false # 内容位图未完全显示时出现的箭头
    @flag_draw = true # 当为 true 时，代表需要进行绘制
    @flag_open_close = false # 当正在进行打开/关闭时，置为 true
    @flag_input_pause = false # 当正在进行按键等待时，置为 true
    @flag_need_open = true # 当为 true 时，需要执行open_and_wait
    @flag_need_change_wh = false # 当为 true 时，需要动态变更大小
    @flag_need_close = false # 当为 true 时，当前对话框必定处理关闭
    @flag_temp_params = false # 当前对话框的转义符不会保存到game_message中？
    @flag_hold = false # 当为 true 时，当前对话框会被拷贝保留，并同步更新
    @flag_instant = false # 当为 true 时，当前对话框不再处理文字显示的等待
    @eagle_dup_windows ||= [] # 存储全部拷贝的窗口
    @eagle_evals = [] # 存储当前对话框的动态脚本 [eval_str, eval_str...]
    @eagle_chara_sets = {} # 存储文字的分组
    @eagle_current_set = nil # 指定当前的分组
    # 对话框动态移动偏移量（此处新增定义，防止子类覆盖 eagle_message_reset）
    @eagle_move_x = @eagle_move_y = 0
    # 存储对话框在上一帧的位置（此处新增定义，防止子类覆盖 eagle_message_reset）
    @eagle_last_x = @eagle_last_y = 0
  end
  #--------------------------------------------------------------------------
  # ● 拷贝自身
  #--------------------------------------------------------------------------
  def clone(window = Window_EagleMessage_Clone)
    t = window.new(game_message.clone)
    t.game_message.win_params[:z] = 0
    t.x = self.x; t.y = self.y; t.width = self.width; t.height = self.height
    t.z = self.z - 5
    t.windowskin = self.windowskin
    # 拷贝背景精灵
    t.back_bitmap = @back_bitmap
    t.back_sprite = @back_sprite
    @back_bitmap = nil
    # 拷贝视图
    t.eagle_chara_viewport = @eagle_chara_viewport
    # 拷贝文字组
    t.eagle_chara_sprites = @eagle_chara_sprites
    t.eagle_chara_sprites.each { |s| s.bind_window(t) }
    # 复制文本宽高
    t.eagle_set_chara_wh(@eagle_charas_w, @eagle_charas_h,
      @eagle_charas_w_final, @eagle_charas_h_final)
    # 拷贝pop对象
    t.eagle_pop_obj = @eagle_pop_obj
    # 拷贝pop的tag
    t.eagle_sprite_pop_tag = @eagle_sprite_pop_tag
    # 拷贝脸图
    if @eagle_sprite_face
      t.eagle_sprite_face = @eagle_sprite_face
      t.eagle_sprite_face.bind_window(t)
    end
    # 拷贝姓名框
    t.eagle_window_name = @eagle_window_name
    t.eagle_window_name.bind_window(t)
    # 拷贝pause精灵
    t.eagle_sprite_pause = @eagle_sprite_pause
    t.eagle_sprite_pause.bind_window(t)
    # 扩展
    t = clone_ex(t)
    # 集体更新z值
    t.eagle_reset_z
    # 自身初始化组件与重置
    eagle_message_init_assets
    eagle_message_reset
    eagle_recreate_back_bitmap
    t
  end
  #--------------------------------------------------------------------------
  # ● 拷贝自身（扩展用处理）
  #--------------------------------------------------------------------------
  def clone_ex(t)
    t
  end
  #--------------------------------------------------------------------------
  # ● 释放
  #--------------------------------------------------------------------------
  alias eagle_message_ex_dispose dispose
  def dispose
    dispose_all_windows
    dispose_back_bitmap
    @back_sprite.dispose
    @eagle_chara_sprites.each { |s| s.dispose }
    @eagle_window_name.dispose
    @eagle_sprite_face.dispose if @eagle_sprite_face
    @eagle_sprite_pop_tag.dispose
    @eagle_sprite_pause.dispose
    @eagle_dup_windows.each { |w| w.dispose if !w.disposed? }
    @eagle_chara_viewport.dispose
  end
  #--------------------------------------------------------------------------
  # ● 释放所有窗口
  #--------------------------------------------------------------------------
  def dispose_all_windows
    @gold_window.dispose
    @choice_window.dispose
    @number_window.dispose
    @item_window.dispose
  end
  #--------------------------------------------------------------------------
  # ● 释放背景位图
  #--------------------------------------------------------------------------
  def dispose_back_bitmap
    @back_bitmap.dispose if @back_bitmap
    @back_bitmap = nil
  end

  #--------------------------------------------------------------------------
  # ● 重置对话框
  #--------------------------------------------------------------------------
  def eagle_message_reset
    eagle_message_reset_continue
    # 移出全部组件
    eagle_move_out_assets
    # 重置存储的上一个对话框的位置
    @eagle_last_x = @eagle_last_y = 0
    # 重置对话框动态移动位置
    @eagle_move_x = @eagle_move_y = 0
    # 重置对话框宽高
    win_params[:des_w] = 0
    win_params[:des_h] = 0
    # 重置文字区域的宽度高度
    @eagle_charas_w = @eagle_charas_h = 0
    @eagle_charas_w_final = @eagle_charas_h_final = 0
    # 重置pop对象，防止报错
    @eagle_pop_obj = nil
    # 重置脸图宽度
    face_params[:width] = 0
    # 重置集体的z值
    eagle_reset_z
    # 清除显示标志
    clear_flags
  end
  #--------------------------------------------------------------------------
  # ● 重置对话框（对话框不关闭，并继续显示）
  #--------------------------------------------------------------------------
  def eagle_message_reset_continue
    # 复原参数
    eagle_process_temp
    # 重置文字分组
    @eagle_chara_sets.clear
    # 自身显示
    show if self.visible == false
    # 重置auto的设置帧数
    MESSAGE_EX.check_bool(win_params[:auto_r])
    win_params[:auto_t] = nil if win_params[:auto_r] # nil时为不自动继续
    # 重置下一个文字的绘制x（左对齐、不考虑换行）
    @eagle_next_chara_x = 0
    # 隐藏pop的tag
    @eagle_sprite_pop_tag.visible = false
    # 隐藏pause精灵
    @eagle_sprite_pause.visible = false
    # 重置pause精灵的文末位置
    @eagle_sprite_pause.bind_last_chara(nil)
    @eagle_sprite_pause_width_add = 0 # 因pause精灵而扩展的窗口宽度
    # 重置强制关闭flag
    @eagle_force_close = false
  end
  #--------------------------------------------------------------------------
  # ● 移出全部组件
  #--------------------------------------------------------------------------
  def eagle_move_out_assets
    # 隐藏pop的tag
    @eagle_sprite_pop_tag.visible = false
    # 隐藏pause精灵
    @eagle_sprite_pause.visible = false
    # 移出显示的脸图
    face_params[:name] = ""
    eagle_move_out_face
    # 关闭姓名框（因为对话框关闭后，姓名框不再更新，调小openness确保先关闭）
    @eagle_window_name.close
    @eagle_window_name.openness -= 15
  end
  #--------------------------------------------------------------------------
  # ● 更新全部组件的不透明度
  #--------------------------------------------------------------------------
  def update_assets_opacity(opa)
    @eagle_chara_sprites.each { |c| c.opacity = opa }
    if game_message.pop? && game_message.pop_tag?
      @eagle_sprite_pop_tag.opacity = opa
    end
    @eagle_sprite_face.opa = opa if @eagle_sprite_face
    if game_message.name?
      @eagle_window_name.opacity = opa
      @eagle_window_name.contents_opacity = opa
      @eagle_window_name.update_back_sprite_opa(opa)
    end
    update_back_sprite_opa(opa)
  end
  #--------------------------------------------------------------------------
  # ● 重设z值
  #--------------------------------------------------------------------------
  def eagle_reset_z
    self.z = win_params[:z] if win_params[:z] > 0
    @back_sprite.z = self.z
    @eagle_chara_viewport.z = self.z + 1
    @eagle_sprite_pop_tag.z = self.z + 1
    @eagle_window_name.z = self.z + 2
    @eagle_sprite_pause.z = self.z + 2
  end
  #--------------------------------------------------------------------------
  # ● 显示窗口
  #--------------------------------------------------------------------------
  def show
    self.visible = true
    @back_sprite.visible = true if self.opacity == 0
    @eagle_chara_sprites.each { |s| s.move_in }
    if game_message.pop? && game_message.pop_tag?
      @eagle_sprite_pop_tag.visible = true
    end
    @eagle_sprite_face.visible = true if @eagle_sprite_face
    @eagle_window_name.show if game_message.name?
    @eagle_sprite_pause.visible = true if @flag_input_pause
    show_ex
    self
  end
  #--------------------------------------------------------------------------
  # ● 显示（扩展用）
  #--------------------------------------------------------------------------
  def show_ex
    @eagle_dup_windows.each { |w| w.show }
  end
  #--------------------------------------------------------------------------
  # ● 隐藏窗口
  #--------------------------------------------------------------------------
  def hide
    self.visible = false
    @back_sprite.visible = false
    @eagle_chara_sprites.each { |s| s.move_out_temp }
    @eagle_sprite_pop_tag.visible = false
    @eagle_sprite_face.visible = false if @eagle_sprite_face
    @eagle_window_name.hide
    @eagle_sprite_pause.visible = false
    hide_ex
    self
  end
  #--------------------------------------------------------------------------
  # ● 隐藏（扩展用）
  #--------------------------------------------------------------------------
  def hide_ex
    @eagle_dup_windows.each { |w| w.hide }
  end

  #--------------------------------------------------------------------------
  # ● 更新画面
  #--------------------------------------------------------------------------
  def update
    super
    eagle_update_before_fiber
    update_fiber
    eagle_update_after_fiber
  end
  #--------------------------------------------------------------------------
  # ● 更新fiber
  #--------------------------------------------------------------------------
  def update_fiber
    if @fiber
      @fiber.resume
    elsif game_message.busy? && !game_message.scroll_mode
      @fiber = Fiber.new { fiber_main }
      @fiber.resume
    else
      game_message.visible = false
    end
  end
  #--------------------------------------------------------------------------
  # ● 更新（在 @fiber 更新之前）
  #--------------------------------------------------------------------------
  def eagle_update_before_fiber
    update_all_windows
    update_back_sprite
    eagle_update_assets_after_open if self.openness > 0
  end
  #--------------------------------------------------------------------------
  # ● 更新所有窗口
  #--------------------------------------------------------------------------
  def update_all_windows
    @gold_window.update
    @choice_window.update
    @number_window.update
    @item_window.update
  end
  #--------------------------------------------------------------------------
  # ● 对话框打开后进行组件更新
  #--------------------------------------------------------------------------
  def eagle_update_assets_after_open
    eagle_pop_update if game_message.pop?
    @eagle_window_name.update
    @eagle_sprite_face.update if @eagle_sprite_face
    @eagle_sprite_pause.update if @eagle_sprite_pause.visible
    force_close if MESSAGE_EX.skip?
    (self.visible ? hide : show) if MESSAGE_EX.toggle_visible?
  end
  #--------------------------------------------------------------------------
  # ● 更新（在 @fiber 更新之后）
  #--------------------------------------------------------------------------
  def eagle_update_after_fiber
    @eagle_chara_sprites.each { |s| s.update }
    eagle_update_dup_windows
  end
  #--------------------------------------------------------------------------
  # ● 更新拷贝窗口
  #--------------------------------------------------------------------------
  def eagle_update_dup_windows
    if @eagle_dup_windows.size > 0
      @eagle_dup_windows.each { |w| w.update }
      if @eagle_dup_windows[-1].openness <= 0
        t = @eagle_dup_windows.pop
        t.dispose
      end
    end
  end

  #--------------------------------------------------------------------------
  # ● 打开直至完成（当有文字绘制完成时执行）
  #--------------------------------------------------------------------------
  def open_and_wait
    @flag_open_close = true
    @eagle_window_name.start if game_message.name?
    eagle_process_open_and_wait
    @flag_open_close = false
    @flag_need_open = false
  end
  #--------------------------------------------------------------------------
  # ● 处理打开方式（打开直至完成）
  #--------------------------------------------------------------------------
  def eagle_process_open_and_wait
    case game_message.open_type
    when :ease
      eagle_open_type_ease
    when :fade
      eagle_open_type_fade
    else # :default
      eagle_open_type_default
    end
  end
  #--------------------------------------------------------------------------
  # ● 打开-动态展开
  #--------------------------------------------------------------------------
  def eagle_open_type_ease
    @eagle_chara_sprites.each { |c| c.visible = false }
    eagle_set_wh({:w => 1, :h => 1, :ins => true, :open => true}) if self.openness == 0
    self.openness = 255
    eagle_set_wh({:open => true})
    @eagle_chara_sprites.each { |c| c.move_in; c.visible = true }
  end
  #--------------------------------------------------------------------------
  # ● 打开-淡入
  #--------------------------------------------------------------------------
  def eagle_open_type_fade
    eagle_set_wh({:ins => true, :open => true})
    update_back_sprite_zoom(nil, nil) # 将背景精灵的缩放重置为 1
    @eagle_chara_sprites.each { |c| c.move_in }
    self.openness = 255
    @eagle_window_name.openness = 255 if game_message.name?
    _opa = 0
    while ( _opa < 255 )
      _opa += 26
      self.opacity = _opa if @background == 0 && !@back_sprite.visible
      update_assets_opacity(_opa)
      Fiber.yield
    end
  end
  #--------------------------------------------------------------------------
  # ● 打开-默认openness
  #--------------------------------------------------------------------------
  def eagle_open_type_default
    eagle_set_wh({:ins => true, :open => true})
    update_back_sprite_zoom(nil, nil) # 将背景精灵的缩放重置为 1
    @eagle_chara_sprites.each { |c| c.visible = false }
    open
    until open?
      update_back_sprite_opa(self.openness)
      Fiber.yield
    end
    @eagle_chara_sprites.each { |c| c.move_in; c.visible = true }
  end
  #--------------------------------------------------------------------------
  # ● 关闭直至完成
  #--------------------------------------------------------------------------
  def close_and_wait
    @flag_open_close = true
    show if !self.visible
    eagle_message_sprites_move_out
    eagle_process_close_and_wait
    @flag_open_close = false
    @flag_need_open = true
  end
  #--------------------------------------------------------------------------
  # ● 处理关闭方式（关闭直至完成）
  #--------------------------------------------------------------------------
  def eagle_process_close_and_wait
    case game_message.close_type
    when :ease
      eagle_close_type_ease
    when :fade
      eagle_close_type_fade
    else # :default
      eagle_close_type_default
    end
  end
  #--------------------------------------------------------------------------
  # ● 关闭-动态缩小
  #--------------------------------------------------------------------------
  def eagle_close_type_ease
    eagle_move_out_assets
    eagle_set_wh({:w => 1, :h => 1}) if self.openness > 0
    self.openness = 0
    close
  end
  #--------------------------------------------------------------------------
  # ● 关闭-淡出
  #--------------------------------------------------------------------------
  def eagle_close_type_fade
    _opa = [self.opacity, @back_sprite.opacity].max
    while ( _opa > 0 )
      _opa -= 30
      self.opacity = _opa if @background == 0 && !@back_sprite.visible
      update_assets_opacity(_opa)
      Fiber.yield
    end
    self.openness = 0
    close
  end
  #--------------------------------------------------------------------------
  # ● 关闭-默认openness
  #--------------------------------------------------------------------------
  def eagle_close_type_default
    close
    until all_close?
      update_back_sprite_opa(self.openness)
      Fiber.yield
    end
  end
  #--------------------------------------------------------------------------
  # ● 关闭
  #--------------------------------------------------------------------------
  def close
    super
    eagle_message_reset
  end
  #--------------------------------------------------------------------------
  # ● 判定是否所有窗口已全部关闭
  #--------------------------------------------------------------------------
  def all_close?
    close? && @choice_window.close? &&
    @number_window.close? && @item_window.close?
  end
  #--------------------------------------------------------------------------
  # ● 移出全部文字精灵
  #--------------------------------------------------------------------------
  def eagle_message_sprites_move_out
    while(!@eagle_chara_sprites.empty?)
      c = eagle_take_out_a_chara
      ensure_character_visible(c)
      c.move_out # 已经交由文字池进行后续更新释放
      win_params[:cwo].times { Fiber.yield } unless @eagle_force_close
    end
    @eagle_chara_sets.clear
  end
  #--------------------------------------------------------------------------
  # ● 取出一个文字精灵
  #--------------------------------------------------------------------------
  def eagle_take_out_a_chara
    case win_params[:cor]
    when 0, false; return @eagle_chara_sprites.shift
    when 1, true; return @eagle_chara_sprites.pop
    when 2;
      i = rand(@eagle_chara_sprites.size)
      return @eagle_chara_sprites.delete_at(i)
    end
  end

  #--------------------------------------------------------------------------
  # ● 设置对话框大小位置，并等待更新结束
  #--------------------------------------------------------------------------
  def eagle_set_wh(_p = {})
    eagle_set_params_xywh(_p)
    eagle_apply_params_xywh(_p)
    wait_until_des_wh(_p)
    eagle_win_update
  end
  #--------------------------------------------------------------------------
  # ● 设置对话框xywh的参数Hash
  #--------------------------------------------------------------------------
  def eagle_set_params_xywh(_p = {})
    _p[:update] = [] # 将会进行更新的属性
    _p[:ins] ||= false  # 如果需要立刻更新完成，就置为 true
    _p[:open] ||= false # 如果目标是打开窗口，就置为 true
    _p[:t] ||= 20 # 更新所需时间（帧）

    _p[:x] ||= nil # 更新结束时的位置，如果为 nil，且对话框未关闭，就适配计算
    _p[:y] ||= nil
    _p[:w] ||= nil  # 更新结束时的宽度高度，如果为 nil，就自动适配计算
    _p[:h] ||= nil

    if _p[:open] # 如果为打开，则直接移动到目的地
      _p[:x] = nil
      _p[:y] = nil
    elsif self.openness == 255
      _p[:x_init] = @eagle_last_x
      _p[:y_init] = @eagle_last_y
      _p[:x] = self.x if _p[:x].nil?
      _p[:y] = self.y if _p[:y].nil?
    end
    if _p[:x]
      _p[:x_d] = _p[:x] - _p[:x_init]
      _p[:update].push(:x) if _p[:x_d] != 0
    end
    if _p[:y]
      _p[:y_d] = _p[:y] - _p[:y_init]
      _p[:update].push(:y) if _p[:y_d] != 0
    end

    _p[:w_init] = self.width
    if _p[:w].nil?
      _p[:w]  = eagle_window_width
      _p[:w] += eagle_window_width_add(_p[:w])
    end
    _p[:w_d] = _p[:w] - _p[:w_init]
    _p[:update].push(:w) if _p[:w_d] != 0

    _p[:h_init] = self.height
    if _p[:h].nil?
      _p[:h]  = eagle_window_height
      _p[:h] += eagle_window_height_add(_p[:h])
    end
    _p[:h_d] = _p[:h] - _p[:h_init]
    _p[:update].push(:h) if _p[:h_d] != 0

    _p[:ins] = true if @background == 2 # 透明背景时直接更新完成
  end
  #--------------------------------------------------------------------------
  # ● 应用对话框xywh的参数Hash的预修改
  #--------------------------------------------------------------------------
  def eagle_apply_params_xywh(_p = {})
    if _p[:x_d] # 如果设置了移动，则覆盖移动增量来进行对话框的移动
      @eagle_move_x = - _p[:x_d]
    end
    if _p[:y_d]
      @eagle_move_y = - _p[:y_d]
    end
    if _p[:ins] # 处理立即完成宽高的更新
      @eagle_move_x = 0
      @eagle_move_y = 0
      self.width = _p[:w]
      self.height = _p[:h]
      _p[:update].clear
    end
    if _p[:open] || @flag_need_change_wh
      # 如果为打开，则记录下最终宽高，且生成新的背景位图
      win_params[:des_w] = _p[:w]
      win_params[:des_h] = _p[:h]
      eagle_recreate_back_bitmap(_p[:w], _p[:h])
    end
  end
  #--------------------------------------------------------------------------
  # ● 更新对话框宽高直至完成
  #--------------------------------------------------------------------------
  def wait_until_des_wh(_p = {})
    return if _p[:update].empty?
    max_w = [_p[:w], _p[:w_init]].max
    max_h = [_p[:h], _p[:h_init]].max
    _i = 0; _t = _p[:t]
    while(true)
      break if self.openness == 0
      break if _i > _t
      per = _i * 1.0 / _t
      per = (_i == _t ? 1 : MESSAGE_EX.ease_value(:msg_xywh, per))
      _p[:update].each do |sym|
        case sym
        when :x
          _x = _p[:x_init] + _p[:x_d] * per
          @eagle_move_x = _x - _p[:x]
        when :y
          _y = _p[:y_init] + _p[:y_d] * per
          @eagle_move_y = _y - _p[:y]
        when :w
          self.width = _p[:w_init] + _p[:w_d] * per
        when :h
          self.height = _p[:h_init] + _p[:h_d] * per
        end
      end
      eagle_win_update
      update_back_sprite_zoom(max_w, max_h)
      Fiber.yield
      _i += 1
    end
  end
  #--------------------------------------------------------------------------
  # ● 获取窗口的初始宽度高度
  #--------------------------------------------------------------------------
  def window_width
    Graphics.width
  end
  def window_height
    fitting_height(4)
  end
  #--------------------------------------------------------------------------
  # ● 获取窗口的实际宽度高度
  #--------------------------------------------------------------------------
  def eagle_window_width
    if game_message.pop? && pop_params[:w] > 0
      return pop_params[:w] + standard_padding * 2
    end
    if win_params[:w] > 0
      return win_params[:w] + standard_padding * 2
    end
    w = nil
    w = @eagle_charas_w       if eagle_dynamic_w?
    w = @eagle_charas_w_final if eagle_dyn_fit_w?
    if w
      w = win_params[:wmin] if win_params[:wmin] > 0 && w < win_params[:wmin]
      w = win_params[:wmax] if win_params[:wmax] > 0 && w > win_params[:wmax]
      w += standard_padding * 2
      w += eagle_face_width
      return w
    end
    window_width
  end
  def eagle_window_height
    if game_message.pop? && pop_params[:h] > 0
      return eagle_check_param_h(pop_params[:h]) + standard_padding * 2
    end
    if win_params[:h] > 0
      return eagle_check_param_h(win_params[:h]) + standard_padding * 2
    end
    h = nil
    h = @eagle_charas_h       if eagle_dynamic_h?
    h = @eagle_charas_h_final if eagle_dyn_fit_h?
    if h
      h = win_params[:hmin] if win_params[:hmin] > 0 && h < win_params[:hmin]
      h = win_params[:hmax] if win_params[:hmax] > 0 && h > win_params[:hmax]
      h += standard_padding * 2
      return h
    end
    window_height
  end
  #--------------------------------------------------------------------------
  # ● 检查内容高度参数
  #  如果h小于行高，则判定其为行数
  #--------------------------------------------------------------------------
  def eagle_check_param_h(h)
    h = line_height * h + win_params[:ld] * (h - 1) if h < line_height
    return h
  end
  #--------------------------------------------------------------------------
  # ● 直接指定宽度高度？
  #--------------------------------------------------------------------------
  def eagle_fix_w?
    return pop_params[:w] > 0 if game_message.pop?
    return win_params[:w] > 0
  end
  def eagle_fix_h?
    return pop_params[:h] > 0 if game_message.pop?
    return win_params[:h] > 0
  end
  #--------------------------------------------------------------------------
  # ● 动态调整宽度高度？
  #--------------------------------------------------------------------------
  def eagle_dynamic_w?
    game_message.pop? ? pop_params[:dw] : win_params[:dw]
  end
  def eagle_dynamic_h?
    game_message.pop? ? pop_params[:dh] : win_params[:dh]
  end
  #--------------------------------------------------------------------------
  # ● 预计算完整文字区域的宽度高度？
  #--------------------------------------------------------------------------
  def eagle_dyn_fit_w?
    game_message.pop? ? pop_params[:fw] : win_params[:fw]
  end
  def eagle_dyn_fit_h?
    game_message.pop? ? pop_params[:fh] : win_params[:fh]
  end
  #--------------------------------------------------------------------------
  # ● 可由子窗口增加对话框的宽度高度？
  #--------------------------------------------------------------------------
  def eagle_add_w_by_child_window?
    return false if eagle_fix_w?
    return true  if eagle_dynamic_w? || eagle_dyn_fit_w?
    return false
  end
  def eagle_add_h_by_child_window?
    return false if eagle_fix_h?
    return true  if eagle_dynamic_h? || eagle_dyn_fit_h?
    return false
  end
  #--------------------------------------------------------------------------
  # ● 额外增加的窗口宽度高度
  #--------------------------------------------------------------------------
  def eagle_window_width_add(cur_width)
    eagle_window_w_empty + game_message.child_window_w_des
  end
  def eagle_window_height_add(cur_height)
    eagle_window_h_empty + game_message.child_window_h_des
  end
  #--------------------------------------------------------------------------
  # ● 窗口内容中，无法被用于文本绘制的宽高
  #--------------------------------------------------------------------------
  def eagle_window_w_empty
    win_params[:cdx] + @eagle_sprite_pause_width_add + win_params[:cdw]
  end
  def eagle_window_h_empty
    win_params[:cdy]
  end

  #--------------------------------------------------------------------------
  # ● 更新win参数组（初始化/一页绘制完成时调用）
  #--------------------------------------------------------------------------
  def eagle_win_update
    @eagle_last_x = self.x
    @eagle_last_y = self.y
    return eagle_pop_update if game_message.pop? && @eagle_pop_obj
    eagle_change_windowskin
    self.x = win_params[:x] || 0
    self.y = win_params[:y] || default_init_y
    eagle_reset_xy_dorigin(self, nil, win_params[:do]) if win_params[:do] < 0
    eagle_reset_xy_origin(self, win_params[:o])
    self.x = self.x + win_params[:dx] + @eagle_move_x
    self.y = self.y + win_params[:dy] + @eagle_move_y
    eagle_fix_position if win_params[:fix]
    eagle_after_update_xy
  end
  #--------------------------------------------------------------------------
  # ● 获取对话框的初始y位置
  #--------------------------------------------------------------------------
  def default_init_y
    (@position * (Graphics.height - win_params[:des_h]) / 2)
  end
  #--------------------------------------------------------------------------
  # ● 修正位置（确保对话框完整显示）
  #--------------------------------------------------------------------------
  def eagle_fix_position
    self.x = [[self.x, 0].max, Graphics.width - self.width].min
    self.y = [[self.y, 0].max, Graphics.height - self.height].min
  end
  #--------------------------------------------------------------------------
  # ● 更新xy后的操作
  #--------------------------------------------------------------------------
  def eagle_after_update_xy
    eagle_set_charas_viewport
    eagle_name_update if game_message.name?
  end
  #--------------------------------------------------------------------------
  # ● 设置文字显示区域的矩形（屏幕坐标）
  #--------------------------------------------------------------------------
  def eagle_set_charas_viewport
    @eagle_chara_viewport.rect.set(eagle_charas_x0, eagle_charas_y0,
      eagle_charas_max_w + eagle_window_w_empty,
      eagle_charas_max_h + eagle_window_h_empty)
  end
  #--------------------------------------------------------------------------
  # ● 更新pop参数组
  #--------------------------------------------------------------------------
  def eagle_pop_update
    eagle_change_windowskin(pop_params[:skin])
    eagle_pop_init_xy
    o = pop_params[:o] # 设置对话框的显示原点
    o ||= 10 - pop_params[:do]
    eagle_reset_xy_origin(self, o) # 显示原点恰好相反
    # 将对话框移动到绑定对象的对应方向上，并加上偏移量
    case pop_params[:do]
    when 1,4,7; self.x -= (pop_params[:chara_w] / 2 + pop_params[:d])
    when 3,6,9; self.x += (pop_params[:chara_w] + pop_params[:d])
    end
    case pop_params[:do]
    when 1,2,3; self.y += (pop_params[:chara_h] / 2 + pop_params[:d])
    when 7,8,9; self.y -= (pop_params[:chara_h] + pop_params[:d])
    end
    # 坐标的运动偏移量
    self.x += @eagle_move_x
    self.y += @eagle_move_y
    # 更新pop的tag
    eagle_pop_tag_update
    # 坐标的补足偏移量
    self.x += pop_params[:dx]
    self.y += pop_params[:dy]
    if pop_params[:fix]
      eagle_fix_position
      eagle_pop_tag_fix_position
    end
    eagle_after_update_xy
  end
  #--------------------------------------------------------------------------
  # ● 更新pop的初始位置
  #--------------------------------------------------------------------------
  def eagle_pop_init_xy
    # 对话框左上角定位到绑定对象位图的对应o位置
    case pop_params[:type]
    when :map_chara
      # 如果对象使用的是行走图，则为Game_Chacter（行走图底部中心为显示原点）
      self.x = @eagle_pop_obj.screen_x
      self.y = @eagle_pop_obj.screen_y
    when :battle_sprite
      # 如果对象为战斗者精灵，则为Sprite_Battler（底部中心为显示原点）
      self.x = @eagle_pop_obj.x
      self.y = @eagle_pop_obj.y
    when :map_grid
      # 如果为地图格子，则格子中心为显示原点
      self.x = $game_map.adjust_x(@eagle_pop_obj[0]) * 32 + 16
      self.y = $game_map.adjust_y(@eagle_pop_obj[1]) * 32 + 16
    end
  end
  #--------------------------------------------------------------------------
  # ● 更新pop的tag
  #--------------------------------------------------------------------------
  def eagle_pop_tag_update
    return if !@eagle_sprite_pop_tag.visible
    i = 10 - pop_params[:do] # tag的显示帧恰好与pop对话框的do值相对
    # tag的显示原点，是pop对话框的do，即目标物体的九宫格位置
    o = pop_params[:do]
    #  但注意，需要调整到 2468 的位置
    o = 2 if o == 1 || o == 3
    o = 8 if o == 7 || o == 9
    _do = pop_params[:o] # 对话框的显示原点是tag的显示位置
    _do ||= 10 - pop_params[:do]
    MESSAGE_EX.set_windowtag(self, @eagle_sprite_pop_tag, i, o, _do)
    case i # 坐标距离事件格子中心的偏移量
    when 1,4,7; @eagle_sprite_pop_tag.x -= pop_params[:td]
    when 3,6,9; @eagle_sprite_pop_tag.x += pop_params[:td]
    end
    case i
    when 1,2,3; @eagle_sprite_pop_tag.y -= pop_params[:td]
    when 7,8,9; @eagle_sprite_pop_tag.y += pop_params[:td]
    end
  end
  #--------------------------------------------------------------------------
  # ● 修正pop的tag的位置
  #--------------------------------------------------------------------------
  def eagle_pop_tag_fix_position
    # 若tag因为对话框的fix position而位于对话框内，则隐藏
    s = @eagle_sprite_pop_tag
    return if !s.visible
    return if s.x + pop_params[:td] >= self.x + self.width
    return if s.x + s.width - pop_params[:td] <= self.x
    return if s.y + pop_params[:td] >= self.y + self.height
    return if s.y + s.height - pop_params[:td] <= self.y
    @eagle_sprite_pop_tag.visible = false
  end
  #--------------------------------------------------------------------------
  # ● 更新name参数组（随win/pop参数组更新）
  #--------------------------------------------------------------------------
  def eagle_name_update
    eagle_reset_xy_dorigin(@eagle_window_name, self, name_params[:do])
    eagle_reset_xy_origin(@eagle_window_name, name_params[:o])

    # 若姓名框遮挡了脸图，则移动到不遮挡的地方
    lx = self.x + eagle_face_left_width
    rx = self.x + self.width - eagle_face_right_width
    w = @eagle_window_name.width
    @eagle_window_name.x = lx if @eagle_window_name.x < lx
    @eagle_window_name.x = rx-w if @eagle_window_name.x+w > rx

    @eagle_window_name.x += name_params[:dx]
    @eagle_window_name.y += name_params[:dy]
    @eagle_window_name.update_with_msg
  end

  #--------------------------------------------------------------------------
  # ● 变更窗口皮肤
  #--------------------------------------------------------------------------
  def eagle_change_windowskin(index = nil)
    index = win_params[:skin] if index.nil?
    eagle_set_pop_tag_by_windowskin(index)
    return if @win_skin_draw == index
    @win_skin_draw = index
    self.windowskin = MESSAGE_EX.windowskin(index)
    change_color(text_color(font_params[:c]))
  end
  #--------------------------------------------------------------------------
  # ● 获取当前窗口皮肤的序号
  #--------------------------------------------------------------------------
  def get_cur_windowskin_index(index = nil)
    return index if index
    return pop_params[:skin] if game_message.pop? && !pop_params[:skin].nil?
    return win_params[:skin]
  end
  #--------------------------------------------------------------------------
  # ● 依据窗口皮肤设置tag序号
  #--------------------------------------------------------------------------
  def eagle_set_pop_tag_by_windowskin(index = nil)
    tag_id = MESSAGE_EX::WINDOWSKIN_TO_WINDOWTAG[index]
    return if tag_id.nil?
    eagle_reset_pop_tag_bitmap(tag_id)
  end

  #--------------------------------------------------------------------------
  # ● 重新生成背景位图
  #--------------------------------------------------------------------------
  def eagle_recreate_back_bitmap(w = self.width, h = self.height)
    case @background
    when 1 # 暗色背景
      if @back_bitmap && @back_bitmap.width == w && @back_bitmap.height == h
      else # 重绘
        @back_bitmap.dispose if @back_bitmap
        @back_bitmap = Bitmap.new(w, h)
        rect1 = Rect.new(0, 0, w, 12)
        rect2 = Rect.new(0, 12, w, h - 24)
        rect3 = Rect.new(0, h - 12, w, 12)
        @back_bitmap.gradient_fill_rect(rect1, back_color2, back_color1, true)
        @back_bitmap.fill_rect(rect2, back_color1)
        @back_bitmap.gradient_fill_rect(rect3, back_color1, back_color2, true)
      end
      @back_sprite.bitmap = @back_bitmap
      @back_sprite.visible = true
      self.opacity = 0
    when 2 # 透明背景
      @back_sprite.visible = false
      self.opacity = 0
    else # 普通
      return if win_params[:bg] && eagle_draw_bg_pic(w, h)
      @back_sprite.visible = false
      self.opacity = 255
    end
  end
  #--------------------------------------------------------------------------
  # ● 获取背景色 1
  #--------------------------------------------------------------------------
  def back_color1
    Color.new(0, 0, 0, 160)
  end
  #--------------------------------------------------------------------------
  # ● 获取背景色 2
  #--------------------------------------------------------------------------
  def back_color2
    Color.new(0, 0, 0, 0)
  end
  #--------------------------------------------------------------------------
  # ● 绘制背景图片
  #--------------------------------------------------------------------------
  def eagle_draw_bg_pic(w, h)
    @back_sprite.visible = true
    self.opacity = 0
    _bitmap = MESSAGE_EX.windowbg(win_params[:bg], w, h)
    if _bitmap != nil
      @back_sprite.bitmap = _bitmap
      return true
    end
    return false
  end
  #--------------------------------------------------------------------------
  # ● 更新背景精灵
  #--------------------------------------------------------------------------
  def update_back_sprite
    eagle_reset_xy_dorigin(@back_sprite, self, win_params[:bgo])
    MESSAGE_EX.reset_sprite_oxy(@back_sprite, win_params[:bgo])
    @back_sprite.update
  end
  #--------------------------------------------------------------------------
  # ● 更新背景精灵的缩放
  #--------------------------------------------------------------------------
  def update_back_sprite_zoom(max_w = nil, max_h = nil)
    if max_w == nil
      @back_sprite.zoom_x = 1
    else
      @back_sprite.zoom_x = self.width * 1.0 / max_w
    end
    if max_h == nil
      @back_sprite.zoom_y = 1
    else
      @back_sprite.zoom_y = self.height * 1.0 / max_h
    end
  end
  #--------------------------------------------------------------------------
  # ● 更新背景精灵的不透明度
  #--------------------------------------------------------------------------
  def update_back_sprite_opa(opa)
    @back_sprite.opacity = opa
  end

  #--------------------------------------------------------------------------
  # ● 处理纤程的主逻辑
  #--------------------------------------------------------------------------
  def fiber_main
    game_message.visible = true
    eagle_process_before_start
    loop do
      eagle_process_all_text
      process_input
      eagle_process_before_close
      Fiber.yield
      break unless text_continue?
      eagle_process_after_check_continue
    end
    close_and_wait
    game_message.visible = false
    @fiber = nil
  end
  #--------------------------------------------------------------------------
  # ● 首次开启对话框时的处理
  #--------------------------------------------------------------------------
  def eagle_process_before_start
    @background = game_message.background
    @position = game_message.position
  end
  #--------------------------------------------------------------------------
  # ● 处理全部文本（扩展）
  #--------------------------------------------------------------------------
  def eagle_process_all_text
    return if !game_message.has_text?
    if game_message.para && !game_message.input_pause?
      @fiber_para = Fiber.new { process_all_text; @fiber_para = nil }
      return
    end
    process_all_text
  end
  #--------------------------------------------------------------------------
  # ● 处理关闭前的操作
  #--------------------------------------------------------------------------
  def eagle_process_before_close
    game_message.clear
    @gold_window.close if @gold_window
  end
  #--------------------------------------------------------------------------
  # ● 判定文字是否继续显示（覆盖）
  #--------------------------------------------------------------------------
  def text_continue?
    return false if @flag_need_close
    game_message.has_text? && !settings_changed?
  end
  #--------------------------------------------------------------------------
  # ● 判定对话框设置是否被更改（覆盖）
  #  此时 $game_message 中存储了下一条指令的对话信息
  #  若返回 false，则会保留当前对话框不关闭，继续显示下一个指令的文本
  #--------------------------------------------------------------------------
  def settings_changed?
    @background != game_message.background ||
    @position != game_message.position
  end
  #--------------------------------------------------------------------------
  # ● 继续显示后的处理
  #--------------------------------------------------------------------------
  def eagle_process_after_check_continue
    eagle_message_reset_continue
    # 需要进行动态的变更大小
    @flag_need_change_wh = true
  end
  #--------------------------------------------------------------------------
  # ● 继续显示时的宽高处理（在第一个文字绘制后被调用）
  #--------------------------------------------------------------------------
  def eagle_change_wh_when_continue
    @eagle_chara_sprites.each { |c| c.visible = false }
    eagle_set_wh
    @eagle_chara_sprites.each { |c| c.move_in; c.visible = true }
    @flag_need_change_wh = false
  end

  #--------------------------------------------------------------------------
  # ● 获取即将绘制的所有文本内容
  #--------------------------------------------------------------------------
  def eagle_all_text
    text = game_message.all_text
    if !game_message.escape_strings.empty? # 如果存在待处理的转义符串，加到开头
      text = game_message.escape_strings.inject("") { |sum, s| sum = sum + s } + text
      game_message.escape_strings.clear
    end
    text = convert_escape_characters(text)
    text
  end
  #--------------------------------------------------------------------------
  # ● 进行控制符的事前变换
  #    在实际绘制前、将控制符替换为实际的内容。
  #    为了减少歧异，文字「\」会被首先替换为转义符（\e）。
  #--------------------------------------------------------------------------
  def convert_escape_characters(text)
    result = text.to_s.clone
    result = eagle_process_conv(result)
    result = eagle_process_rb(result)
    result = super(result) # 此处将 \\ 替换成了 \e
    result.gsub!(/\eINFO\[(\w)(\d+)\]/i) { MESSAGE_EX.get_data_info($1, $2.to_i) }
    result.gsub!(/\enl|\enew_line/i) { "\n" } # 替换换行转义符
    result
  end
  #--------------------------------------------------------------------------
  # ● 替换转义符（此时依旧是 \\ 开头的转义符）
  #--------------------------------------------------------------------------
  def eagle_process_conv(text)
    text.gsub!(/\\conv\[(.*?)\]/i) { MESSAGE_EX.get_conv($1) }
    text
  end
  #--------------------------------------------------------------------------
  # ● 处理脚本转义符（此时依旧是 \\ 开头的转义符）
  #--------------------------------------------------------------------------
  def eagle_process_rb(text)
    s = $game_switches; v = $game_variables
    text.gsub!(/\\RB\{(.*?)\}/i) { eval($1).to_s }
    text
  end

  #--------------------------------------------------------------------------
  # ● （覆盖）处理所有文本内容
  #--------------------------------------------------------------------------
  def process_all_text
    text = eagle_all_text; pos = {}
    new_page(text, pos)
    loop do
      break if text.empty?
      process_character(text.slice!(0, 1), text, pos)
      break @pause_skip = true if @eagle_force_close
    end
    eagle_process_draw_update if !@eagle_chara_sprites.empty?
  end
  #--------------------------------------------------------------------------
  # ● 强制中断绘制全部文本
  #--------------------------------------------------------------------------
  def force_close
    @eagle_force_close = true  # 若还在绘制，则直接结束绘制并跳过最后的等待按键
    @eagle_auto_continue_c = 0 # 若进入了按键等待，则将计数置0，并依靠auto跳过按键
  end
  #--------------------------------------------------------------------------
  # ● （覆盖）翻页处理
  #--------------------------------------------------------------------------
  def new_page(text, pos)
    eagle_message_sprites_move_out
    eagle_reset_charas_oxy
    pos[:x] = new_line_x
    pos[:y] = 0
    pos[:new_x] = new_line_x
    pos[:height] = line_height
    reset_font_settings
    clear_flags
    eagle_apply_params_changes
    eagle_check_pre_settings(text)
    eagle_draw_face(game_message.face_name, game_message.face_index)
    eagle_draw_name(text)

    # 存储实际绘制的内容，预先转义符已经处理并存储
    game_message.eagle_text = text.clone
    # 当预先转义符全部处理完成，进行一次预绘制
    pre_calc_charas_wh(text, pos)
  end
  #--------------------------------------------------------------------------
  # ● 清除标志（此处放置每次绘制前需要清空的数据）
  #--------------------------------------------------------------------------
  def clear_flags
    @show_fast = false          # 快进的标志
    @line_show_fast = false     # 行单位快进的标志
    @pause_skip = false         # “不等待输入”的标志
    pop_params[:type] = nil     # pop绑定对象的类型
  end
  #--------------------------------------------------------------------------
  # ● 应用预定的转义符修改
  #--------------------------------------------------------------------------
  def eagle_apply_params_changes
    game_message.params_need_apply.each do |sym|
      m_c = ("eagle_text_control_#{sym}").to_sym
      method(m_c).call("") if respond_to?(m_c)
    end
    game_message.clear_applys
  end
  #--------------------------------------------------------------------------
  # ● （覆盖）获取换行位置
  #--------------------------------------------------------------------------
  def new_line_x; 0; end
  #--------------------------------------------------------------------------
  # ● 计算文字区域最终绘制完成时的宽度高度
  #  本质上为预先全部绘制一次（但不真实绘制）
  #--------------------------------------------------------------------------
  def pre_calc_charas_wh(text, pos)
    text_ = text.clone; pos_ = pos.clone
    game_message.save_params
    @flag_draw = false
    # 初始化
    @eagle_charas_w = @eagle_charas_h = 0
    # 执行预绘制
    process_character(text_.slice!(0, 1), text_, pos_) until text_.empty?
    # 记录最终的文字区域宽度高度
    @eagle_charas_w_final = @eagle_charas_w
    @eagle_charas_h_final = @eagle_charas_h
    before_input_pause unless @pause_skip # 此处追加对pause精灵占用宽度的处理
    # 复原
    @eagle_charas_w = @eagle_charas_h = 0
    game_message.load_params(nil)
    game_message.clear_applys
    @flag_draw = true
  end

  #--------------------------------------------------------------------------
  # ● 文字显示区域的左上角位置（屏幕坐标系）
  #--------------------------------------------------------------------------
  def eagle_charas_x0
    self.x + standard_padding + eagle_face_left_width + win_params[:cdx]
  end
  def eagle_charas_y0
    self.y + standard_padding + win_params[:cdy]
  end
  #--------------------------------------------------------------------------
  # ● 计算文字显示区域的宽度和高度
  #--------------------------------------------------------------------------
  def eagle_charas_max_w
    self.width - standard_padding * 2 - eagle_face_width - eagle_window_w_empty
  end
  def eagle_charas_max_h
    self.height - standard_padding * 2 - eagle_window_h_empty
  end
  #--------------------------------------------------------------------------
  # ● 文字显示区域的显示原点
  #--------------------------------------------------------------------------
  def eagle_charas_ox; self.ox; end
  def eagle_charas_oy; self.oy; end
  #--------------------------------------------------------------------------
  # ● 重置文字显示区域
  #--------------------------------------------------------------------------
  def eagle_reset_charas_oxy
    self.ox = self.oy = 0
    @eagle_chara_viewport.rect.set(0,0,Graphics.width,Graphics.height)
  end
  #--------------------------------------------------------------------------
  # ● 重新生成适合全部文字的位图
  #--------------------------------------------------------------------------
  def recreate_contents_for_charas
    w = @eagle_charas_w + eagle_window_w_empty
    h = @eagle_charas_h + eagle_window_h_empty
    w = 1 if w == 0
    h = 1 if h == 0
    f = self.contents.font.dup
    self.contents.dispose if self.contents
    self.contents = Bitmap.new(w, h)
    self.contents.font = f
  end
  #--------------------------------------------------------------------------
  # ● （覆盖）普通文字的处理
  #--------------------------------------------------------------------------
  def process_normal_character(c, pos)
    c_rect = text_size(c); c_w = c_rect.width; c_h = c_rect.height
    eagle_auto_new_line(c_w, pos)
    if @flag_draw
      s = eagle_new_chara_sprite(pos[:x], pos[:y], c_w, c_h)
      s.eagle_font.draw(s.bitmap, 0, 0, c_w, c_h, c, 0)
    end
    eagle_process_draw_end(c_w, c_h, pos)
  end
  #--------------------------------------------------------------------------
  # ● （覆盖）处理控制符指定的图标绘制
  #--------------------------------------------------------------------------
  def process_draw_icon(icon_index, pos)
    eagle_auto_new_line(24, pos)
    if @flag_draw
      s = eagle_new_chara_sprite(pos[:x], pos[:y], 24, 24)
      s.eagle_font.draw_icon(s.bitmap, 0, 0, icon_index)
    end
    eagle_process_draw_end(24, 24, pos)
  end
  #--------------------------------------------------------------------------
  # ● 处理控制符指定的图片绘制
  #--------------------------------------------------------------------------
  def process_draw_pic(text, pos)
    param = text.slice!(/^\[.*?\]/)[1..-2]
    params = param.split('|') # [filename, param_str]
    _bitmap = Cache.picture(MESSAGE_EX.get_pic_file(params[0])) rescue return
    h = {}
    parse_param(h, params[1], :opa) if params[1]
    h[:w] ||= _bitmap.width
    h[:h] ||= _bitmap.height
    h[:opa] ||= 255

    eagle_auto_new_line(h[:w], pos)
    if @flag_draw
      s = eagle_new_chara_sprite(pos[:x], pos[:y], h[:w], h[:h])
      s.eagle_font.draw_pic(s.bitmap, _bitmap, h)
    end
    eagle_process_draw_end(h[:w], h[:h], pos)
  end
  #--------------------------------------------------------------------------
  # ● （封装）生成一个新的文字精灵
  #--------------------------------------------------------------------------
  def eagle_new_chara_sprite(c_x, c_y, c_w, c_h)
    f = Font_EagleCharacter.new(font_params)
    f.set_param(:skin, win_params[:skin])
    f.set_param(:ex_cg, ex_params[:cg])

    s = MESSAGE_EX.charapool_new(self, f, c_x, c_y, c_w, c_h, @eagle_chara_viewport)
    s.start_effects(game_message.chara_params)
    # 存入数组
    @eagle_chara_sprites.push(s) # 实时更新的数组
    @eagle_chara_sets[@eagle_current_set].push(s) if @eagle_current_set # 分组
    s
  end
  #--------------------------------------------------------------------------
  # ● 检查自动换行
  #--------------------------------------------------------------------------
  def eagle_auto_new_line(c_w, pos)
    return if game_message.auto_wrap == false
    return if @flag_draw == false
    return if !eagle_fix_w? && eagle_dynamic_w?
    max_w = eagle_charas_max_w
    return if max_w <= 0
    return if pos[:x] + c_w <= max_w # 若当前文字绘制完成后会超出边界，则换行
    process_new_line('', pos)
  end
  #--------------------------------------------------------------------------
  # ● 绘制完成时的处理
  #--------------------------------------------------------------------------
  def eagle_process_draw_end(c_w, c_h, pos)
    # 处理下一次绘制的参数
    pos[:x] += (c_w - game_message.win_params[:ck])
    pos[:height] = [pos[:height], c_h].max
    # 记录下一个文字绘制位置x
    @eagle_next_chara_x = pos[:x]
    # 处理文字区域大小更改
    @eagle_charas_w = pos[:x] if @eagle_charas_w < pos[:x]
    @eagle_charas_h = pos[:y] + pos[:height] if @eagle_charas_h < pos[:y] + pos[:height]
    return if !@flag_draw
    return if show_fast? # 如果是立即显示，则不更新
    eagle_process_draw_update
    wait_for_one_character
  end
  #--------------------------------------------------------------------------
  # ● 绘制完成时的更新
  #--------------------------------------------------------------------------
  def eagle_process_draw_update
    # 第一个文字绘制后打开窗口
    return open_and_wait if @flag_need_open
    # 如果是继续显示，需要动态更新大小
    return eagle_change_wh_when_continue if @flag_need_change_wh
    eagle_set_wh({:ins => true}) # 重设对话框宽高，并更新对话框位置
    # 对齐需要用到对话框的宽高，因此在更新后执行
    eagle_charas_reset_alignment(win_params[:ali])
    # 确保最后绘制的文字在视图区域内
    ensure_character_visible(@eagle_chara_sprites[-1])
  end
  #--------------------------------------------------------------------------
  # ● 重排列全部文字精灵
  #--------------------------------------------------------------------------
  def eagle_charas_reset_alignment(align)
    return if @eagle_chara_sprites.empty?
    charas = [] # 存储当前迭代行的全部文字精灵
    # 存储当前迭代行的y值（同y的为同一行）（未考虑列排文字）
    charas_y = @eagle_chara_sprites[0].origin_y  # 初始为第一行
    # 最大宽度 = [可供文字绘制区域的最大宽度, 文字占据宽度].max
    max_w = [eagle_charas_max_w, @eagle_charas_w].max
    @eagle_chara_sprites.each do |s|
      next charas.push(s) if s.origin_y == charas_y # 第一行的首字符会存入
      # 对同一行的字符重排
      eagle_charas_realign_line(charas, align, max_w)
      charas.clear
      # 将当前迭代的 下一行的首字符 存入
      charas.push(s)
      charas_y = s.origin_y
    end
    # 对最后一行进行重排列
    eagle_charas_realign_line(charas, align, max_w) if !charas.empty?
  end
  #--------------------------------------------------------------------------
  # ● 重排列同一行上的文字精灵
  #--------------------------------------------------------------------------
  def eagle_charas_realign_line(charas, align, max_w)
    w_line = charas[-1].origin_x - charas[0].origin_x + charas[-1].width
    h_line = charas.collect{ |c| c.height }.max
    charas.each do |c|
      case align
      when 0 # 左对齐（默认对齐方式）
        _x = c.origin_x
      when 1 # 居中排列
        _x = c.origin_x + (max_w - w_line) / 2
      when 2 # 右排列
        _x = c.origin_x + max_w - w_line
      end
      _y = c.origin_y + h_line - c.height # 底部对齐
      c.reset_xy(_x, _y)
    end
  end
  #--------------------------------------------------------------------------
  # ● 确保指定文字在视图内
  #--------------------------------------------------------------------------
  def ensure_character_visible(c)
    return if c.nil?
    self.ox = 0 if c._x < self.ox
    d = c._x + c.width - @eagle_chara_viewport.rect.width
    self.ox = d if d > 0
    self.oy = 0 if c._y < self.oy
    d = c._y + c.height - @eagle_chara_viewport.rect.height
    self.oy = d if d > 0
  end
  #--------------------------------------------------------------------------
  # ● 处于快进显示？
  #--------------------------------------------------------------------------
  def show_fast?
    @flag_instant || @show_fast || @line_show_fast
  end
  #--------------------------------------------------------------------------
  # ● 输出一个字符后的等待
  #--------------------------------------------------------------------------
  def wait_for_one_character
    MESSAGE_EX.se(game_message.win_params[:se])
    win_params[:cwi].times do
      return if show_fast?
      update_show_fast if win_params[:cfast]
      Fiber.yield
    end
  end
  #--------------------------------------------------------------------------
  # ● 监听“确定”键的按下，更新快进的标志
  #--------------------------------------------------------------------------
  def update_show_fast
    @show_fast = true if Input.trigger?(:C)
  end
  #--------------------------------------------------------------------------
  # ● 换行文字的处理（删去翻页）
  #  由于自动对齐的存在，无需预先计算当前行高，text参数无效
  #--------------------------------------------------------------------------
  def process_new_line(text, pos)
    pos[:height] += win_params[:ld] # 当前行增加一个行间距
    @line_show_fast = false
    pos[:x] = pos[:new_x]
    pos[:y] += pos[:height]
    pos[:height] = line_height
  end

  #--------------------------------------------------------------------------
  # ● 设置【预先】指令的参数
  #--------------------------------------------------------------------------
  def eagle_check_pre_settings(text)
    eagle_check_temp(text)
    eagle_check_hold(text)
    eagle_check_instant(text)
    eagle_check_close(text)
    eagle_check_eval(text)
    eagle_check_popt(text)
    eagle_check_facep(text)
  end
  #--------------------------------------------------------------------------
  # ● 设置/执行temp指令
  #--------------------------------------------------------------------------
  def eagle_check_temp(text)
    text.gsub!(/\e(temp)/i) { "" }
    if $1
      game_message.save_params(:temp)
      @flag_temp_params = true
    end
  end
  def eagle_process_temp
    return if @flag_temp_params == false
    @flag_temp_params = false
    game_message.load_params(nil, :temp) # 已经在预绘制时存储了参数
  end
  #--------------------------------------------------------------------------
  # ● 设置/执行hold指令
  #--------------------------------------------------------------------------
  def eagle_check_hold(text)
    text.gsub!(/\e(hold)/i) { "" }
    @flag_hold = $1 ? true : false
  end
  def eagle_process_hold
    if @flag_hold
      t = self.clone
      # 重置之前存储的窗口的z值（确保最近的显示在最上面）
      @eagle_dup_windows.each_with_index do |w, i|
        w.z = t.z - (i+1) * 5; w.eagle_reset_z
      end
      @eagle_dup_windows.unshift(t)
      self.openness = 0
      @flag_need_open = true
    else
      eagle_release_hold
    end
  end
  def eagle_release_hold # 所有暂存窗口关闭
    @eagle_dup_windows.each { |w| w.close_clone }
  end
  #--------------------------------------------------------------------------
  # ● 设置instant指令
  #--------------------------------------------------------------------------
  def eagle_check_instant(text)
    text.gsub!(/\e(ins|instant)/i) { "" }
    @flag_instant = $1 ? true : false
  end
  #--------------------------------------------------------------------------
  # ● 设置close指令
  #--------------------------------------------------------------------------
  def eagle_check_close(text)
    text.gsub!(/\e(close)/i) { "" }
    @flag_need_close = $1 ? true : false
  end
  #--------------------------------------------------------------------------
  # ● 设置eval指令
  #--------------------------------------------------------------------------
  def eagle_check_eval(text)
    @eagle_evals.clear # 清除旧的
    text.gsub!(/\eeval\{(.*?)\}/m) {
      @eagle_evals.push($1) # ID 从 1 开始，防止之后param传入nil出错
      "\eeval[#{@eagle_evals.size}]"
    }
  end
  #--------------------------------------------------------------------------
  # ● 分析【预先】转义符的全部参数（按出现顺序处理）
  #--------------------------------------------------------------------------
  def parse_pre_params(text, sym, hash, default_type = :default)
    params = []
    text.gsub!(/\e#{sym}\[(.*?)\]/i) { params.push($1); "" }
    params.push("") if params.empty?
    params.each { |param| parse_param(hash, param, default_type) }
  end
  #--------------------------------------------------------------------------
  # ● 设置popt指令的参数
  #--------------------------------------------------------------------------
  def eagle_check_popt(text)
    parse_pre_params(text, 'popt', pop_params, :tag)
    eagle_reset_pop_tag_bitmap(pop_params[:tag])
  end
  #--------------------------------------------------------------------------
  # ● 重置tag的位图
  #--------------------------------------------------------------------------
  def eagle_reset_pop_tag_bitmap(tag_id = pop_params[:tag])
    @eagle_sprite_pop_tag.bitmap = MESSAGE_EX.windowtag(tag_id)
    w = @eagle_sprite_pop_tag.bitmap.width
    h = @eagle_sprite_pop_tag.bitmap.height
    @eagle_sprite_pop_tag.src_rect.width = w / 3
    @eagle_sprite_pop_tag.src_rect.height = h / 3
  end
  #--------------------------------------------------------------------------
  # ● 设置facep指令的参数
  #--------------------------------------------------------------------------
  def eagle_check_facep(text)
    parse_pre_params(text, 'facep', face_params, :dir)
    face_params[:dir] = MESSAGE_EX.check_bool(face_params[:dir])
    face_params[:m] = MESSAGE_EX.check_bool(face_params[:m])
  end
  #--------------------------------------------------------------------------
  # ● 初始化姓名框
  #--------------------------------------------------------------------------
  def name_params; game_message.name_params; end
  def eagle_draw_name(text)
    # 用 | 分隔需要绘制的name字符串（其中转义符用<>代替[]）和参数组
    str_name = ""
    text.gsub!(/\ename\[(.*?)\]/i) {
      t = $1.dup
      if t.include?('|')
        str_name = t.slice!(/.*?\|/).chop
        "\ename[#{t}]"
      else
        str_name = t
        ""
      end
    }
    parse_pre_params(text, 'name', name_params, :o)
    name_params[:name] = str_name
    @eagle_window_name.reset
  end

  #--------------------------------------------------------------------------
  # ● 控制符的处理
  #     code : 控制符的实际形式（比如“\C[1]”是“C”）
  #     text : 绘制处理中的字符串缓存（字符串可能会被修改）
  #     pos  : 绘制位置 {:x, :y, :new_x, :height}
  #--------------------------------------------------------------------------
  def process_escape_character(code, text, pos)
    return if eagle_call_process_escape(code, text, pos)
    temp_code = code.downcase
    m_c = ("eagle_text_control_" + temp_code).to_sym
    m_e = ("eagle_chara_effect_" + temp_code).to_sym
    if respond_to?(m_c)
      param = obtain_escape_param_string(text)
      method(m_c).call(param)
    elsif respond_to?(m_e)
      param = obtain_escape_param_string(text)
      # 当只传入 0 时，代表关闭该特效
      return eagle_chara_effect_clear(temp_code.to_sym) if param == '0'
      game_message.chara_params[temp_code.to_sym] = param
      method(m_e).call(param)
    else
      super(code, text, pos)
    end
  end
  #--------------------------------------------------------------------------
  # ● 控制符的处理（方便扩展的编写方式）
  #     code : 控制符的实际形式（比如“\C[1]”是“C”）
  #     text : 绘制处理中的字符串缓存（字符串可能会被修改）
  #     pos  : 绘制位置 {:x, :y, :new_x, :height}
  #  返回 true 则代表转义符执行成功，否则继续匹配组件和默认转义符
  #--------------------------------------------------------------------------
  def eagle_call_process_escape(code, text, pos)
    c = code.upcase
    if c == '$' && @gold_window
      @gold_window.open? ? @gold_window.close : @gold_window.open
      return true
    end
    if c == '.'
      wait(15); return true
    end
    if c == '|'
      wait(60); return true
    end
    if c == '!'
      input_pause; return true
    end
    if c == '>'
      @line_show_fast = true; return true
    end
    if c == '<'
      @line_show_fast = false; return true
    end
    if c == '^'
      @pause_skip = true; return true
    end
    if c == 'C'
      font_params[:c] = obtain_escape_param_string(text)
      change_color(text_color(font_params[:c]))
      return true
    end
    if c == "PIC"
      process_draw_pic(text, pos)
      return true
    end
    return false
  end
  #--------------------------------------------------------------------------
  # ● （覆盖）获取控制符的实际形式（这个方法会破坏原始数据）
  #--------------------------------------------------------------------------
  def obtain_escape_code(text)
    text.slice!(/^[\$\.\|\^!><\{\}\\]|^[\d\w]+/i)
  end
  #--------------------------------------------------------------------------
  # ● 获取控制符的参数（变量参数字符串形式）（这个方法会破坏原始数据）
  #--------------------------------------------------------------------------
  def obtain_escape_param_string(text)
    text.slice!(/^\[[\|\$\-\d\w]+\]/)[1..-2] rescue ""
  end
  #--------------------------------------------------------------------------
  # ● 清除暂存的指定文字特效
  #--------------------------------------------------------------------------
  def eagle_chara_effect_clear(code_sym)
    game_message.chara_params.delete(code_sym)
  end

  #--------------------------------------------------------------------------
  # ● 设置font参数
  #--------------------------------------------------------------------------
  def font_params; game_message.font_params; end
  def eagle_text_control_font(param = "")
    parse_param(font_params, param, :size)
    change_color(text_color(font_params[:c]))
    MESSAGE_EX.apply_font_params(self.contents.font, font_params)
  end
  #--------------------------------------------------------------------------
  # ● （覆盖）重置字体设置
  #--------------------------------------------------------------------------
  def reset_font_settings
    change_color(normal_color)
    font_params[:c] = 0
    font_params[:ca] = 255
  end
  #--------------------------------------------------------------------------
  # ● （覆盖）放大字体尺寸
  #--------------------------------------------------------------------------
  def make_font_bigger
    self.contents.font.size += 4 if self.contents.font.size <= 64
    font_params[:size] = self.contents.font.size
  end
  #--------------------------------------------------------------------------
  # ● （覆盖）缩小字体尺寸
  #--------------------------------------------------------------------------
  def make_font_smaller
    self.contents.font.size -= 4 if self.contents.font.size >= 16
    font_params[:size] = self.contents.font.size
  end

  #--------------------------------------------------------------------------
  # ● 设置win参数
  #--------------------------------------------------------------------------
  def win_params; game_message.win_params; end
  def eagle_text_control_win(param = "")
    parse_param(win_params, param, :o)
    win_params[:hmin] = eagle_check_param_h(win_params[:hmin])
    win_params[:hmax] = eagle_check_param_h(win_params[:hmax])
    win_params[:dw] = MESSAGE_EX.check_bool(win_params[:dw])
    win_params[:fw] = MESSAGE_EX.check_bool(win_params[:fw])
    win_params[:dh] = MESSAGE_EX.check_bool(win_params[:dh])
    win_params[:fh] = MESSAGE_EX.check_bool(win_params[:fh])
    win_params[:cwi] = 0 if win_params[:cwi] < 0
    win_params[:cwo] = 0 if win_params[:cwo] < 0
    win_params[:cfast] = MESSAGE_EX.check_bool(win_params[:cfast])
    win_params[:fix] = MESSAGE_EX.check_bool(win_params[:fix])
    eagle_reset_z
  end
  #--------------------------------------------------------------------------
  # ● （覆盖）获取基础行高
  #--------------------------------------------------------------------------
  def line_height
    h = win_params[:lh]
    return h if h > 0
    return super
  end

  #--------------------------------------------------------------------------
  # ● 设置pop参数
  #--------------------------------------------------------------------------
  def pop_params; game_message.pop_params; end
  def eagle_text_control_pop(param = "")
    pop_params[:id] = nil # 重置绑定对象
    pop_params[:mx] = nil
    pop_params[:my] = nil
    parse_param(pop_params, param, :id)
    pop_params[:type] = nil # 清除可能的误设置
    @eagle_pop_obj = eagle_get_pop_obj # 获取所绑定的对象
    return pop_params[:type] = nil if @eagle_pop_obj.nil?
    s = eagle_get_pop_sprite # 获取所绑定对象的精灵
    eagle_set_pop_sprite_info(s)
    pop_params[:dw] = MESSAGE_EX.check_bool(pop_params[:dw])
    pop_params[:fw] = MESSAGE_EX.check_bool(pop_params[:fw])
    pop_params[:dh] = MESSAGE_EX.check_bool(pop_params[:dh])
    pop_params[:fh] = MESSAGE_EX.check_bool(pop_params[:fh])
    pop_params[:fix] = MESSAGE_EX.check_bool(pop_params[:fix])
    # 设置pop的tag
    @eagle_sprite_pop_tag.visible = show_pop_tag?
    eagle_pop_update
  end
  #--------------------------------------------------------------------------
  # ● 获取pop的弹出对象（需要有x、y、width、height方法）
  #--------------------------------------------------------------------------
  def eagle_get_pop_obj
    if pop_params[:id]
      return eagle_get_pop_obj_m if @in_map
      return eagle_get_pop_obj_b if @in_battle
    end
    return eagle_get_pop_obj_ex
  end
  #--------------------------------------------------------------------------
  # ● 获取pop的对象（地图场景中）（Game_Character的实例）
  #--------------------------------------------------------------------------
  def eagle_get_pop_obj_m
    pop_params[:type] = :map_chara
    id = pop_params[:id]
    if id == 0 # 当前事件
      return $game_map.events[game_message.event_id]
    elsif id > 0 # 第id号事件
      chara = $game_map.events[id]
      chara ||= $game_map.events[game_message.event_id]
      return chara
    elsif id < 0 # 队伍中数据库id号角色（不存在则取队长）
      id = id.abs
      $game_player.followers.each { |f|
        return f if f.actor && f.actor.actor.id == id
      }
      return $game_player
    end
  end
  #--------------------------------------------------------------------------
  # ● 获取pop的对象（战斗场景中）（Sprite_Battler的实例）
  #--------------------------------------------------------------------------
  def eagle_get_pop_obj_b
    pop_params[:type] = :battle_sprite
    id = pop_params[:id]
    return nil if id.nil?
    if id > 0 # 敌人index
      SceneManager.scene.spriteset.battler_sprites.each do |s|
        return s if s.battler && s.battler.enemy? && s.battler.index == id-1
      end
    elsif id < 0 # 我方数据库id
      id = id.abs
      SceneManager.scene.spriteset.battler_sprites.each do |s|
        return s if s.battler && s.battler.actor? && s.battler.id == id
      end
    end
    return nil
  end
  #--------------------------------------------------------------------------
  # ● 获取pop的对象（无 id 设置时）
  #--------------------------------------------------------------------------
  def eagle_get_pop_obj_ex
    if @in_map && pop_params[:mx] && pop_params[:my]
      pop_params[:type] = :map_grid
      return [pop_params[:mx], pop_params[:my]]
    end
    return nil
  end
  #--------------------------------------------------------------------------
  # ● 获取pop对象的精灵（用于计算偏移值）
  #--------------------------------------------------------------------------
  def eagle_get_pop_sprite
    # 地图场景中，所存储的并非精灵，需要再次检索
    if pop_params[:type] == :map_chara
      SceneManager.scene.spriteset.character_sprites.each do |s|
        return s if s.character == @eagle_pop_obj
      end
      return nil
    end
    return @eagle_pop_obj
  end
  #--------------------------------------------------------------------------
  # ● 存储用于pop更新的精灵对象的信息
  #--------------------------------------------------------------------------
  def eagle_set_pop_sprite_info(s)
    if s.is_a?(Sprite)
      pop_params[:chara_w] = s.width
      pop_params[:chara_h] = s.height
    end
    if pop_params[:type] == :map_grid
      pop_params[:chara_w] = 32
      pop_params[:chara_h] = 32
    end
  end
  #--------------------------------------------------------------------------
  # ● 可以显示pop的tag？
  #--------------------------------------------------------------------------
  def show_pop_tag?
    game_message.pop_tag? && @background == 0 &&
    pop_params[:do] > 0 && pop_params[:do] < 10
  end

  #--------------------------------------------------------------------------
  # ● 设置face参数
  #--------------------------------------------------------------------------
  def face_params; game_message.face_params; end
  def eagle_text_control_face(param = "")
    face_params[:ls] = -1 # 设置循环开始编号（+1直至le，再从ls循环）
    face_params[:le] = -1 # 设置循环结束编号
    parse_param(face_params, param, :i)
    @eagle_sprite_face.apply_face_params if @eagle_sprite_face
  end
  #--------------------------------------------------------------------------
  # ● 执行facem
  #--------------------------------------------------------------------------
  def eagle_text_control_facem(param = "")
    return if !@flag_draw
    return if @eagle_sprite_face == nil
    params = param.split('|')
    @eagle_sprite_face.motion(params[0], params[1] || "")
  end
  #--------------------------------------------------------------------------
  # ● 初始化脸图
  #--------------------------------------------------------------------------
  def eagle_draw_face(face_name, face_index)
    face_params[:name] = face_name
    face_params[:i] = face_index
    return eagle_move_out_face if face_name == ""
    if @eagle_sprite_face
      return if @eagle_sprite_face.no_change?
      eagle_move_out_face
    end
    @eagle_sprite_face = MESSAGE_EX.facepool_new
    @eagle_sprite_face.reset(self)
    @eagle_sprite_face.motion(:fade_in)
  end
  #--------------------------------------------------------------------------
  # ● 移出脸图
  #--------------------------------------------------------------------------
  def eagle_move_out_face
    return if @eagle_sprite_face.nil?
    @eagle_sprite_face.motion(:fade_out)
    MESSAGE_EX.facepool_push(@eagle_sprite_face) # 由精灵池接管
    @eagle_sprite_face = nil
  end
  #--------------------------------------------------------------------------
  # ● 脸图占用的宽度
  #--------------------------------------------------------------------------
  def eagle_face_width
    return 0 if !game_message.face?
    return 0 if face_params[:z] < 0
    face_params[:width] + face_params[:dw]
  end
  #--------------------------------------------------------------------------
  # ● 脸图在左侧占用的宽度（用于调整文字区域的左侧起始位置）
  #--------------------------------------------------------------------------
  def eagle_face_left_width
    return 0 if face_params[:dir] # 显示在右侧时
    eagle_face_width
  end
  #--------------------------------------------------------------------------
  # ● 脸图在右侧占用的宽度
  #--------------------------------------------------------------------------
  def eagle_face_right_width
    return 0 if !face_params[:dir] # 显示在左侧时
    eagle_face_width
  end

  #--------------------------------------------------------------------------
  # ● 设置pause参数
  #--------------------------------------------------------------------------
  def pause_params; game_message.pause_params; end
  def eagle_text_control_pause(param = "")
    parse_param(pause_params, param, :pause)
    @eagle_sprite_pause.reset
  end
  #--------------------------------------------------------------------------
  # ● 设置wait参数
  #--------------------------------------------------------------------------
  def eagle_text_control_wait(param = '0')
    h = {}
    h[:t] = 0 # 等待帧数
    parse_param(h, param, :t)
    wait(h[:t])
  end
  #--------------------------------------------------------------------------
  # ● （覆盖）等待
  #--------------------------------------------------------------------------
  def wait(duration)
    return if !@flag_draw
    duration.times { break if @eagle_force_close; Fiber.yield }
  end
  #--------------------------------------------------------------------------
  # ● 设置auto参数
  #--------------------------------------------------------------------------
  def eagle_text_control_auto(param = '0')
    h = {}
    h[:t] = win_params[:auto_t] # 自动继续的帧数
    h[:r] = win_params[:auto_r]
    parse_param(h, param, :t)
    win_params[:auto_t] = h[:t]
    win_params[:auto_r] = MESSAGE_EX.check_bool(h[:r])
  end
  #--------------------------------------------------------------------------
  # ● 执行shake
  #--------------------------------------------------------------------------
  def eagle_text_control_shake(param = '0')
    return if !@flag_draw
    h = {}
    h[:p] = 5 # shake power
    h[:s] = 5 # shake speed
    h[:t] = 40 # shake duration
    parse_param(h, param, :t)
    # 等待震动至结束
    shake = 0 # 对话框的偏移值
    shake_direction = 1 # 下一次位移量
    while h[:t] > 0
      delta = (h[:p] * h[:s] * shake_direction) / 10.0
      shake += delta
      shake_direction = -1 if shake > h[:p] * 2
      shake_direction = 1 if shake < - h[:p] * 2
      h[:t] -= 1
      self.x += shake
      eagle_after_update_xy
      Fiber.yield
    end
    shake = shake.to_i # 平滑移动回初始位置
    d = shake > 0 ? -1 : 1
    while shake != 0
      shake += d
      self.x += shake
      eagle_after_update_xy
      Fiber.yield
    end
  end
  #--------------------------------------------------------------------------
  # ● 执行eval指令
  #--------------------------------------------------------------------------
  def eagle_text_control_eval(param = '0')
    return if !@flag_draw
    id_ = param.to_i
    if id_ > 0 && @eagle_evals[id_ - 1]
      s = $game_switches; v = $game_variables; msg = self
      eval( @eagle_evals[id_ - 1] )
    end
  end
  #--------------------------------------------------------------------------
  # ● 设置set参数
  #--------------------------------------------------------------------------
  def eagle_text_control_set(param = '0')
    return if !@flag_draw
    return @eagle_current_set = nil if param == '0'
    @eagle_current_set = param
    @eagle_chara_sets[@eagle_current_set] ||= []
  end
  def eagle_text_control_setm(param = '0')
    return if !@flag_draw
    params = param.split('|') # [set_sym, effect_sym, param]
    if params[2] == "0"
      chara_set(params[0]) { |s| s.finish_effect(params[1].to_sym) }
    else
      chara_set(params[0]) { |s| s.start_effect(params[1].to_sym, params[2]) }
    end
  end
  #--------------------------------------------------------------------------
  # ● 对指定分组内的文字执行block
  #   传入空字符串或 0 时为全部文字
  #--------------------------------------------------------------------------
  def chara_set(set_sym = nil) # block
    if set_sym.nil? || set_sym.empty? || set_sym == 0 || set_sym == '0'
      @eagle_chara_sprites.each { |s| yield(s) }
      return
    end
    return if @eagle_chara_sets[set_sym].nil?
    @eagle_chara_sets[set_sym].each { |s| yield(s) }
  end
  #--------------------------------------------------------------------------
  # ● 设置扩展参数
  #--------------------------------------------------------------------------
  def ex_params; game_message.ex_params; end
  #--------------------------------------------------------------------------
  # ● 设置cg参数 / 渐变绘制预定
  #--------------------------------------------------------------------------
  if defined?(Sion_GradientText)
  def eagle_text_control_cg(param = '0')
    ex_params[:cg].clear
    ex_params[:cg] = param if param != '' && param != '0'
  end
  end

  #--------------------------------------------------------------------------
  # ● 输入处理（此处为全部绘制完成后，判定接下来的输入类型）
  #--------------------------------------------------------------------------
  def process_input
    if game_message.choice?
      input_choice
    elsif game_message.num_input?
      input_number
    elsif game_message.item_choice?
      input_item
    else
      input_pause unless @pause_skip
    end
    eagle_process_hold
  end
  #--------------------------------------------------------------------------
  # ● 处理输入等待
  #--------------------------------------------------------------------------
  def input_pause
    return if !@flag_draw
    before_input_pause
    eagle_process_draw_update # 统一更新一次
    @eagle_sprite_pause.bind_last_chara(@eagle_chara_sprites[-1])
    @eagle_sprite_pause.show
    @flag_input_pause = true
    self.pause = true unless MESSAGE_EX::NO_DEFAULT_PAUSE
    process_input_pause
    self.pause = false
    @flag_input_pause = false
    @eagle_sprite_pause.hide
  end
  #--------------------------------------------------------------------------
  # ● 输入等待前的操作
  #--------------------------------------------------------------------------
  def before_input_pause
    # 当pause精灵位于句末且紧靠边界时
    #  增加对话框宽度保证它在对话框内部（不可占用padding）
    if pause_params[:v] != 0 && pause_params[:do] <= 0 &&
       game_message.input_pause? && eagle_add_w_by_child_window?
      # 最大可用于文字绘制的宽度 eagle_charas_max_w
      # 全部文字实际绘制的宽度 @eagle_charas_w_final + win_params[:cdw]
      # 最后一行所需的绘制宽度 @eagle_next_chara_x
      if @eagle_next_chara_x >= @eagle_charas_w_final
        @eagle_sprite_pause_width_add = @eagle_sprite_pause.width
      else
        d = @eagle_charas_w_final + win_params[:cdw] - @eagle_next_chara_x
        d -= @eagle_sprite_pause.width
        @eagle_sprite_pause_width_add = -d if d <= 0
      end
    else
      @eagle_sprite_pause_width_add = 0
    end
  end
  #--------------------------------------------------------------------------
  # ● 执行输入等待
  #--------------------------------------------------------------------------
  def process_input_pause
    recreate_contents_for_charas
    @eagle_auto_continue_c = win_params[:auto_t]
    ox_max = [self.ox, @eagle_charas_w - @eagle_chara_viewport.rect.width].max
    oy_max = self.oy
    d_oxy = 1; last_input = nil; last_input_c = 0
    self.arrows_visible = true
    while true
      Fiber.yield
      # 处理自动继续
      if @eagle_auto_continue_c
        break if @eagle_auto_continue_c <= 0
        process_while_auto_wait_input_pause(@eagle_auto_continue_c)
        @eagle_auto_continue_c -= 1
      end
      break if check_input_pause?
      # 处理内容滚动
      if Input.press?(:UP)
        self.oy -= d_oxy
        self.oy = 0 if self.oy < 0
      elsif Input.press?(:DOWN)
        self.oy += d_oxy
        self.oy = oy_max if self.oy > oy_max
      elsif Input.press?(:LEFT)
        self.ox -= d_oxy
        self.ox = 0 if self.ox < 0
      elsif Input.press?(:RIGHT)
        self.ox += d_oxy
        self.ox = ox_max if self.ox > ox_max
      end
      if last_input == Input.dir4
        last_input_c += 1
        d_oxy += 1 if last_input_c % 10 == 0
      else
        d_oxy = 1
        last_input_c = 0
      end
      last_input = Input.dir4
    end
    self.arrows_visible = false
    Input.update
  end
  #--------------------------------------------------------------------------
  # ● 等待按键时，启用auto时的额外处理
  #  c 为自动继续的剩余帧数，从 win_params[:auto_t] 获取总等待帧数
  #--------------------------------------------------------------------------
  def process_while_auto_wait_input_pause(c)
    @eagle_sprite_pause.redraw_auto_countdown(c)
  end
  #--------------------------------------------------------------------------
  # ● 检查输入等待的按键
  #--------------------------------------------------------------------------
  def check_input_pause?
    Input.trigger?(:B) || Input.trigger?(:C)
  end
  #--------------------------------------------------------------------------
  # ● 处理选项的输入（覆盖）
  #--------------------------------------------------------------------------
  def input_choice
    input_wait_until_msg_wh(@choice_window)
    input_wait_while_active(@choice_window)
  end
  #--------------------------------------------------------------------------
  # ● 处理数值的输入（覆盖）
  #--------------------------------------------------------------------------
  def input_number
    input_wait_until_msg_wh(@number_window)
    input_wait_while_active(@number_window)
  end
  #--------------------------------------------------------------------------
  # ● 处理物品的选择（覆盖）
  #--------------------------------------------------------------------------
  def input_item
    input_wait_until_msg_wh(@item_window)
    input_wait_while_active(@item_window)
  end
  #--------------------------------------------------------------------------
  # ● 等待对话框宽高处理结束
  #--------------------------------------------------------------------------
  def input_wait_until_msg_wh(child_window)
    child_window.hide.start
    eagle_set_wh # 执行因子窗口嵌入而变更的窗口大小
    child_window.show.open.activate
  end
  #--------------------------------------------------------------------------
  # ● 并行等待子窗口处理结束
  #--------------------------------------------------------------------------
  def input_wait_while_active(child_window)
    while child_window.active
      break child_window.deactivate.close if @eagle_force_close
      @fiber_para.resume if @fiber_para
      Fiber.yield
    end
    @fiber_para = nil
  end
end # end of class Window_EagleMessage

#=============================================================================
# ○ 对话框拷贝
#=============================================================================
class Window_EagleMessage_Clone < Window_EagleMessage
  attr_accessor :back_bitmap, :back_sprite
  attr_accessor :eagle_chara_viewport
  attr_accessor :eagle_chara_sprites, :eagle_sprite_pop_tag
  attr_accessor :eagle_sprite_face, :eagle_window_name, :eagle_sprite_pause
  attr_accessor :eagle_pop_obj
  #--------------------------------------------------------------------------
  # ● 初始化对象
  #--------------------------------------------------------------------------
  def initialize(game_message)
    @game_message = game_message
    super()
    self.openness = 255
    @fin = false # 结束显示？
  end
  #--------------------------------------------------------------------------
  # ● 初始化组件（覆盖，不再初始化，防止在赋值前还要dispose）
  #--------------------------------------------------------------------------
  def eagle_message_init_assets
  end
  #--------------------------------------------------------------------------
  # ● 获取主参数
  #--------------------------------------------------------------------------
  def game_message
    @game_message
  end
  #--------------------------------------------------------------------------
  # ● 重置单页对话框（覆盖，防止过早移出组件）
  #--------------------------------------------------------------------------
  def eagle_message_reset
    @eagle_sprite_pause_width_add = 0 # 拷贝窗口中不存在pause精灵
  end
  #--------------------------------------------------------------------------
  # ○ 记录文本的宽高（用于更新大小）
  #--------------------------------------------------------------------------
  def eagle_set_chara_wh(w, h, w_final, h_final)
    @eagle_charas_w = w
    @eagle_charas_h = h
    @eagle_charas_w_final = w_final
    @eagle_charas_h_final = h_final
  end
  #--------------------------------------------------------------------------
  # ● （覆盖）去除全部子窗口
  #--------------------------------------------------------------------------
  def create_all_windows
  end
  def dispose_all_windows
  end
  def update_all_windows
  end
  #--------------------------------------------------------------------------
  # ● （覆盖）判定是否所有窗口已全部关闭
  #--------------------------------------------------------------------------
  def all_close?
    close?
  end
  #--------------------------------------------------------------------------
  # ● 更新纤程
  #--------------------------------------------------------------------------
  def update_fiber
    if @fiber
      @fiber.resume
    elsif self.openness >= 255 && !@fin
      @fiber = Fiber.new { fiber_main }
      @fiber.resume
    end
  end
  #--------------------------------------------------------------------------
  # ● 处理纤程的主逻辑
  #--------------------------------------------------------------------------
  def fiber_main
    eagle_set_wh( {:open => true} ) # 由于pause精灵需要去除，增加更新宽高
    loop do
      Fiber.yield
      break if @fin
    end
    close_and_wait
    @fiber = nil
  end
  #--------------------------------------------------------------------------
  # ○ 关闭对话框
  #--------------------------------------------------------------------------
  def close_clone
    @fin = true
  end
end

#=============================================================================
# ○ 金钱框窗口
#=============================================================================
class Window_EagleMsgGold < Window_Base
  #--------------------------------------------------------------------------
  # ● 初始化对象
  #--------------------------------------------------------------------------
  def initialize(window_msg)
    bind_window(window_msg)
    super(0, 0, window_width, fitting_height(1))
    self.x = Graphics.width - self.width
    self.y = 0
    self.openness = 0
  end
  #--------------------------------------------------------------------------
  # ● 绑定对话框
  #--------------------------------------------------------------------------
  def bind_window(window)
    @window_msg = window
  end
  #--------------------------------------------------------------------------
  # ● 获取窗口的宽度
  #--------------------------------------------------------------------------
  def window_width
    return 160
  end
  #--------------------------------------------------------------------------
  # ● 刷新
  #--------------------------------------------------------------------------
  def refresh
    contents.clear
    draw_currency_value(value, currency_unit, 4, 0, contents.width - 8)
  end
  #--------------------------------------------------------------------------
  # ● 获取持有金钱
  #--------------------------------------------------------------------------
  def value
    $game_party.gold
  end
  #--------------------------------------------------------------------------
  # ● 获取货币单位
  #--------------------------------------------------------------------------
  def currency_unit
    Vocab::currency_unit
  end
  #--------------------------------------------------------------------------
  # ● 打开窗口
  #--------------------------------------------------------------------------
  def open
    refresh
    super
  end
end

#=============================================================================
# ○ 姓名框窗口
#=============================================================================
class Window_EagleMsgName < Window_Base
  #--------------------------------------------------------------------------
  # ● 获取文字颜色
  #     n : 文字颜色编号（0..31）
  #--------------------------------------------------------------------------
  def text_color(n)
    MESSAGE_EX.text_color(n, self.windowskin)
  end
  #--------------------------------------------------------------------------
  # ● 初始化对象
  #--------------------------------------------------------------------------
  def initialize(window_msg)
    bind_window(window_msg)
    super(0, 0, 32, 32)
    self.openness = 0
    @back_sprite = Sprite.new
    @params = {}
  end
  #--------------------------------------------------------------------------
  # ● 绑定对话框
  #--------------------------------------------------------------------------
  def bind_window(window)
    @window_msg = window
  end
  #--------------------------------------------------------------------------
  # ● 姓名参数
  #--------------------------------------------------------------------------
  def name_params
    @window_msg.name_params
  end
  #--------------------------------------------------------------------------
  # ● 获取行高
  #--------------------------------------------------------------------------
  def line_height
    name_params[:size]
  end
  #--------------------------------------------------------------------------
  # ● 获取全部文本
  #--------------------------------------------------------------------------
  def all_text
    t = MESSAGE_EX.get_name_prefix + name_params[:name]
    t.gsub!(/<(.*?)>/) { "[" + $1 + "]" }
    t = @window_msg.convert_escape_characters(t)
    t
  end
  #--------------------------------------------------------------------------
  # ● 姓名没有变化？
  #--------------------------------------------------------------------------
  def no_change?
    @params[:name] == name_params[:name]
  end
  #--------------------------------------------------------------------------
  # ● 开始
  #--------------------------------------------------------------------------
  def start
    self.show.open
  end
  #--------------------------------------------------------------------------
  # ● 重置
  #--------------------------------------------------------------------------
  def reset
    return close if name_params[:name] == ""
    return if open? && no_change?
    @params[:name] = name_params[:name]
    t = all_text
    reset_size(t)
    redraw(t)
    skin = @window_msg.get_cur_windowskin_index(name_params[:skin])
    self.windowskin = MESSAGE_EX.windowskin(skin)
    if name_params[:bg] && eagle_draw_bg_pic(self.width, self.height)
      @back_sprite.visible = true
      self.opacity = 0
      self.back_opacity = 0
    else
      @back_sprite.visible = false
      self.opacity = name_params[:opa]
      self.back_opacity = name_params[:opa]
    end
    self.contents_opacity = 255
  end
  #--------------------------------------------------------------------------
  # ● 重设窗口大小
  #--------------------------------------------------------------------------
  def reset_size(t)
    contents.font.size = name_params[:size]
    w, h = MESSAGE_EX.calculate_text_wh(contents, t)
    h = [h, name_params[:size]].max
    move(0, 0, w + standard_padding * 2, h + standard_padding * 2)
    create_contents
  end
  #--------------------------------------------------------------------------
  # ● 重绘
  #--------------------------------------------------------------------------
  def redraw(t)
    change_color(text_color(@window_msg.font_params[:c]))
    MESSAGE_EX.apply_font_params(contents.font, @window_msg.font_params)
    draw_text_ex(0, 0, t)
  end
  #--------------------------------------------------------------------------
  # ● 重置字体设置
  #--------------------------------------------------------------------------
  def reset_font_settings
    change_color(normal_color)
    contents.font.size = name_params[:size]
    contents.font.bold = false
    contents.font.italic = false
  end
  #--------------------------------------------------------------------------
  # ● 获取控制符的参数（这个方法会破坏原始数据）
  #--------------------------------------------------------------------------
  def obtain_escape_param_string(text)
    text.slice!(/^\[[\|\$\-\d\w]+\]/)[1..-2] rescue ""
  end
  #--------------------------------------------------------------------------
  # ● 控制符的处理
  #     code : 控制符的实际形式（比如“\C[1]”是“C”）
  #     text : 绘制处理中的字符串缓存（字符串可能会被修改）
  #     pos  : 绘制位置 {:x, :y, :new_x, :height}
  #--------------------------------------------------------------------------
  def process_escape_character(code, text, pos)
    if code.upcase == 'C'
      change_color(text_color(obtain_escape_param_string(text)))
      return
    end
    super(code, text, pos)
  end
  #--------------------------------------------------------------------------
  # ● 绘制背景图片
  #--------------------------------------------------------------------------
  def eagle_draw_bg_pic(w, h)
    _bitmap = MESSAGE_EX.namebg(name_params[:bg], w, h)
    if _bitmap != nil
      @back_sprite.bitmap = _bitmap
      return true
    end
    return false
  end
  #--------------------------------------------------------------------------
  # ● 更新背景精灵
  #--------------------------------------------------------------------------
  def update_back_sprite
    MESSAGE_EX.reset_xy_dorigin(@back_sprite, self, name_params[:bgo])
    MESSAGE_EX.reset_sprite_oxy(@back_sprite, name_params[:bgo])
  end
  def update_back_sprite_opa(opa)
    @back_sprite.opacity = opa
  end
  #--------------------------------------------------------------------------
  # ● 更新（在 eagle_win_update 中调用）
  #--------------------------------------------------------------------------
  def update_with_msg
    update_position
    update_back_sprite
  end
  #--------------------------------------------------------------------------
  # ● 更新位置
  #  尽管已经更新了姓名框位置，但保留此处用于扩展
  #--------------------------------------------------------------------------
  def update_position
  end
end

#=============================================================================
# ○ 等待按键的精灵
#=============================================================================
class Sprite_EaglePauseTag < Sprite
  #--------------------------------------------------------------------------
  # ● 初始化对象
  #--------------------------------------------------------------------------
  def initialize(window_bind)
    super(nil)
    bind_window(window_bind)
    @type_source = 0 # 记录当前源位图的类型（见module中对应【设置】）
    @type_pos = 0 # 记录当前相对于对话框的位置类型
    @last_chara = nil
    @last_pause_index = nil
    init_auto_countdown
    reset
    hide
  end
  #--------------------------------------------------------------------------
  # ● 绑定window
  #--------------------------------------------------------------------------
  def bind_window(window_bind)
    @window_bind = window_bind
  end
  #--------------------------------------------------------------------------
  # ● 释放
  #--------------------------------------------------------------------------
  def dispose
    @sprite_auto_countdown.bitmap.dispose if @sprite_auto_countdown.bitmap
    @sprite_auto_countdown.dispose
    @s_bitmap.dispose
    self.bitmap.dispose
    super
  end
  #--------------------------------------------------------------------------
  # ● 获取参数组
  #--------------------------------------------------------------------------
  def params
    @window_bind.pause_params
  end
  #--------------------------------------------------------------------------
  # ● 绑定文末精灵
  #--------------------------------------------------------------------------
  def bind_last_chara(sprite_chara)
    @last_chara = sprite_chara
    reset_position
  end
  #--------------------------------------------------------------------------
  # ● 重置
  #--------------------------------------------------------------------------
  def reset
    reset_source if @last_pause_index != params[:pause]
    reset_bitmap
  end
  #--------------------------------------------------------------------------
  # ● 重置源位图
  #--------------------------------------------------------------------------
  def reset_source
    @s_bitmap.dispose if @s_bitmap
    @last_pause_index = params[:pause]
    _params = MESSAGE_EX.pause_params(@last_pause_index)
    _bitmap = Cache.system(_params[0])
    _rect = _params[1].nil? ? _bitmap.rect : _params[1]
    @s_bitmap_row = _params[2] # 源位图中一行中帧数目
    @s_bitmap_col = _params[3] # 源位图中一列中帧数目
    @s_bitmap_n = @s_bitmap_row * @s_bitmap_col # 总帧数

    @s_bitmap = Bitmap.new(_rect.width, _rect.height)
    @s_bitmap.blt(0, 0, _bitmap, _rect)
    @s_rect = Rect.new(0, 0, @s_bitmap.width / @s_bitmap_row,
      @s_bitmap.height / @s_bitmap_col)

    self.bitmap.dispose if self.bitmap
    self.bitmap = Bitmap.new(@s_rect.width, @s_rect.height)
    @index = 0 # 当前index
  end
  #--------------------------------------------------------------------------
  # ● 重绘位图
  #--------------------------------------------------------------------------
  def reset_bitmap
    self.bitmap.clear
    @s_rect.x = (@index % @s_bitmap_row) * @s_rect.width
    @s_rect.y = (@index / @s_bitmap_row) * @s_rect.height
    self.bitmap.blt(0, 0, @s_bitmap, @s_rect)
    @count = 0
  end
  #--------------------------------------------------------------------------
  # ● 更新位置
  #--------------------------------------------------------------------------
  def reset_position
    self.viewport = nil
    if params[:do] > 0
      MESSAGE_EX.reset_xy_dorigin(self, @window_bind, params[:do])
    elsif @last_chara
      self.viewport = @window_bind.eagle_chara_viewport
      self.x = @last_chara._x + @last_chara.width - @window_bind.eagle_charas_ox
      self.y = @last_chara._y + @last_chara.height/2 - @window_bind.eagle_charas_oy
    else
      self.x = @window_bind.eagle_charas_x0
      self.y = @window_bind.eagle_charas_y0
    end
    self.x += params[:dx]
    self.y += params[:dy]
    MESSAGE_EX.reset_xy_origin(self, params[:o])
    reset_auto_countdown_position
  end
  #--------------------------------------------------------------------------
  # ● 更新
  #--------------------------------------------------------------------------
  def update
    super
    update_index
    reset_position if self.viewport && @last_chara
  end
  #--------------------------------------------------------------------------
  # ● 更新帧动画
  #--------------------------------------------------------------------------
  def update_index
    return if (@count += 1) < params[:t]
    @index = (@index + 1) % @s_bitmap_n
    reset_bitmap
  end
  #--------------------------------------------------------------------------
  # ● 显示
  #--------------------------------------------------------------------------
  def show
    return if params[:v] == 0
    reset_position
    @sprite_auto_countdown.visible = true
    self.visible = true
    self
  end
  #--------------------------------------------------------------------------
  # ● 隐藏
  #--------------------------------------------------------------------------
  def hide
    @sprite_auto_countdown.visible = false
    self.visible = false
    self
  end
  #--------------------------------------------------------------------------
  # ● 初始化自动倒计时
  #--------------------------------------------------------------------------
  def init_auto_countdown
    @auto_countdown_max = 0
    @sprite_auto_countdown = Sprite.new
    @sprite_auto_countdown.bitmap = Bitmap.new(13, 13)
  end
  #--------------------------------------------------------------------------
  # ● 重置自动倒计时
  #--------------------------------------------------------------------------
  def reset_auto_countdown_position
    MESSAGE_EX.reset_xy_dorigin(@sprite_auto_countdown, @window_bind, 3)
    @sprite_auto_countdown.x -= @sprite_auto_countdown.width
    @sprite_auto_countdown.y -= @sprite_auto_countdown.height
    @sprite_auto_countdown.z = self.z + 1
  end
  #--------------------------------------------------------------------------
  # ● 重绘自动倒计时
  #--------------------------------------------------------------------------
  def redraw_auto_countdown(cd)
    return if !$imported["EAGLE-UtilsDrawing"]
    @sprite_auto_countdown.bitmap.clear
    a2 = 360 - (360.0 * cd / @window_bind.win_params[:auto_t]).to_i
    [[4,4],[5,5],[6,6],[5,7],[4,8],
     [6,3],[7,4],[8,5],[9,6],[8,7],[7,8],[6,9]].each do |xy|
      @sprite_auto_countdown.bitmap.set_pixel(xy[0], xy[1], Color.new(255,255,255))
    end
    r = 6
    EAGLE.Arc(@sprite_auto_countdown.bitmap,r,r, r, 0,a2,false,Color.new(255,255,255,250))
  end
end

#==============================================================================
# ○ 精灵池（用于更新需要延迟消失的精灵）
#==============================================================================
module MESSAGE_EX
  #--------------------------------------------------------------------------
  # ● 重置
  #--------------------------------------------------------------------------
  def self.pools_reset
    all_pools.each do |type|
      get_pool(type).each { |s| s.dispose }
      get_pool(type).clear
    end
  end
  #--------------------------------------------------------------------------
  # ● 更新
  #--------------------------------------------------------------------------
  def self.pools_update
    all_pools.each do |type|
      get_pool(type).each { |s| s.update if !s.disposed? && !s.finish? }
    end
  end
  #--------------------------------------------------------------------------
  # ● 从指定池子中取出一个可用的精灵（失败则返回nil）
  #--------------------------------------------------------------------------
  def self.pool_new(type)
    while true
      s = get_pool(type).shift
      return nil if s.nil?
      next if s.disposed?
      if !s.finish?
        get_pool(type).unshift(s)
        return nil
      end
      return s
    end
  end
  #--------------------------------------------------------------------------
  # ● 将指定精灵放入指定池子
  # 【注】精灵需要存在 finish? 方法，该方法返回 true 代表可以被重置复用
  #      返回 false 代表需要继续自己的 update
  #--------------------------------------------------------------------------
  def self.pool_push(type, s)
    return if s.disposed?
    return get_pool(type).unshift(s) if s.finish?
    get_pool(type).push(s)
  end

  #--------------------------------------------------------------------------
  # ● 定义可用的池
  #--------------------------------------------------------------------------
  def self.all_pools
    [:chara, :face]
  end
  #--------------------------------------------------------------------------
  # ● 定义全局数组
  #--------------------------------------------------------------------------
  @pool_charas = [] # 文字精灵池
  @pool_faces  = [] # 脸图精灵池
  def self.get_pool(type)
    return @pool_charas if type == :chara
    return @pool_faces if type == :face
  end

  #--------------------------------------------------------------------------
  # ● 对文字精灵池的操作
  #--------------------------------------------------------------------------
  def self.charapool_push(s)
    pool_push(:chara, s)
  end
  def self.charapool_new(window, font, x,y,w,h, viewport)
    s = pool_new(:chara)
    return Sprite_EagleCharacter.new(window, font, x,y,w,h, viewport) if s.nil?
    s.bind_viewport(viewport)
    s.bind_window(window)
    s.bind_font(font)
    s.reset(x,y,w,h)
    s
  end

  #--------------------------------------------------------------------------
  # ● 对脸图精灵池的操作
  #--------------------------------------------------------------------------
  def self.facepool_push(s)
    pool_push(:face, s)
  end
  def self.facepool_new
    s = pool_new(:face)
    return Sprite_EagleFace.new if s.nil?
    s
  end
end
#=============================================================================
# ○ Scene_Base
#=============================================================================
class Scene_Base
  #--------------------------------------------------------------------------
  # ● 开始处理
  #--------------------------------------------------------------------------
  alias eagle_message_pool_start start
  def start
    MESSAGE_EX.pools_reset
    eagle_message_pool_start
  end
  #--------------------------------------------------------------------------
  # ● 更新画面（基础）
  #--------------------------------------------------------------------------
  alias eagle_message_pool_update_basic update_basic
  def update_basic
    eagle_message_pool_update_basic
    MESSAGE_EX.pools_update
  end
  #--------------------------------------------------------------------------
  # ● 结束处理
  #--------------------------------------------------------------------------
  alias eagle_message_pool_terminate terminate
  def terminate
    eagle_message_pool_terminate
    MESSAGE_EX.pools_reset
  end
end

#=============================================================================
# ○ 脸图精灵
#=============================================================================
class Sprite_EagleFace < Sprite
  attr_accessor :opa
  #--------------------------------------------------------------------------
  # ● 绑定
  #--------------------------------------------------------------------------
  def bind_window(w); @window = w; end
  def face_params; @window.face_params; end
  #--------------------------------------------------------------------------
  # ● 已经结束使用？
  #--------------------------------------------------------------------------
  def finish?
    @flag_fin == true
  end
  #--------------------------------------------------------------------------
  # ● 初始化/重置
  #--------------------------------------------------------------------------
  def reset(window)
    bind_window(window)
    init_params
    apply_face_bitmap
    apply_face_params
  end
  #--------------------------------------------------------------------------
  # ● 初始化参数
  #--------------------------------------------------------------------------
  def init_params
    @params = {}   # 自用参数组
    @flag_fin = false  # 可复用的标志
    @fiber = nil # 移动用 fiber
    @fiber_tmp = nil # 若fiber未执行完，则只预存一个 fiber
    # 为了更好的扩展性，不直接使用默认属性，而是利用中间变量去赋值
    @x0 = @y0 = 0 # 因绑定对话框而获得的基础坐标
    @x1 = @y1 = 0 # 因为移动而增加的偏移
    @opa = 0 # 不透明度
  end
  #--------------------------------------------------------------------------
  # ● 脸图未更改？
  #--------------------------------------------------------------------------
  def no_change?
    @params[:name] == face_params[:name] && @params[:i] == face_params[:i]
  end
  #--------------------------------------------------------------------------
  # ● 设置脸图文件
  #--------------------------------------------------------------------------
  def apply_face_bitmap
    @params[:name] = face_params[:name]
    self.bitmap = Cache.face(@params[:name])
    @params[:name] =~ /_(\d+)x(\d+)_?/i  # 从文件名获取行数和列数（默认为2行4列）
    @params[:num_line] = $1 ? $1.to_i : face_default_line
    @params[:num_col] = $2 ? $2.to_i : face_default_col
    @params[:sole_w] = self.bitmap.width / @params[:num_col]
    @params[:sole_h] = self.bitmap.height / @params[:num_line]
    # 传出脸图宽度，用于对话框中文字位移
    face_params[:width] = @params[:sole_w]
    # 脸图以底部中心为显示原点
    self.ox = @params[:sole_w] / 2
    self.oy = @params[:sole_h]
  end
  #--------------------------------------------------------------------------
  # ● 脸图默认规格（行和列）
  #--------------------------------------------------------------------------
  def face_default_line; 2; end
  def face_default_col;  4; end
  #--------------------------------------------------------------------------
  # ● 导入face参数
  #--------------------------------------------------------------------------
  def apply_face_params
    # 移入移出的参数
    @params[:it] = face_params[:it]
    @params[:ot] = face_params[:ot]

    # 判断是否需要循环的flag
    @params[:flag_l] = (face_params[:ls] > -1 && face_params[:le] > face_params[:ls])
    @params[:ls] = face_params[:ls]
    @params[:lt] = face_params[:lt]
    @params[:lw] = face_params[:lw]
    @params[:li_c] = face_params[:ls] # 循环用index计数
    @params[:lt_c] = face_params[:lt] # 循环用time计数
    @params[:lw_c] = face_params[:lw] # 循环后wait计数

    @params[:i] = face_params[:i]
    apply_index
  end
  #--------------------------------------------------------------------------
  # ● 应用当前帧
  #--------------------------------------------------------------------------
  def apply_index
    return if @params[:i] == nil
    w = @params[:sole_w]
    h = @params[:sole_h]
    x = @params[:i] % @params[:num_col] * w
    y = @params[:i] / @params[:num_col] * h
    rect = Rect.new(x, y, w, h)
    self.src_rect = rect
  end
  #--------------------------------------------------------------------------
  # ● 更新
  #--------------------------------------------------------------------------
  def update
    super
    @fiber.resume if @fiber
    update_position
    update_pattern
  end
  #--------------------------------------------------------------------------
  # ● 更新位置
  #--------------------------------------------------------------------------
  def update_position
    if @window
      if face_params[:dir] # 脸图放置于右侧时
        @x0 = @window.x + @window.width - @window.standard_padding - self.ox
      else # 脸图放置于左侧时
        @x0 = @window.x + @window.standard_padding + self.ox
      end
      @x0 += face_params[:dx]
      @y0 = @window.y + @window.height - @window.standard_padding + face_params[:dy]
      self.mirror = face_params[:m]
      self.z = @window.z + face_params[:z]
    end
    self.x = @x0 + @x1
    self.y = @y0 + @y1
    self.opacity = @opa
  end
  #--------------------------------------------------------------------------
  # ● 更新自动播放
  #--------------------------------------------------------------------------
  def update_pattern
    if @params[:flag_l]
      if @params[:li_c] >= @params[:le]
        # 每次loop之间的等待
        return if @params[:lw].nil?
        @params[:lw_c] -= 1
        return if @params[:lw_c] > 0
        @params[:lw_c] = @params[:lw]
        @params[:li_c] = @params[:ls]
      else
        # 每帧之间的等待
        @params[:lt_c] -= 1
        return if @params[:lt_c] > 0
        @params[:lt_c] = @params[:lt]
        @params[:li_c] += 1
      end
      @params[:i] = @params[:li_c]
      apply_index
    end
  end
  #--------------------------------------------------------------------------
  # ● 执行动作
  #--------------------------------------------------------------------------
  def motion(type, param_str = "")
    m_c = ("fiber_#{type}").to_sym
    if respond_to?(m_c)
      if @fiber
        @fiber_tmp = Fiber.new { fiber_main(m_c, param_str) }
      else
        @fiber = Fiber.new { fiber_main(m_c, param_str) }
      end
    else
      p "对话框中 \epicm 转义符，指令 #{type} 无效！请检查指令名称及其大小写！"
    end
  end
  #--------------------------------------------------------------------------
  # ● Fiber主逻辑
  #--------------------------------------------------------------------------
  def fiber_main(m_c, param_str)
    method(m_c).call(param_str)
    @fiber = nil
    @fiber = @fiber_tmp if @fiber_tmp
    @fiber_tmp = nil
  end
  #--------------------------------------------------------------------------
  # ● 动作：淡入
  #--------------------------------------------------------------------------
  def fiber_fade_in(param_str = "")
    v = 255.0 / @params[:it]
    while(@opa < 255)
      @opa += v
      yield self if block_given?
      Fiber.yield
    end
  end
  #--------------------------------------------------------------------------
  # ● 动作：淡出
  #--------------------------------------------------------------------------
  def fiber_fade_out(param_str = "")
    bind_window(nil)
    v = 255.0 / @params[:ot]
    while(@opa > 0)
      @opa -= v
      yield self if block_given?
      Fiber.yield
    end
    @flag_fin = true
  end
  #--------------------------------------------------------------------------
  # ● 动作：跳跃
  #--------------------------------------------------------------------------
  def fiber_jump(param_str = "")
    t = 0
    while t <= 10
      @y1 = (t-5)**2 * 40 * 1.0/25 - 40
      yield self if block_given?
      Fiber.yield
      t += 1
    end
  end
  #--------------------------------------------------------------------------
  # ● 动作：移动
  #--------------------------------------------------------------------------
  def fiber_move(param_str = "")
    h = { :x => nil, :y => nil, :dx => nil, :dy => nil, :t => 30 }
    MESSAGE_EX.parse_param(h, param_str, :t)

    init_x1 = @x1
    des_x = init_x1
    des_x = init_x1 + h[:dx] if h[:dx]
    des_x = h[:x] if h[:x]
    init_y1 = @y1
    des_y = init_y1
    des_y = init_y1 + h[:dy] if h[:dy]
    des_y = h[:y] if h[:y]
    return if init_x1 == des_x && init_y1 == des_y
    d_x = des_x - init_x1
    d_y = des_y - init_y1

    _i = 0; _t = h[:t]
    while(true)
      break if _i > _t
      per = _i * 1.0 / _t
      per = (_i == _t ? 1 : MESSAGE_EX.ease_value(:face_xy, per))
      @x1 = init_x1 + d_x * per
      @y1 = init_y1 + d_y * per
      yield self if block_given?
      Fiber.yield
      _i += 1
    end
  end
end

#=============================================================================
# ○ 文字绘制类
#=============================================================================
class Font_EagleCharacter
  #--------------------------------------------------------------------------
  # ● 初始化
  #--------------------------------------------------------------------------
  def initialize(font_params)
    @params = font_params.dup
  end
  #--------------------------------------------------------------------------
  # ● 设置参数
  #--------------------------------------------------------------------------
  def set_param(sym, value)
    @params[sym] = value
  end
  #--------------------------------------------------------------------------
  # ● 获取文字颜色
  #     n : 文字颜色编号（0..31）
  #--------------------------------------------------------------------------
  def text_color(n)
    MESSAGE_EX.text_color(n, MESSAGE_EX.windowskin(@params[:skin]))
  end
  #--------------------------------------------------------------------------
  # ● 获取渐变色数组
  #--------------------------------------------------------------------------
  def get_gradient_color(str)
    result = []
    param = str.downcase
    while(param != "")
      param.slice!(/\D+/)
      result.push((param.slice!(/\d+/)).to_i)
    end
    result
  end
  #--------------------------------------------------------------------------
  # ● 执行文字绘制
  #--------------------------------------------------------------------------
  def draw(bitmap, x, y, w, h, c, ali = 0)
    bitmap.font.color = text_color(@params[:c])
    MESSAGE_EX.apply_font_params(bitmap.font, @params)

    draw_param_p(bitmap, x, y, w, h) if @params[:p]
    draw_param_l(bitmap, x, y, w, h, c, ali) if @params[:l]
    if defined?(Sion_GradientText) && @params[:ex_cg] && @params[:ex_cg] != ''
      grad_cs = get_gradient_color(@params[:ex_cg])
      Sion_GradientText.draw_text(bitmap,x,y,w*2,h,c,ali,grad_cs)
    else
      bitmap.draw_text(x, y, w*2, h, c, ali)
    end
    draw_param_m(bitmap, x, y, w, h) if @params[:m]
    draw_param_d(bitmap) if @params[:d]
    draw_param_u(bitmap) if @params[:u]
  end
  #--------------------------------------------------------------------------
  # ● 执行图标绘制
  #--------------------------------------------------------------------------
  def draw_icon(bitmap, x, y, icon_index)
    draw_param_p(bitmap, x, y, 24, 24) if @params[:p]
    draw_param_l_rect(bitmap, x, y, 24, 24) if @params[:l]
    _bitmap = Cache.system("Iconset")
    rect = Rect.new(icon_index % 16 * 24, icon_index / 16 * 24, 24, 24)
    bitmap.blt(x, y, _bitmap, rect, 255)
    draw_param_m(bitmap, x, y, 24, 24) if @params[:m]
    draw_param_d(bitmap) if @params[:d]
    draw_param_u(bitmap) if @params[:u]
  end
  #--------------------------------------------------------------------------
  # ● 绘制底纹
  #--------------------------------------------------------------------------
  def draw_param_p(bitmap, x, y, w, h)
    color = text_color(@params[:pc])
    case @params[:p]
    when 1 # 边框
      bitmap.fill_rect(x, y, w, h, color)
      bitmap.clear_rect(x+1, y+1, w-2, h-2)
    when 2 # 纯色方块
      bitmap.fill_rect(x, y, w, h, color)
    end
  end
  #--------------------------------------------------------------------------
  # ● 绘制外发光
  #--------------------------------------------------------------------------
  def draw_param_l(bitmap, x, y, w, h, c, ali)
    bitmap.font.outline = false
    bitmap.font.shadow = false
    color = bitmap.font.color.dup
    bitmap.font.color = text_color(@params[:lc])
    @params[:lp].times do
      bitmap.draw_text(x, y, w+4, h, c, ali)
      bitmap.blur
    end
    bitmap.font.color = color
  end
  def draw_param_l_rect(bitmap, x, y, w, h)
    c = text_color(@params[:lc])
    bitmap.fill_rect(x, y, w, h, c)
    bitmap.blur
  end
  #--------------------------------------------------------------------------
  # ● 绘制删除线
  #--------------------------------------------------------------------------
  def draw_param_d(bitmap)
    c = text_color(@params[:dc])
    bitmap.fill_rect(0, bitmap.height/2 - 1, bitmap.width, 1, c)
  end
  #--------------------------------------------------------------------------
  # ● 绘制下划线
  #--------------------------------------------------------------------------
  def draw_param_u(bitmap)
    c = text_color(@params[:uc])
    bitmap.fill_rect(0, bitmap.height - 1, bitmap.width, 1, c)
  end
  #--------------------------------------------------------------------------
  # ● 绘制叠加文字
  #--------------------------------------------------------------------------
  def draw_param_m(bitmap, x, y, w, h)
    color = bitmap.font.color.dup
    bitmap.font.color = text_color(@params[:mc]) if @params[:mc] >= 0
    @params[:m].each do |c|
      if c.is_a?(Integer)
        _bitmap = Cache.system("Iconset")
        rect = Rect.new(c % 16 * 24, c / 16 * 24, 24, 24)
        bitmap.blt(x+w/2-12, y+h/2-12, _bitmap, rect, 255)
      else
        bitmap.draw_text(x, y, w, h, c, 1)
      end
    end
    bitmap.font.color = color
  end
  #--------------------------------------------------------------------------
  # ● 执行图片绘制
  #--------------------------------------------------------------------------
  def draw_pic(bitmap, pic_bitmap, h)
    bitmap.stretch_blt(bitmap.rect, pic_bitmap, pic_bitmap.rect, h[:opa])
  end
end
#=============================================================================
# ○ 单个文字的精灵
#=============================================================================
class Sprite_EagleCharacter < Sprite
  attr_reader :origin_x, :origin_y, :_x, :_y, :eagle_font
  attr_accessor :flag_update_pos
  #--------------------------------------------------------------------------
  # ● 初始化对象
  #  window_bind ：所绑定的显示窗口，需要有以下方法
  #    .z 返回窗口的z值（当前文字精灵将高于该值）
  #    .eagle_charas_x0 .eagle_charas_y0 返回文字显示区域的左上角坐标（屏幕坐标）
  #    .eagle_charas_ox .eagle_charas_oy 返回文字显示区域的显示原点（文字区域坐标）
  #    .eagle_charas_max_h 返回文字区域的最大高度
  #  font_bind ：所绑定的字符绘制类 Font_EagleCharacter 的对象
  #--------------------------------------------------------------------------
  def initialize(window_bind, font_bind, x, y, w, h, viewport = nil)
    super(viewport)
    bind_viewport(viewport)
    bind_window(window_bind)
    bind_font(font_bind)
    reset(x, y, w, h)
  end
  #--------------------------------------------------------------------------
  # ● 文字中心点是否在视图内部？
  #--------------------------------------------------------------------------
  def in_viewport?
    return true if self.viewport.nil?
    x_ = self.x - self.ox + self.width / 2
    y_ = self.y - self.oy + self.height / 2
    return false if x_ < 0 || x_ > self.viewport.rect.width
    return false if y_ < 0 || y_ > self.viewport.rect.height
    return true
  end
  #--------------------------------------------------------------------------
  # ● 设置绑定的视图
  #--------------------------------------------------------------------------
  def bind_viewport(vp)
    @viewport_bind = vp
    self.viewport = vp
  end
  #--------------------------------------------------------------------------
  # ● 设置绑定的窗口
  #--------------------------------------------------------------------------
  def bind_window(window_bind)
    @window_bind = window_bind
    self.z = @window_bind.z + 1
  end
  #--------------------------------------------------------------------------
  # ● 设置绑定的绘制参数
  #--------------------------------------------------------------------------
  def bind_font(font_bind)
    @eagle_font = font_bind
  end
  #--------------------------------------------------------------------------
  # ● 取消绑定视图
  #--------------------------------------------------------------------------
  def unbind_viewport
    self.viewport = nil
  end
  #--------------------------------------------------------------------------
  # ● 重新绑定视图
  #--------------------------------------------------------------------------
  def rebind_viewport
    self.viewport = @viewport_bind
  end
  #--------------------------------------------------------------------------
  # ● 释放
  #--------------------------------------------------------------------------
  def dispose
    self.bitmap.dispose if !self.bitmap.disposed?
    super
  end
  #--------------------------------------------------------------------------
  # ● 重置
  #--------------------------------------------------------------------------
  def reset(x, y, w, h)
    self.bitmap.dispose if self.bitmap
    self.bitmap = Bitmap.new(w, h)
    # (x0,y0) 当前的文字显示区域的左上角的屏幕坐标
    @x0 = 0; @y0 = 0
    # (_ox,_oy) 当前的文字显示区域的显示原点位置（对话框内部坐标系）
    @_ox = 0; @_oy = 0
    # 左对齐时，本文字的显示位置（存储为标准位置，方便对齐）
    @origin_x = x; @origin_y = y
    # 设置本文字的显示位置
    reset_xy(x, y)
    reset_oxy(7)
    # 重置参数
    @dx = 0; @dy = 0 # 动态移动时的偏移值
    @flag_update_pos = true # 需要时刻更新位置？
    @flag_move = nil # 在移动中？
    @flag_in_charapool = false # 已经被放入文字池？
    # 重置特效参数
    @effects = {} # effect_sym => param_string
    @params = {} # effect_sym => param_has
    # 重置精灵参数
    self.src_rect = Rect.new(0,0,self.width,self.height)
    self.zoom_x = self.zoom_y = 1.0
    self.angle = 0
    self.wave_amp    = 0
    self.wave_length = 0
    self.wave_speed  = 0
    self.wave_phase  = 0
    self.mirror = false
    self.blend_type = 0
    self.color = Color.new(255,255,255,0)
    self.opacity = 255
    self.visible = true
  end
  #--------------------------------------------------------------------------
  # ● 设置相对偏移值（以对话框中的文字显示区域的屏幕左上角为原点）
  #--------------------------------------------------------------------------
  def reset_xy(x, y)
    @_x = x # 存储文字相对对话框左上角的显示位置
    @_y = y
  end
  #--------------------------------------------------------------------------
  # ● 设置显示原点
  #--------------------------------------------------------------------------
  def reset_oxy(o)
    MESSAGE_EX.reset_sprite_oxy(self, o)
  end
  #--------------------------------------------------------------------------
  # ● 结束
  #--------------------------------------------------------------------------
  def finish
    self.opacity = 0
  end
  #--------------------------------------------------------------------------
  # ● 结束使命？（在文字池中使用，进行文字精灵的复用）
  #--------------------------------------------------------------------------
  def finish?
    self.opacity == 0
  end

  #--------------------------------------------------------------------------
  # ● 解析参数
  #--------------------------------------------------------------------------
  def parse_param(params, param_s, default_type = "default")
    MESSAGE_EX.parse_param(params, param_s, default_type)
  end
  #--------------------------------------------------------------------------
  # ● 初始化特效的默认参数
  #--------------------------------------------------------------------------
  def init_effect_params(sym)
    MESSAGE_EX.get_default_params(sym)
  end
  #--------------------------------------------------------------------------
  # ● 开始特效（整合）
  #--------------------------------------------------------------------------
  def start_effects(effects)
    @effects = effects.dup # code_symbol => param_string
    @effects.each { |sym, param_s| start_effect(sym, param_s) }
  end
  #--------------------------------------------------------------------------
  # ● 开始特效
  #--------------------------------------------------------------------------
  def start_effect(sym, param_s)
    @params[sym] = init_effect_params(sym).dup # 初始化
    m = ("start_effect_" + sym.to_s).to_sym
    method(m).call(@params[sym], param_s.dup) if respond_to?(m)
  end
  # def start_effect_code(param)  code → 转义符
  # end
  #--------------------------------------------------------------------------
  # ● 更新特效（整合）
  #--------------------------------------------------------------------------
  def update_effects
    @effects.each { |sym, param|
      m = ("update_effect_" + sym.to_s).to_sym
      method(m).call(@params[sym]) if respond_to?(m)
    }
  end
  # def update_effect_code(param)  code → 转义符
  # end
  #--------------------------------------------------------------------------
  # ● 结束特效（整合）
  #--------------------------------------------------------------------------
  def finish_effects
    @effects.each { |sym, param|
      m = ("finish_effect_" + sym.to_s).to_sym
      method(m).call(@params[sym]) if respond_to?(m)
    }
    @effects.clear
  end
  #--------------------------------------------------------------------------
  # ● 结束特效
  #--------------------------------------------------------------------------
  def finish_effect(sym)
    m = ("finish_effect_" + sym.to_s).to_sym
    method(m).call(@params[sym]) if respond_to?(m)
    @effects.delete(sym)
  end
  # def finish_effect_code(param)  code → 转义符
  # end

  #--------------------------------------------------------------------------
  # ● 更新
  #--------------------------------------------------------------------------
  def update
    update_position if @flag_update_pos
    return move_update(@flag_move) if @flag_move
    if update_effects?
      super
      update_effects
    end
  end
  #--------------------------------------------------------------------------
  # ● 可以更新特效？
  #--------------------------------------------------------------------------
  def update_effects?
    self.opacity > 0 && !@effects.empty?
  end
  #--------------------------------------------------------------------------
  # ● 更新位置
  #--------------------------------------------------------------------------
  def update_position
    self.x = @_x + @dx + self.ox
    self.y = @_y + @dy + self.oy
    if @window_bind
      @x0 = @window_bind.eagle_charas_x0
      @y0 = @window_bind.eagle_charas_y0
      if self.viewport
        @_ox = @window_bind.eagle_charas_ox
        @_oy = @window_bind.eagle_charas_oy
        self.x -= self.viewport.rect.x
        self.y -= self.viewport.rect.y
      end
    end
    self.x += (@x0 - @_ox)
    self.y += (@y0 - @_oy)
  end
  #--------------------------------------------------------------------------
  # ● 更新移动
  #--------------------------------------------------------------------------
  def move_update(sym = :cin) # 只有移动结束时，才进行其他更新
    params = @params[sym]
    params[:tc] += 1

    per = params[:tc] * 1.0 / params[:t]
    per = (params[:tc] == params[:t] ? 1 : MESSAGE_EX.ease_value(:chara_xy, per))
    @dx = params[:dx_init] + params[:dx_d] * per
    @dy = params[:dy_init] + params[:dy_d] * per

    if (params[:rxc] += 1) == params[:rxt]
      params[:rxc] = 0
      self.src_rect.x += params[:rx]
    end
    if (params[:ryc] += 1) == params[:ryt]
      params[:ryc] = 0
      self.src_rect.y += params[:ry]
    end
    (params[:vzc] = 0;@_zoom += params[:vz]) if (params[:vzc] += 1) == params[:vzt]
    self.zoom_x = self.zoom_y = 1.0 + @_zoom/100.0
    self.angle += params[:va]
    self.opacity += params[:vo]
    move_end(sym) if params[:tc] == params[:t]
  end
  def move_end(sym = :cin)
    rebind_viewport
    reset_oxy(7)
    if sym == :cin
      @dx = @dy = 0
      self.zoom_x = self.zoom_y = 1.0
      self.opacity = 255
      update_position
    elsif sym == :cout
      finish
    end
    @flag_move = nil
  end

  #--------------------------------------------------------------------------
  # ● 移入
  #--------------------------------------------------------------------------
  def start_effect_cin(params, param_s, flag_move_in = true)
    parse_param(params, param_s)
    params[:t] = 1 if params[:t] < 1
    params[:vzc] = 0 # 计数用
    params[:vzt] = 1 if params[:vzt] < 1
    rand_cin(params, param_s) if params[:r] != 0
    _vo = 255 / params[:t] # 移入时每帧不透明度增量
    params[:vo] = [_vo, params[:vo], 1].max
    params[:rxc] = 0; params[:ryc] = 0
    params[:rxt] = 1 if params[:rxt] < 1
    params[:ryt] = 1 if params[:ryt] < 1
    move_in if flag_move_in
  end
  #--------------------------------------------------------------------------
  # ● 随机移入
  #--------------------------------------------------------------------------
  RAND_V = lambda { |v| rand(v * 2 + 1) - v }
  def rand_cin(params, param_s)
    params[:t] = rand(params[:t]) + 1
    params[:vz] = RAND_V.call(params[:vz])
    params[:vzt] = rand(params[:vzt]) + 1
    params[:va] = RAND_V.call(params[:va])
  end
  #--------------------------------------------------------------------------
  # ● 执行移入
  #--------------------------------------------------------------------------
  def move_in
    params = @params[:cin]
    return self.opacity = 255 if params.nil?
    unbind_viewport
    @dx = @dy = 0
    update_position # 用于获取实际的最终显示位置（屏幕坐标）

    _rect = Rect.new(self.x, self.y, self.width, self.height)
    if params[:do] != 0
      MESSAGE_EX.reset_xy_dorigin(_rect, @window_bind, params[:do])
    end
    @dx = params[:dx_init] = _rect.x + params[:dx] - self.x
    @dy = params[:dy_init] = _rect.y + params[:dy] - self.y
    params[:dx_d] = self.x - (_rect.x + params[:dx])
    params[:dy_d] = self.y - (_rect.y + params[:dy])

    @_zoom = -(params[:t]/params[:vzt]) * params[:vz]
    self.angle = -params[:t] * params[:va]
    self.src_rect.x = -(params[:t]/params[:rxt]) * params[:rx]
    self.src_rect.y = -(params[:t]/params[:ryt]) * params[:ry]
    self.opacity = 0
    self.zoom_x = self.zoom_y = 1.0 + @_zoom/100.0
    reset_oxy(5)
    params[:tc] = 0
    @flag_move = :cin
  end
  #--------------------------------------------------------------------------
  # ● 移出
  #--------------------------------------------------------------------------
  def start_effect_cout(params, param_s)
    start_effect_cin(params, param_s, false)
    params[:vo] *= -1
  end
  #--------------------------------------------------------------------------
  # ● 执行移出（外部调用的方法）
  #--------------------------------------------------------------------------
  def move_out
    finish_effects # 先结束全部特效
    finish if !in_viewport? # 若精灵在视图外，则会直接结束
    bind_viewport(nil) # 取消视图，确保不会出现资源崩溃，且不再限制可见范围
    if !finish?
      update_position # 更新一次位置
      process_move_out  # 处理移出模式
    end
    @window_bind = nil # 取消窗口的绑定
    MESSAGE_EX.charapool_push(self) # 由文字池接管
    @flag_in_charapool = true
  end
  #--------------------------------------------------------------------------
  # ● 执行移出（外部调用的方法）（临时移出，之后可以再执行move_in）
  #--------------------------------------------------------------------------
  def move_out_temp
    unbind_viewport
    process_move_out
  end
  #--------------------------------------------------------------------------
  # ● 处理移出模式
  #--------------------------------------------------------------------------
  def process_move_out
    return move_out_cout(@params[:cout]) if @params[:cout] && !@params[:cout].empty?
    return move_out_uout(@params[:uout]) if @params[:uout] && !@params[:uout].empty?
    finish # 如果未预订任何移出模式，则直接结束
  end
  #--------------------------------------------------------------------------
  # ● 执行默认移出
  #--------------------------------------------------------------------------
  def move_out_cout(params)
    _rect = Rect.new(self.x, self.y, self.width, self.height)
    if params[:do] != 0
      MESSAGE_EX.reset_xy_dorigin(_rect, @window_bind, params[:do])
      MESSAGE_EX.reset_xy_origin(_rect, 5)
    end
    params[:dx_init] = 0
    params[:dy_init] = 0
    params[:dx_d] = (_rect.x + params[:dx]) - self.x
    params[:dy_d] = (_rect.y + params[:dy]) - self.y

    @dx = @dy = @_zoom = 0
    reset_oxy(5)
    params[:tc] = 0
    @flag_move = :cout
  end
  #--------------------------------------------------------------------------
  # ● 消散移出
  #--------------------------------------------------------------------------
  def start_effect_uout(params, param_s)
    parse_param(params, param_s)
    params[:dir] = MESSAGE_EX::CU_PARAM_DIR[ params[:dir] ]
    params[:s] = MESSAGE_EX::CU_PARAM_S[ params[:s] ]
  end
  def move_out_uout(params)
    Unravel_Bitmap.new(self.x, self.y, self.bitmap.clone, 0, 0, self.width,
      self.height, params[:n], params[:d], params[:o], params[:dir], params[:s])
    finish
  end
  #--------------------------------------------------------------------------
  # ● 正弦扭曲特效
  #--------------------------------------------------------------------------
  def start_effect_csin(params, param_s)
    parse_param(params, param_s)
    self.wave_amp    = params[:a]
    self.wave_length = params[:l]
    self.wave_speed  = params[:s]
    self.wave_phase  = params[:p]
  end
  #--------------------------------------------------------------------------
  # ● 波浪特效
  #--------------------------------------------------------------------------
  def start_effect_cwave(params, param_s)
    params[:tc] = 0  # 移动计数用初值（一次性）
    parse_param(params, param_s)
  end
  def update_effect_cwave(params)
    return if (params[:tc] += 1) < params[:t]
    params[:tc] = 0
    @dy += params[:vy]
    params[:vy] *= -1 if @dy < -params[:h] || @dy > params[:h]
  end
  #--------------------------------------------------------------------------
  # ● 抖动特效
  #--------------------------------------------------------------------------
  def start_effect_cshake(params, param_s)
    params[:vxc] = 0  # 移动计数用初值（一次性）
    params[:vyc] = 0  # 移动计数用初值（一次性）
    parse_param(params, param_s)
    params[:vx] = rand(2) * 2 - 1 if params[:vx] == 0
    params[:vy] = rand(2) * 2 - 1 if params[:vy] == 0
  end
  def update_effect_cshake(params)
    if (params[:vxc] += 1) > params[:vxt]
      params[:vxc] = 0
      @dx += params[:vx]
      params[:vx] *= -1 if @dx < -params[:l] || @dx > params[:r]
    end
    if (params[:vyc] += 1) > params[:vyt]
      params[:vyc] = 0
      @dy += params[:vy]
      params[:vy] *= -1 if @dy < -params[:u] || @dy > params[:d]
    end
  end
  #--------------------------------------------------------------------------
  # ● 摇摆特效
  #--------------------------------------------------------------------------
  def start_effect_cswing(params, param_s)
    params[:ac] = 0 # 当前偏移角度和
    params[:tc] = 0
    parse_param(params, param_s)
    params[:d] = rand(2) * 2 - 1 if params[:d] == 0
    reset_oxy(params[:o])
    self.angle = 0
  end
  def update_effect_cswing(params)
    return if (params[:tc] -= 1) > 0
    params[:tc] = params[:t]
    params[:ac] += params[:d]
    if params[:ac].abs > params[:a]
      params[:ac] = params[:a] * (params[:ac] > 0 ? 1 : -1)
      params[:d] *= -1
    end
    self.angle = params[:ac]
  end
  #--------------------------------------------------------------------------
  # ● 缩放特效
  #--------------------------------------------------------------------------
  def start_effect_czoom(params, param_s)
    params[:tc] = 0 # 计时
    parse_param(params, param_s)
    params[:zoom_x] = 100 # 初始的总缩放量
    params[:zoom_y] = 100
    reset_oxy(params[:o])
  end
  def update_effect_czoom(params)
    return if (params[:tc] -= 1) > 0
    params[:tc] = params[:t]
    if params[:dx] != 0
      params[:zoom_x] += params[:dx]
      params[:dx] *= -1 if params[:zoom_x] > params[:max] || params[:zoom_x] < params[:min]
      self.zoom_x = params[:zoom_x] * 1.0 / 100
    end
    if params[:dy] != 0
      params[:zoom_y] += params[:dy]
      params[:dy] *= -1 if params[:zoom_y] > params[:max] || params[:zoom_y] < params[:min]
      self.zoom_y = params[:zoom_y] * 1.0 / 100
    end
  end
  #--------------------------------------------------------------------------
  # ● 闪烁特效
  #--------------------------------------------------------------------------
  def start_effect_cflash(params, param_s)
    params[:tc] = 0  # 闪烁后的等待时间计数
    parse_param(params, param_s)
    params[:color] = Color.new(params[:r], params[:g], params[:b], params[:a])
  end
  def update_effect_cflash(params)
    return if (params[:tc] -= 1) > 0
    params[:tc] = params[:t] + params[:d]
    self.flash(params[:color], params[:d])
  end
  #--------------------------------------------------------------------------
  # ● 镜像特效
  #--------------------------------------------------------------------------
  def start_effect_cmirror(params, param_s)
    params[:b]  = '0'
    parse_param(params, param_s, :b)
    self.mirror = (params[:b] == '0' ? false : true)
  end
  def finish_effect_cmirror(params)
    self.mirror = false
  end
  #--------------------------------------------------------------------------
  # ● 消散特效
  #--------------------------------------------------------------------------
  def start_effect_cu(params, param_s)
    params[:t_c] = 0 # 间隔计数
    parse_param(params, param_s)
    params[:dir] = MESSAGE_EX::CU_PARAM_DIR[ params[:dir] ]
    params[:s] = MESSAGE_EX::CU_PARAM_S[ params[:s] ]
  end
  def update_effect_cu(params)
    return if !in_viewport?
    return if (params[:t_c] += 1) < params[:t]
    params[:t_c] = 0
    _x = self.x; _y = self.y
    if(self.viewport)
      _x += self.viewport.rect.x; _y += self.viewport.rect.y
    end
    Unravel_Bitmap.new(_x, _y, self.bitmap.clone, 0, 0, self.width,
      self.height, params[:n], params[:d], params[:o], params[:dir], params[:s])
  end
  #--------------------------------------------------------------------------
  # ● 位图切换特效
  #--------------------------------------------------------------------------
  def start_effect_ctog(params, param_s)
    parse_param(params, param_s)
    params[:bitmaps] = []
    params[:bitmaps].push(self.bitmap)
    charas = MESSAGE_EX.get_charas_array(:ctog, params[:i], params[:n])
    charas.each do |c|
      s = Bitmap.new(self.width, self.height)
      if c.is_a?(Integer)
        @eagle_font.draw_icon(s, 0+self.width/2-12, 0+self.height/2-12, c)
      else
        r = s.text_size(c)
        @eagle_font.draw(s, (self.width-r.width)/2, (self.height-r.height)/2,
          self.width, self.height, c, 0)
      end
      params[:bitmaps].push(s)
    end
    params[:i_cur] = 0
    params[:i_max] = params[:bitmaps].size
    params[:tc] = 0
  end
  def update_effect_ctog(params)
    return if (params[:tc] += 1) < params[:t]
    params[:tc] = 0
    if(params[:r] > 0)
      params[:i_cur] = rand(params[:i_max])
    else
      params[:i_cur] += 1
      params[:i_cur] %= params[:i_max]
    end
    self.bitmap = params[:bitmaps][params[:i_cur]]
  end
  def finish_effect_ctog(params)
    self.bitmap = params[:bitmaps].shift
    params[:bitmaps].each { |b| b.dispose }
    params[:bitmaps].clear
  end
  #--------------------------------------------------------------------------
  # ● 颜色渐变更新特效
  #--------------------------------------------------------------------------
  def start_effect_cgrad(params, param_s)
    params[:c] = []
    s = param_s.downcase
    while(s != "")
      sym = s.slice!(/\D+/)
      v = (s.slice!(/\d+/)).to_i
      next params[:c].push(v) if sym == "c"
      params[sym.to_sym] = v
    end
    params[:tc] = 0
    params[:c1] = self.color
    params[:c1].alpha = 255
    params[:c2] = @window_bind.text_color(params[:c][0])
    params[:i] = 0
  end
  def update_effect_cgrad(params)
    return if @window_bind.nil?
    params[:tc] += 1
    self.color.red = params[:c1].red +
      (params[:c2].red - params[:c1].red)*1.0/ params[:t] * params[:tc]
    self.color.green = params[:c1].green +
      (params[:c2].green - params[:c1].green)*1.0 / params[:t] * params[:tc]
    self.color.blue = params[:c1].blue +
      (params[:c2].blue - params[:c1].blue)*1.0 / params[:t] * params[:tc]

    if params[:tc] >= params[:t]
      params[:c1] = @window_bind.text_color(params[:c][params[:i]])
      params[:i] += 1
      params[:i] = 0 if params[:i] >= params[:c].size
      params[:c2] = @window_bind.text_color(params[:c][params[:i]])
      params[:tc] = 0
    end
  end
  #--------------------------------------------------------------------------
  # ● 文字叠加绘制
  #--------------------------------------------------------------------------
  def start_effect_cmc(params, param_s)
    parse_param(params, param_s)
    charas = MESSAGE_EX.get_charas_array(:cmc, params[:i], params[:n])
    @eagle_font.set_param(:m, charas)
    @eagle_font.set_param(:mc, params[:c])
  end
end

#=============================================================================
# ○ 兼容模式
#=============================================================================
module MESSAGE_EX::COMPA_MODE
  #--------------------------------------------------------------------------
  # ● 更新画面
  #--------------------------------------------------------------------------
  def update_all_windows
    if $game_message.eagle_message == true
      @message_window = @msg_windows[1]
    else
      @message_window = @msg_windows[0]
    end
    eagle_message_ex_compa_mode_update_all_windows
  end
  #--------------------------------------------------------------------------
  # ● 释放所有窗口
  #--------------------------------------------------------------------------
  def dispose_all_windows
    @msg_windows.each { |w| w.dispose }
    @message_window = nil
    eagle_message_ex_compa_mode_dispose_all_windows
  end
end
#=============================================================================
# ○ Scene_Map
#=============================================================================
class Spriteset_Map; attr_reader :character_sprites; end
class Scene_Map
  attr_reader :spriteset, :message_window
if EAGLE_MSG_EX_COMPAT_MODE == true
  alias eagle_message_ex_compa_mode_update_all_windows update_all_windows
  alias eagle_message_ex_compa_mode_dispose_all_windows dispose_all_windows
  include MESSAGE_EX::COMPA_MODE
  #--------------------------------------------------------------------------
  # ● 生成信息窗口
  #--------------------------------------------------------------------------
  def create_message_window
    @msg_windows = [Window_Message.new, Window_EagleMessage.new]
    @message_window = @msg_windows[0]
  end
else
  #--------------------------------------------------------------------------
  # ● 生成信息窗口
  #--------------------------------------------------------------------------
  def create_message_window
    @message_window = Window_EagleMessage.new
  end
end
end
#=============================================================================
# ○ Scene_Battle
#=============================================================================
class Scene_Battle
  attr_reader :spriteset, :message_window
if EAGLE_MSG_EX_COMPAT_MODE == true
  alias eagle_message_ex_compa_mode_update_all_windows update_all_windows
  alias eagle_message_ex_compa_mode_dispose_all_windows dispose_all_windows
  include MESSAGE_EX::COMPA_MODE
  #--------------------------------------------------------------------------
  # ● 生成信息窗口
  #--------------------------------------------------------------------------
  def create_message_window
    @msg_windows = [Window_Message.new, Window_EagleMessage.new]
    @message_window = @msg_windows[0]
  end
else
  #--------------------------------------------------------------------------
  # ● 生成信息窗口
  #--------------------------------------------------------------------------
  def create_message_window
    @message_window = Window_EagleMessage.new
  end
end
end
