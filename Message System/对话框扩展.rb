#=============================================================================
# ■ 对话框扩展 by 老鹰（http://oneeyedeagle.lofter.com/）
#=============================================================================
$imported ||= {}
$imported["EAGLE-MessageEX"] = true
#=============================================================================
# - 2020.6.2.10 新增文字乱序移出
#=============================================================================
# - 对话框中对于 \code[param] 类型的转义符，传入param串、并执行code相对应的指令
# - code 指令名解析：
#     下述列举出的转义符（英文字符组合）
# - param 变量参数字符串解析：
#     param 由 变量名（字母组合）+ 参数值（整数或nil（用$代表传入nil）） 重复构成
#    当传入 无变量名 的 参数值 时，将存入其【默认】变量
#    而未被传入值的 变量 ，将读取上一次所设置的通用值
#   （带有【重置】的变量，每一次进行转义符设置时，都会先重置为预设值）
# - 示例：
#     \foo[1b-1tc0d$] 【默认】变量名称 a
#    → 调用 foo 所对应的指令，并给所有变量传入预设值
#      再给 a 变量传入值 1，b 变量传入值 -1，tc 变量传入值 0，d 变量传入值 nil
# - 注意：
#    ·转义符的全部内容（\code[param]）均不会被绘制
#    ·指令和变量参数字符串的大小写差异不会影响读取
#    ·转义符会在绘制到达时生效
#      但若有【预先】，则会在绘制开始前生效（绘制到达时不会再次生效）
#      但若有【结尾】，则只在全部文字绘制完成后生效
#----------------------------------------------------------------------------
# ● 转义符及其变量列表
#----------------------------------------------------------------------------
# - 文本替换类
#     此类别的转义符将会在绘制开始前，预先进行目标文本的替换
#     将按照下面的排列顺序进行先后替换，因此请注意相互之间的嵌套模式
#
#  \conv[string] → 替换成 CONVERT_ESCAPE 中设置的 string 符号对应的文本内容
#
#  \rb{string} → 替换成 eval(string) 的返回结果
#    【注意】该转义符使用花括号，同时 string 中不可以出现花括号
#    可用 s 代替 $game_switches ，用 v 代替 $game_variables
#
#  \info[type+id] → 替换成指定数据库对象的 图标+名称 的文本
#    type → 数据库对象的类型（s代表技能，i代表物品，w代表武器，a代表防具）
#    id → 数据库对象的序号
#    示例：\info[i16] → 绘制 16号物品 的 图标+名称
#
#  \nl → 替换成换行转义符 \n（效果等同编辑器中的手动回车）
#    （由于编辑器自身限制，部分文本框无法识别输入的\n，因此添加该转义符）
#
#----------------------------------------------------------------------------
# - 控制类
#    对于带有 是否 描述的bool变量，数字0 代表 false，正数（推荐数字1）代表 true
#    对于未说明 nil 效果的变量，请尽量不要传入 nil（传入符号$代表传入nil）
#
#  \font[param] → 设置单个字的绘制选项（默认取Font模块的设定）
#    size → 【默认】字体大小
#    i → 是否斜体（font.italic）
#    b → 是否加粗（font.bold）
#    s → 是否添加阴影（font.shadow）
#    ca → 文字的不透明度（0~255）
#    o → 是否添加边框（font.outline）
#    or/og/ob/oa → 设置边框颜色RGBA（0~255）
#    p → 底部花纹的类型（0不绘制，1边框，2实心方框）
#    pc → 底部花纹的颜色索引号（具体查看 Window.png 右下角部分，同默认\c[id]转义符）
#    l → 是否绘制外发光（若开启，则强制关闭阴影和边框）
#    lc → 外发光的颜色索引号
#    lp → 外发光的强度
#    d → 是否绘制删除线
#    dc → 删除线的颜色索引号
#    u → 是否绘制下划线
#    uc → 下划线的颜色索引号
#
#  \win[param] → 对话框窗口的基本设置
#  （窗口属性相关）
#    z → 对话框的z值（仅正整数有效）（默认取va设置的200）
#    skin → 对话框所用windowskin的index（按常量设置进行 index → skin名称 映射）
#    bg → 对话框背景图片的index（按常量设置进行 index → 图片名称 映射）
#        （若读取成功，将不显示窗口皮肤；若读取失败，仍绘制窗口皮肤）
#    bgo → 对话框背景图片与对话框的对齐原点（对应九宫格小键盘）
#        （默认背景图片的左上角与对话框左上角对齐7）
#  （窗口位置相关）
#    o → 【默认】对话框的显示原点的位置类型（对应九宫格小键盘）（默认左上角7）
#    x/y → 对话框显示原点的屏幕坐标（默认nil，取va设置）
#    do → 基于屏幕的九宫格划分，对话框显示原点的屏幕坐标类型（覆盖x/y）
#        （参考九宫格小键盘，有效值为-1~-9）
#    dx/dy → x、y坐标的补足偏移量（默认0）
#    fix → 是否修正对话框位置（保证对话框完整显示在屏幕内）
#  （窗口大小相关）
#    w → 窗口内容的固定宽度（不含边框）（默认0不设置）（优先级高于dw和fw）
#    dw → 窗口内容宽度是否随文字绘制而动态变更（默认false）
#    fw → 窗口内容宽度是否指定为全部文字绘制完成时的所需宽度值（优先级高于dw）
#    wmin/wmax → 窗口内容宽度的上下限（启用dw/fw时生效）（默认0不设置）
#    h → 窗口内容的固定高度（不含边框）（默认0不设置）（优先级高于dh和fh）
#       （若小于对话框的 line_height 方法值，则识别为行数，并进行二次计算）
#    dh → 窗口内容高度是否随文字绘制而动态变更（默认false）（不翻页）
#    fh → 窗口内容高度是否指定为全部文字绘制完成时的所需高度值（优先级高于dh）
#    hmin/hmax → 窗口内容高度的上下限（启用dh/fh时生效）（若小于行高，则修正为行数）
#  （文本显示相关）
#    se → 启用的打字音类型index（默认0，按常量设置进行 index → 声效SE设置 映射）
#    ali → 文本的对齐方式（0左对齐，1居中对齐，2右对齐；默认0）
#    ck → 缩减的字符间距值（默认0）
#    lh → 设置基础行高 line_height 值（默认0无效，取原方法值）
#    ld → 增加的行间距值（默认0）（默认行间距为0）（每一行行高将取其最大字号）
#    cwi → 单个文字绘制完成后的等待帧数（最小值0）
#    cwo → 单个文字移出开始后的等待帧数（最小值0）
#    cor → 全部文字移出的顺序类型（0正序，1逆序，2乱序，默认0）
#    cfast → 是否允许按键快进（默认true）
#    cdx/cdy/cdw → 文本绘制区域与窗口左侧/上侧/右侧padding的间距（默认0）
#
#  \pop[param] → 启用气泡类型对话框时的设置
#    id → 【重置】【默认】所绑定对象的id
#     【地图】传入 0 时取执行当前对话框的事件的id
#            传入 正数id 时取当前地图id号的事件，目标事件不存在时取当前事件
#            传入 负数id 时取队列中数据库id号的角色，目标角色不在队伍中时取队首角色
#     【战斗】传入 正数id 时取敌群中index序号为id的敌人，目标敌人不存在时pop无效
#            传入 负数id 时取我方参战角色中数据库id号的角色，目标角色不存在时pop无效
#    skin → pop状态下对话框所用皮肤的index（按常量设置进行 index → skin名称 映射）
#         （默认nil，取win转义符中的skin变量的值）
#    do → 对话框相对于绑定对象的位置类型（默认目标顶部中间8）
#         （基于绑定对象的九宫格小键盘位置，5代表目标中心）
#    d → 对话框显示原点远离绑定对象的中心点的像素值（依据do自动选择增减x或y）（默认0）
#    dx/dy → x、y方向上的补足偏移量（默认0）
#    fix → 是否进行位置修正（保证pop对话框完整显示在屏幕内）
#    w → pop对话框的内容固定宽度（覆盖win中的w）（默认0不设置）（优先级高于dw/fw）
#    h → pop对话框的内容固定高度（覆盖win中的h）
#       （若小于对话框的 line_height 方法值，则认定为行数，并进行二次计算）
#    dw → 是否随文字绘制而动态变更pop对话框的内容宽度（默认false）
#    fw → 是否指定为全部文字绘制完成时的所需宽度值（覆盖dw）
#    dh → 是否随文字绘制而动态变更pop对话框的内容高度（默认false）（不翻页）
#    fh → 是否指定为全部文字绘制完成时的所需高度值（覆盖dh）
#
#  \popt[param] → 【预先】指向性箭头的设置（当对话框为pop类型时才显示）
#    tag → 【默认】所用箭头图片的index（按常量设置进行 index → tag名称 映射）
#    td → 设置与所绑定对象的中心的远离偏移值（按pop的do自动设置xy）（默认0）
#
#  \face[param] → 脸图的动态设置
#    【注】脸图文件名包含 _数字1x数字2 时（其中为字母x），
#         将设置该脸图文件的规格为 行数（数字1）x列数（数字2）（默认2行x4列）
#     示例： face_actor_1x1.png → 该脸图规格为 1×1，含有一张脸图，只有index为0有效
#    i → 【重置】【默认】显示当前文件中指定序号的脸图（默认同va对话框传入参数）
#    ls/le → 【重置】定义脸图循环播放的开始index/结束index（负数代表不启用循环）
#    lt → 循环播放时，每两帧之间的等待间隔帧数
#    lw → 循环播放时，每一次loop结束时的等待帧数（nil代表只播放一次）
#
#  \facep[param] → 【预先】脸图的基础设置
#    dir → 【默认】脸图的显示位置（0左侧，1右侧；默认0）
#    m → 是否镜像显示脸图（默认false）
#    it/iv/io → 脸图移入时所用帧数/每帧x的增量/每帧不透明度的增量
#    ot/ov/oo → 脸图移出时所用帧数/每帧x的增量/每帧不透明度的减量
#    dx → 脸图在x方向上的偏移增量（默认0）
#    dy → 脸图在y方向上的偏移增量（默认0）
#    dw → 当嵌入对话框内时，脸图宽度的补足增量（默认0）
#    z → 脸图的z值增量（默认1，在对话框上面）（在对话框下面时，将不占用对话框宽度）
#
#  \name[param] → 【预先】姓名框的设置
#    【注】param 中用 | 分隔 姓名字符串（其中转义符用<>代替[]）与 变量参数字符串
#      （若无变量参数的设置，可省略 | 符号）
#    skin → 姓名框所用皮肤的index（默认nil，同win中设置）
#    o → 姓名框的显示原点的类型（对应九宫格小键盘）（默认左上角7）
#    do → 基于对话框的九宫格位置，姓名框的显示原点所在位置（默认左上角7）
#    dx/dy → x、y坐标的补足偏移量
#    opa → 姓名框背景的不透明度（默认255）（文字的不透明度锁定为255）
#
#  \pause[param] → 等待按键时的帧动画的设置
#    pause → 【默认】等待按键帧动画的类型（按常量设置进行 index → pause参数组 映射）
#    o → 帧动画的显示原点位置类型（九宫格小键盘）（默认左上角7）
#    do → 基于对话框的九宫格位置，自身显示位置的类型（0时显示在文末）（默认2）
#    dx/dy → xy方向上的补足偏移值（默认0）
#    t → 每两帧之间的等待帧数（默认10）
#    v → 是否显示等待按键的帧动画（默认true）
#
#  \shake[param] → 对话框震动（与事件指令中的屏幕震动一致）并等待至结束
#    p → 震动的强度（默认5）
#    s → 震动的速度（默认5）
#    t → 【默认】震动的持续帧数（将补足平滑结束的帧数）（默认40）
#
#  \wait[param] → 等待
#   （注意：和默认的等待类型转义符保持一致，不会被快进跳过、期间不处理按键）
#    t → 【默认】等待的帧数
#
#  \auto[param] → 等待按键时，自动继续的设置
#    若使用了【组件-形状绘制 by老鹰】，则会在对话框右下角绘制简单的倒计时UI
#    t → 【默认】在t帧后自动结束按键等待，并继续事件处理（默认nil，不自动继续）
#    r → 是否为 t 参数附加【重置】属性，即每次对话框打开后不自动继续（默认true）
#
#  \ins → 【预先】当前对话框不再处理绘制间隔的等待（先完成打开，再绘制全部内容）
#
#  \hold → 【结尾】保留当前对话框，直至没有该指令的对话框关闭，关闭所有保留的对话框
#
#  \temp → 【结尾】当前对话框对转义符参数的变更不会被保留
#          （在当前对话框关闭前，转义符参数仍然生效）
#
#----------------------------------------------------------------------------
# - 文字特效类
#     以下 param 传入 任意非0非空字符（如 1） 代表以预设值开启特效
#     只传入 0 代表关闭该特效
#    （除非标注【叠加】，否则多特效同时执行可能会造成奇怪效果）
#
#  \cin[param] → 开启文字移入的特效【独占】（移入完成时才进行其余特效更新）
#    r → 是否将以下全部变量的值变更为正负范围内的随机数？
#         比如传入的 vx5，则实际的 vx 为 -5 ~ 5 中随机一个值
#    t → 移入所用帧数（即移动到最终位置所用帧数）（不透明度从0平滑增加到255）
#    vxt/vx → 每vxt（最小值1）帧x偏移值增加vx像素的值
#    vyt/vy → 每vyt（最小值1）帧y偏移值增加vy像素的值
#    vzt/vz → 每zvt（最小值1）帧zoom放缩值增加vz的值（整数）
#    va → 每帧内angle的增值
#  （以下参数不受 r 的影响）
#    vo → 每帧不透明度的增量（默认为 255/t）
#    rxt/rx → 每rxt（最小值1）帧src_rect的x偏移值增加rx像素的值（默认0）
#    ryt/ry → 每ryt（最小值1）帧src_rect的x偏移值增加ry像素的值（默认0）
#
#  \cout[param] → 开启文字移出的特效【独占】（移出时关闭其余特效更新）
#    r → 是否将以下全部变量的值变更为正负范围内的随机数？
#         比如传入的 vx5，则实际的 vx 为 -5 ~ 5 中随机一个值
#    t → 移出所用帧数（即移动到最终位置所用帧数）（不透明度从255平滑减小到0）
#    vxt/vx → 每vxt（最小值1）帧x偏移值增加vx像素的值
#    vyt/vy → 每vyt（最小值1）帧y偏移值增加vy像素的值
#    vzt/vz → 每zvt（最小值1）帧zoom放缩值增加vz的值（整数）
#    va → 每帧内angle的增值
#  （以下参数不受 r 的影响）
#    vo → 每帧不透明度的减量（默认为 255/t）
#    rxt/rx → 每rxt（最小值1）帧src_rect的x偏移值增加rx像素的值（默认0）
#    ryt/ry → 每ryt（最小值1）帧src_rect的x偏移值增加ry像素的值（默认0）
#
#  \uout[param] → 利用消散移出文字【需要前置Unravel_Bitmap插件】
#    n → 消散的粒子总数（大约）
#    d → 单个粒子的大小（直径/边长）
#    o → 单个粒子消失时的透明度变更最小值
#    dir → 整体消散方向类型（同九宫格小键盘）（1379-四角；5-四方向；46-左右向上）
#    s → 粒子形状类型（0-正方向；1-圆形；2-三角形）
#
#  \csin[param] → 开启正弦波浪扭曲特效
#    a → 正弦波浪的幅度（像素数）
#    l → 正弦波浪的频度（像素数）
#    s → 正弦波浪的动画速度（默认360）
#    p → 正弦波浪的相位角度（最大360°）（一般不需要设置）
#
#  \cwave[param] → 开启上下浮动特效
#    h → 上下浮动的最大偏移像素值
#    t → 每隔t帧进行一次1像素的偏移
#    vy → 起始时的y方向移动速度（正数为向下）
#
#  \cswing[param] → 开启左右摇摆特效（本质为精灵旋转）
#    d → 每次更新增加的角度值（0时随机取正负1）
#    t → 每次角度更新后等待t帧
#    a → 角度可到达的最大值（左右对称）
#    o → 摇摆不动点所在位置类型（键盘九宫格）
#
#  \czoom[param] → 开启缩放特效（本质为精灵缩放）
#    t → 在进行一次缩放变更后的等待帧数
#    dx → x方向的每次缩放增量（单位%，即 1 代表每t帧放大1%，zoom_x增加0.01）
#    dy → y方向的每次缩放增量（单位%，即 1 代表每t帧放大1%，zoom_y增加0.01）
#    o → 缩放不动点所在位置类型（键盘九宫格）
#    min → x和y方向上缩放总量的最小值
#          （在RGSS3中，负数的缩放量不会显示，推荐设置为自然数）
#          （在RGD中，负数的缩放量将反向显示，推荐设置为最大值的相反数）
#    max → x和y方向上缩放总量的最大值
#
#  \cshake[param] → 开启抖动特效
#    l/r/u/d → 设置 左右上下 四个方向的最大移动偏移值
#    vx/vy → 设置x、y方向上的初始移动速度（正数为向右、向下）（0为随机方向）
#    vxt/vyt → 设置x、y方向上移动一次后的等待帧数
#
#  \cflash[param] → 开启闪烁特效【叠加】
#    r/g/b/a → 闪烁的颜色（红、绿、蓝、不透明度）（默认255）（示例：r50g50b100a200）
#    d → 闪烁从开始到完成需要的帧数
#    t → 闪烁完成后的等待帧数
#
#  \cmirror[param] → 开启横轴镜像绘制（无设置参数）【叠加】
#
#  \cu[param] → 开启字符消散特效【叠加】【需要前置Unravel_Bitmap插件】
#    t → 每两次执行消散之间的间隔帧数（正整数）
#    其余同 \uout 的变量
#
#  \ctog[param] → 开启文字切换特效（本质为位图切换）
#    i → 使用 i 号对应的文字组
#    n → 从文字组中挑选出 n 个字符作为切换文字
#    t → 文字切换一次后的等待帧数
#    r → 是否启用随机切换
#
#----------------------------------------------------------------------------
# - 扩展类
#     此处放置整合其他插件效果的转义符，统一放置于 $game_message.ex_params 中
#
#  \cg[c1..] → 渐变描绘文本【需要前置Sion_GradientText插件】
#    变量参数字符串为按序排列的 c + Windowskin颜色索引号，无任何参数时取消渐变绘制
#    示例：\cg[c1c2c1] → 用 1号 2号 1号颜色由上至下进行渐变绘制
#    示例：\cg[] → 取消渐变绘制
#
#----------------------------------------------------------------------------
# ● 高级功能
#----------------------------------------------------------------------------
# - 对话框跨指令继续
#
#   利用该脚本设置对话框不关闭继续显示的开启状态（默认 true）
#
#         $game_message.no_close = true 或者 false
#
# · 若开启且 settings_changed? 方法返回 false，对话框将不关闭，继续显示下一条指令的文本
# · 在当前版本中，如果脸图文件名与脸图索引均未更改，则 settings_changed? 返回 false
#----------------------------------------------------------------------------
# - 自动换行
#
#   利用该脚本设置对话框自动换行的开启状态（默认 true）
#
#         $game_message.auto_wrap = true 或者 false
#
# · 若开启，当文字绘制到对话框边界padding处时，将进行自动换行
# · 只是非常基础的按单个文字切割的自动换行方式，会切割单词，不考虑标点符号
#----------------------------------------------------------------------------
# - 内容滚动
#
# · 当对话框的宽度或高度被固定时，
#    若所绘制的文字超出对话框范围，将自动开启内容滚动效果
#
# · 当进入 等待按键 状态时，按住 方向键 即可朝对应方向滚动浏览对话框全部内容
#----------------------------------------------------------------------------
# - 对话框Open/Close特效优化
#
# · 对话框的开启关闭特效已被优化为 动态展开收缩，而非默认的 上下打开关闭
#
# · 若 $game_message.default_open_type 赋值为 true，则使用默认的 上下打开关闭
#    若 $game_message.default_open_type 赋值为 false，则使用 动态展开收缩
#----------------------------------------------------------------------------
# - 并行处理子窗口
#
#   利用该脚本设置对话框与下一条指令的 选择框/数字输入框/物品选择框 并行处理
#
#         $game_message.para = true
#
# · 当赋值为 true 后，若当前对话框的下一条指令为 选择支/数字输入/物品选择，
#      则会在对话框打开、开始绘制文字时，同步打开并激活选择框
#
# · 当选择框的按键处理结束并关闭时，对话框将同步强制关闭
#    【注意】未被绘制的转义符可能不会生效！
#
# · 该并行设置不会被存储，因此请在每个需要并行处理子窗口的对话框前执行一次该脚本
#----------------------------------------------------------------------------
# - 预定绘制文本
#
#   利用该脚本存储文本，在下次打开对话框时，全部存储文本将按序插入到对话开头
#
#        $game_message.add_escape(param_string)
#
#   param_string 解析： 【String】型常量
#
# · 示例：
#     $game_message.add_escape("\\win[ali1]")
#        → 之后的对话框中 文本居中 绘制
#     $game_message.add_escape("\\pop[0]")
#        → 下一次的对话框为pop类型，绑定在当前执行对话框的事件上
#
# · 注意：
#    ·由于解析问题，在 param_string 中请将 "\" 替换成 "\\"
#    ·当存在多条预定文本，将按照预定时间的先后顺序，依次放入下一次对话框的开头
#    ·预定的字符串只会被放入对话框一次
#    ·不会去除 param_string 中的非转义符文本
#----------------------------------------------------------------------------
# - 参数重置
#
#   利用该脚本重置指定转义符的指定变量（用预设值覆盖）
#
#        $game_message.reset_params(param_sym, code_string)
#
# · param_sym 解析： 【Symbol】型常量
#   【注意】若传入的 param_sym 为 nil，则将重置以下所有类型
#     :font → 重置关于字体的设置
#     :win  → 重置关于对话框的设置
#     :pop  → 重置关于pop类型对话框与pop的tag类型的设置
#     :face → 重置关于脸图显示的设置
#     :name → 重置关于姓名框的设置
#     :pause- 重置关于pause等待按键的精灵的设置
#     :chara → 重置关于文字特效的设置（其参数为文字特效转义符）
#     :ex → 重置扩展类转义符为预设的变量参数（其参数为扩展类转义符）
#
# · code_string 解析： 【String】型常量
#     可利用 | 将多个变量进行分割
#     若未传入该参数，则将重置全部变量
#
# · 示例：
#     $game_message.reset_params(:font, "i") → 重置字体是否斜体的参数
#     $game_message.reset_params(:win, "x|y") → 重置对话框的xy坐标（取默认va设置）
#     $game_message.reset_params(:pop) → 清除pop转义符的全部设置
#     $game_message.reset_params(:chara, "cin")
#       → cin转义符的参数重置为 CHARA_PARAMS_INIT 中的:cin键值，
#         若常量中无该键，则取消cin特效
#----------------------------------------------------------------------------
# - 参数保存与读取
#
#   利用该脚本保存当前全部 param_sym 参数组的状态值
#   （当不传入 sym 时默认取 :default 类别）
#   （由于涉及内部对话框临时参数的实现方式，请不要用 :temp 类别）
#
#         $game_message.save_params(sym)
#
#   利用该脚本使 param_sym 所对应的变量组恢复到上一次的保存状态
#   （当不传入 sym 时默认取 :default 类别）
#
#         $game_message.load_params(param_sym, sym)
#
#   param_sym 解析：【Symbol】型常量
#      具体见 参数重置 中的解析
#
# · 示例：
#     $game_message.save_params
#     $game_message.load_params(:font)
#       → 按 :default 存储的状态，来恢复字体的全部参数
#     $game_message.save_params("测试")
#     $game_message.load_params(:pause, "测试")
#       → 按 "测试" 存储的状态，来恢复pause精灵的全部参数
#----------------------------------------------------------------------------
# ● 特别感谢
#----------------------------------------------------------------------------
# - 葱兔（http://onira.lofter.com/）
#=============================================================================

#=============================================================================
# ○ 【设置部分】
#=============================================================================
module MESSAGE_EX
  #--------------------------------------------------------------------------
  # ● 【设置】定义控制类转义符各参数的预设值
  # （对于bool型变量，0与false等价，1与true等价）
  #--------------------------------------------------------------------------
  FONT_PARAMS_INIT = {
  # \font[]
    :size => Font.default_size, # 字体大小
    :i => Font.default_italic, # 斜体绘制
    :b => Font.default_bold, # 加粗绘制
    :s => Font.default_shadow, # 阴影
    :ca => 255, # 不透明度
    :o => Font.default_outline, # 描边
    :or => Font.default_out_color.red,
    :og => Font.default_out_color.green,
    :ob => Font.default_out_color.blue,
    :oa => Font.default_out_color.alpha,
    :p => 0, # 底纹
    :pc => 0, # 底纹颜色index
    :l => 0, # 外发光
    :lc => 0, # 外发光颜色index
    :lp => 2, # 外发光强度
    :d => 0, # 删除线
    :dc => 0, # 删除线颜色index
    :u => 0, # 下划线
    :uc => 0, # 下划线颜色index
  }
  WIN_PARAMS_INIT = {
  # \win[]
    # 窗口属性相关
    :z => 200,
    :skin => 0, # 对话框所用windowskin的类型
    :bg => nil, # 对话框背景所用图片（覆盖窗口皮肤）
    :bgo => 7,  # 对话框背景图片与对话框的对齐原点
    # 窗口位置相关
    :o => 7, # 原点位置类型 默认为7左上角
    :x => nil, # 原点坐标xy
    :y => nil,
    :do => 0, # 相较于屏幕的九宫格位置（覆盖x/y的设置）
    :dx => 0, # 坐标偏移值xy
    :dy => 0,
    :fix => 1, # 是否进行位置修正，防止对话框跑出屏幕
    # 窗口大小相关
    :w => 0,
    :h => 0,
    :dw => 0, # 若为1，则代表宽度会依据文字动态调整
    :fw => 0, # 若为1，则窗口打开时即为文字绘制完成时所需宽度值
    :wmin => 0, # 设置宽度的上下限（当dw==1时生效）
    :wmax => 0, # （有脸图时宽度会自动增加脸图宽度）
    :dh => 0, # 若为1，则代表高度会依据文字动态调整
    :fh => 0, # 若为1，则窗口打开时即为文字绘制完成时所需高度值
    :hmin => 0, # 设置高度的上下限（当dh==1时生效）
    :hmax => 0,
    # 文本显示相关
    :se => 0, # 打字音类型（默认0，无声效）
    :ali => 0, # 设置文本对齐方式
    :ck => 0, # 缩减的字符间距值
    :lh => Font.default_size, # 基础行高
    :ld => 4, # 增加的行间距值
    :cwi => 2, # 单个文字绘制后的等待帧数（最小值0）
    :cwo => 0, # 单个文字开始移出后的等待帧数（最小值0）
    :cor => 0, # 全部文字移出的顺序类型
    :cfast => 1, # 是否允许快进
    :cdx => 0, # 文本左侧与窗口padding的间距
    :cdy => 0, # 文本上边距
    :cdw => 0, # 文本右边距
  }
  POP_PARAMS_INIT = {
  # \pop[]
    :skin => nil, # pop模式下所用skin类型
    :do => 8, # 对话框相对于绑定对象的位置（九宫格小键盘）
    :d => 0, # 指定原点距离事件格子中心的偏移量
    :dx => 0,  # 指定x、y方向上的偏移量
    :dy => 0,
    :fix => 0, # 是否进行位置修正
    :w => 0, # 指定固定的宽度和高度（优先级高于win_params）
    :h => 0,
    :dw => 0, # 若为1，则代表宽度会依据文字动态调整
    :fw => 1, # 若为1，则窗口打开时将预绘制成文字区域最终大小
    :dh => 0, # 若为1，则代表高度会依据文字动态调整
    :fh => 1, # 若为1，则窗口打开时将预绘制成文字区域最终大小
  # \popt[]
    :tag => 1, # tag所用文件名index（0时表示不启用）
    :td => 3, # 与绑定事件格子中心位置的偏移值
  }
  FACE_PARAMS_INIT = {
  # \face[]
    :lt => 30, # 循环时，每两帧之间的间隔
    :lw => 60, # 循环后，等待帧数
  # \facep[]
    :dir => 0, # 脸图显示方向 1为右侧
    :m => 0, # 脸图镜像显示
    :it => 10, # 脸图移入所需帧数
    :iv => 1, # 脸图移入每帧x增量
    :io => 26, # 脸图移入每帧不透明度增量
    :ot => 10, # 脸图移出所需帧数
    :ov => 1, # 脸图移出每帧x增量
    :oo => 26, # 脸图移出每帧不透明度减量
    :dx => 0, # 脸图x方向的偏移增量
    :dy => 0, # 脸图y方向的偏移增量
    :dw => 8, # 脸图显示宽度的补足量
    :z => 1, # 脸图z值增量
  }
  NAME_PARAMS_INIT = {
  # \name[]
    :o => 1, # 自身的显示原点位置
    :do => 7, # 相较于对话框的显示原点位置
    :dx => 0, # 位置的偏移增量
    :dy => 0,
    :opa => 255, # 背景不透明度
    :skin => nil, # 皮肤类型
  }
  PAUSE_PARAMS_INIT = {
  # \pause[]
    :pause => 0,  # 源位图index
    :o => 4,  # 自身的显示原点类型
    :do => 0,  # 相对于对话框的显示位置（九宫格小键盘）（0时为在文末）
    :dx => 0,  # xy偏移值
    :dy => 0,
    :t => 7, # 每两帧之间的等待帧数
    :v => 1,  # 是否显示
  }
  #--------------------------------------------------------------------------
  # ● 【设置】定义初始激活的文字特效类转义符的变量参数字符串
  #--------------------------------------------------------------------------
  CHARA_PARAMS_INIT = {
  # 文字特效类转义符sym => 变量参数字符串"code_string"
    #:cin => "1",
  }
  #--------------------------------------------------------------------------
  # ● 【设置】定义文字特效类转义符各参数的初始值
  #--------------------------------------------------------------------------
  CIN_PARAMS_INIT = {
  # \cin[]
    :r => 0, # 随机取值？
    :t => 15, # 移入所用帧数
    :vx => 0,  # 每vxt帧x的增量
    :vxt => 1,
    :vy => 0,  # 每vyt帧y的增量
    :vyt => 1,
    :vz => 0,  # 每vzt帧zoom的增量
    :vzt => 1,
    :va => 0,  # 每帧角度增量
    :rxt => 1, # 每rxt帧src_rect.x的增量
    :rx => 0,
    :ryt => 1, # 每ryt帧src_rect.y的增值
    :ry => 0,
  }
  COUT_PARAMS_INIT = {
  # \cout[]
    :r => 0, # 随机取值？
    :t => 15, # 移出所用帧数
    :vx => 0,  # 每vxt帧x的增量
    :vxt => 1,
    :vy => 0,  # 每vyt帧y的增量
    :vyt => 1,
    :vz => 0,  # 每vzt帧zoom的增量
    :vzt => 1,
    :va => 0,  # 每帧角度增量
    :rxt => 1, # 每rxt帧src_rect.x的增量
    :rx => 0,
    :ryt => 1, # 每ryt帧src_rect.y的增值
    :ry => 0,
  }
  UOUT_PARAMS_INIT = {
  # \uout[]
    :n => 300, # 消散的粒子总数
    :d =>  2, # 消散的粒子的大小（直径/边长）
    :o =>  1, # 透明度变更量的最小值
    :dir => 4, # 消散方向类型
    :s =>  0, # 粒子的形状类型
  }
  CSIN_PARAMS_INIT = {
    :a => 6, # 幅度
    :l => 10, # 频度
    :s => 30, # 速度
    :p => 0, # 相位
  }
  CWAVE_PARAMS_INIT = {
  # \cwave[]
    :h  => 2,  # Y方向上的最大偏移值
    :t  => 4,  # 移动一像素所耗帧数
    :vy => -1, # 起始速度的Y方向分量（正数向下）
  }
  CSWING_PARAMS_INIT = {
  # \cswing[]
    :d => 0, # 每次更新增加的角度值（0时随机取正负1）
    :t => 1, # 每次角度更新后等待t帧
    :a => 15, # 角度可到达的最大值（左右对称）
    :o => 2, # 摇摆不动点所在位置类型（键盘九宫格）（2为底部中心）
  }
  CZOOM_PARAMS_INIT = {
  # \czoom[]
    :t => 0, # 在进行一次缩放变更后的等待帧数
    :dx => 2, # x方向的每次缩放增量（缩放总量在-100~100之间，整数）
    :dy => 0, # y方向的每次缩放增量
    :o => 5, # 缩放不动点所在位置类型（键盘九宫格）（5为中心）
    :min => 0, # xy缩放总量的最小值
    :max => 100, # xy缩放总量的最大值
  }
  CSHAKE_PARAMS_INIT = {
  # \cshake[]
    :l => 3,  # 距离所在原点的最大偏移量（左右上下）
    :r => 3,
    :u => 3,
    :d => 3,
    :vx  => 0,  # x的初始移动方向（0为随机方向）
    :vxt => 3,  # x方向移动一像素所耗帧数
    :vy  => 0,  # y的初始移动方向（0为随机方向）
    :vyt => 3,  # y方向移动一像素所耗帧数
  }
  CFLASH_PARAMS_INIT = {
  # \cflash[]
    :r => 255, # 闪烁颜色RGBA
    :g => 255,
    :b => 255,
    :a => 255,
    :d => 60,  # 闪烁帧数
    :t => 60,  # 闪烁后的等待时间
  }
  CMIRROR_PARAMS_INIT = {}
  CU_PARAMS_INIT = {
  # \cu[]
    :t => 10, # 每两次消散之间的时间间隔
    :n => 20, # 消散的粒子总数
    :d =>  2, # 消散的粒子的大小（直径/边长）
    :o =>  1, # 透明度变更量的最小值
    :dir => 4, # 消散方向类型
    :s =>  0, # 粒子的形状类型
  }
  CU_PARAM_DIR = { # 定义消散方向类型的id
    1 => :LD, 3 => :RD, 4 => :LR, 5 => :LRUD, 6 => :LR, 7 => :LU, 9 => :RU
  }
  CU_PARAM_S = { # 定义粒子形状类型的id
    0 => :S, # 正方形
    1 => :C, # 圆形（耗时）
    2 => :T  # 三角形
  }
  CTOG_PARAMS_INIT = {
  # \ctog[]
    :i => 0,  # 选取i号文字组
    :n => 4,  # 从文字组中选取n个字符
    :t => 10, # 文字切换的等待帧数
    :r => 0,  # 是否随机选择下一个文字？
  }
  CTOG_CHARAS = { # 定义文字切换特效的文字组
    0 => ['▀', '▄', '█', '▌', '✖'],
  }
  #--------------------------------------------------------------------------
  # ● 【设置】定义初始激活的扩展类转义符的预设变量参数字符串
  #--------------------------------------------------------------------------
  EX_PARAMS_INIT = {
  # 渐变绘制转义符 \cg => "颜色索引字符串",
    :cg => "",
  }
  #--------------------------------------------------------------------------
  # ● 【设置】定义新游戏开始时对话框预定的转义字符串
  # （由于解析问题，字符串中请将 "\" 替换成 "\\"）
  #--------------------------------------------------------------------------
  ESCAPE_STRING_INIT = ""
  #--------------------------------------------------------------------------
  # ● 【设置】定义\conv[string]转义符与替换后的字符串
  # （由于解析问题，字符串中请将 "\" 替换成 "\\"）
  # （在添加了预定转义符字符串于文本开头后，将对全部文本检查替换）
  # （如果目标转义符是用 <> 代替 []，如姓名框中的内容，则将 "\" 替换成 "\e"）
  #--------------------------------------------------------------------------
  CONVERT_ESCAPE = {
  # String => String,
    "系统" => "\\win[ali1dw1dh1o5do-5dx0dy0]\\pause[do2o5]",
    "底部" => "\\win[ali0dw1dh1o2do-2dx0dy-60]\\pause[do0o4]",
    "顶部" => "\\win[ali0dw1dh1o8do-8dx0dy60]\\pause[do0o4]",
  }
  #--------------------------------------------------------------------------
  # ● 【设置】定义在所有姓名框的名字字符串的最前面增加的转义字符串
  # （具体见draw_text_ex所支持的转义符）
  # （由于解析问题，字符串中请将 "\" 替换成 "\e" ，并用 <> 代替 []）
  #--------------------------------------------------------------------------
  ESCAPE_STRING_NAME_PREFIX = "\ec<9>"
  #--------------------------------------------------------------------------
  # ● 【设置】定义 index → 窗口皮肤文件名 的映射
  # （其中 index 必须为整数）
  # （图片存储于 Graphics/System 目录下）
  #--------------------------------------------------------------------------
  INDEX_TO_WINDOWSKIN = {
    0 => "Window", # 默认所用皮肤名称
  }
  #--------------------------------------------------------------------------
  # ● 【设置】定义 index → 窗口背景图片名 的映射
  # （图片的左上角会与对话框的左上角对齐）
  # （其中 index 必须为整数）
  # （图片存储于 Graphics/System 目录下）
  #--------------------------------------------------------------------------
  INDEX_TO_WINDOW_BG = {
  }
  #--------------------------------------------------------------------------
  # ● 【设置】定义 index → 打字音效 的映射
  # （音效存储于 Audio/SE 目录下）
  #--------------------------------------------------------------------------
  INDEX_TO_SE = {
  #index => SE文件名, 音量, 音调
    0 => ["", 80, 100], # 默认设置，不推荐修改
    1 => ["Cursor1", 40, 150],
  }
  #--------------------------------------------------------------------------
  # ● 【设置】定义 index → 指向性箭头文件名 的映射
  # （其中 index 为正整数；为 0 时代表不启用tag）
  # （图片存储于 Graphics/System 目录下）
  # 【Tag图片解析】任意大小，3帧×3帧规格
  #    7 8 9
  #    4 5 6  ← pop对话框的原点位置类型 与 对应所用的tag位图区域
  #    1 2 3
  # （比如 pop对话框的原点类型为 2 时，tag显示在对话框底部中央，图像使用2号区域）
  # 【注意】tag的存在不会使pop对话框产生额外偏移，请利用pop参数d/dx/dy自行移动
  #--------------------------------------------------------------------------
  INDEX_TO_WINDOWTAG = {
    1 => "Window_Tag", # 默认所用tag名称
  }
  #--------------------------------------------------------------------------
  # ● 【设置】定义 窗口皮肤index → Tag图片index 的映射
  #  当使用窗口皮肤时，将必定使用此处设置的Tag图片
  #--------------------------------------------------------------------------
  WINDOWSKIN_TO_WINDOWTAG = {
    -1 => 1,
  }
  #--------------------------------------------------------------------------
  # ● 【设置】定义 index → 等待按键帧动画参数组 的映射
  # （其中 index 必须为整数）
  # （图片存储于 Graphics/System 目录下）
  # 【注意】帧动画统一从左上开始计为0号位置，并按行优先从左往右遍历
  #--------------------------------------------------------------------------
  INDEX_TO_PAUSE = {
  #         文件名 范围（nil则为整张图） 一行中的帧数 一列中的帧数
  #index=>[String, Rect, Integer, Integer]
   -1 => ["", nil, 1, 1], # 不显示
    0 => ["Window", Rect.new(96,64,32,32), 2, 2], # 默认 使用皮肤窗口里的箭头
  }
  #--------------------------------------------------------------------------
  # ● 【设置】是否屏蔽默认的输入等待的箭头显示
  # （位于底部中央的4帧动画）
  #--------------------------------------------------------------------------
  NO_DEFAULT_PAUSE = true
  #--------------------------------------------------------------------------
  # ● 【设置】跳过对话判定成功？
  #  返回值等于 true 时，会进行跳过当前对话框的处理（中断绘制并强行关闭）
  # （请注意，该跳过会直接忽略掉还未被绘制的转义符，可能存在奇怪问题）
  #--------------------------------------------------------------------------
  def self.skip?
    false #Input.trigger?(:CTRL)
  end
end

#=============================================================================
# ○ 读取设置
#=============================================================================
module MESSAGE_EX
  #--------------------------------------------------------------------------
  # ● 获取指定转义符的基础设置
  #--------------------------------------------------------------------------
  def self.get_default_params(param_sym)
    MESSAGE_EX.const_get("#{param_sym.to_s.upcase}_PARAMS_INIT".to_sym) rescue {}
  end
  #--------------------------------------------------------------------------
  # ● 读取文字切换特效的文字组
  #--------------------------------------------------------------------------
  def self.get_tog_charas(index, num)
    array = CTOG_CHARAS[index]
    return [] if array.nil?
    return array.sample(num)
  end
  #--------------------------------------------------------------------------
  # ● 获取\conv[string]的替换字符串
  #--------------------------------------------------------------------------
  def self.get_conv(s)
    CONVERT_ESCAPE[s] || ""
  end
  #--------------------------------------------------------------------------
  # ● 获取姓名框绘制内容的前缀
  #--------------------------------------------------------------------------
  def self.get_name_prefix
    ESCAPE_STRING_NAME_PREFIX
  end
  #--------------------------------------------------------------------------
  # ● 读取对应的 windowskin 位图
  #--------------------------------------------------------------------------
  def self.windowskin(index)
    begin
      return Cache.system(INDEX_TO_WINDOWSKIN[index])
    rescue
      return Cache.system(INDEX_TO_WINDOWSKIN[0])
    end
  end
  #--------------------------------------------------------------------------
  # ● 读取对应的 window bg 位图
  #--------------------------------------------------------------------------
  def self.windowbg(index)
    begin
      return Cache.system(INDEX_TO_WINDOW_BG[index])
    rescue
      return nil
    end
  end
  #--------------------------------------------------------------------------
  # ● 播放对应的SE
  #--------------------------------------------------------------------------
  def self.se(index)
    params = INDEX_TO_SE[index] || INDEX_TO_SE[0]
    return if params[0] == ""
    volume = params[1] || INDEX_TO_SE[0][1]
    pitch = params[2] || INDEX_TO_SE[0][2]
    Audio.se_play("Audio/SE/" + params[0], volume, pitch)
  end
  #--------------------------------------------------------------------------
  # ● 读取对应的 tag 位图
  #--------------------------------------------------------------------------
  def self.windowtag(index)
    begin
      return Cache.system(INDEX_TO_WINDOWTAG[index])
    rescue
      return Cache.empty_bitmap
    end
  end
  #--------------------------------------------------------------------------
  # ● 重绘tag，并定位
  #--------------------------------------------------------------------------
  def self.windowtag_o(window, sprite, tag_bitmap, o, redraw = true)
    if redraw
      sprite.bitmap.clear
      w = sprite.width; h = sprite.height # 单个tag的宽度和高度
      rect = Rect.new( w*(2-(9-o)%3), h*((9-o)/3), w, h)
      sprite.bitmap.blt(0, 0, tag_bitmap, rect)
    end
    self.reset_xy_dorigin(sprite, window, o)
    self.reset_xy_origin(sprite, 10 - o)
  end
  #--------------------------------------------------------------------------
  # ● 读取 pause 按键等待精灵的信息组
  #--------------------------------------------------------------------------
  def self.pause_params(index)
    INDEX_TO_PAUSE[index] || INDEX_TO_PAUSE[0]
  end
#==============================================================================
# ○ 共享方法
#==============================================================================
  #--------------------------------------------------------------------------
  # ● 获取指定对象的信息文本
  #--------------------------------------------------------------------------
  def self.get_data_info(type, id)
    case type
    when 's'; obj = $data_skills[id]
    when 'i'; obj = $data_items[id]
    when 'w'; obj = $data_weapons[id]
    when 'a'; obj = $data_armors[id]
    end
    return "\ei[#{obj.icon_index}]#{obj.name}" if obj
    return ""
  end
  #--------------------------------------------------------------------------
  # ● 解析字符串参数
  #--------------------------------------------------------------------------
  def self.parse_param(param_hash, param_text, default_type = "default")
    param_text = param_text.downcase
    # 只有首位是省略名字的参数设置
    t = param_text.slice!(/^\-?\d+/)
    param_hash[default_type.to_sym] = t.to_i if t && t != ""
    while(param_text != "")
      t = param_text.slice!(/^[a-z]+/)
      if param_text[0] == "$"
        param_text[0] = ''
        next param_hash[t.to_sym] = nil
      end
      param_hash[t.to_sym] = (param_text.slice!(/^\-?\d+/)).to_i
    end
  end
  #--------------------------------------------------------------------------
  # ● 将指定值变更为布尔量
  #--------------------------------------------------------------------------
  def self.check_bool(v)
    return true if v == true
    return false if v.nil? || v == false || v == 0
    return true
  end
  #--------------------------------------------------------------------------
  # ● 应用font参数到font对象上
  #--------------------------------------------------------------------------
  def self.apply_font_params(font, params)
    font.size = params[:size]
    font.italic = MESSAGE_EX.check_bool(params[:i])
    font.bold = MESSAGE_EX.check_bool(params[:b])
    font.shadow = MESSAGE_EX.check_bool(params[:s])
    font.color.alpha = params[:ca]
    font.outline = MESSAGE_EX.check_bool(params[:o])
    font.out_color.set(params[:or],params[:og],params[:ob],params[:oa])
    params[:l] = MESSAGE_EX.check_bool(params[:l])
    params[:lc] ||= 0
    params[:lp] ||= 2
    params[:d] = MESSAGE_EX.check_bool(params[:d])
    params[:dc] ||= 0
    params[:u] = MESSAGE_EX.check_bool(params[:u])
    params[:uc] ||= 0
  end
  #--------------------------------------------------------------------------
  # ● 重置指定精灵的显示原点
  #--------------------------------------------------------------------------
  def self.reset_sprite_oxy(obj, o)
    case o # 固定不动点的位置类型 以九宫格小键盘察看
    when 1
      obj.ox = 0
      obj.oy = obj.height
    when 2
      obj.ox = obj.width / 2
      obj.oy = obj.height
    when 3
      obj.ox = obj.width
      obj.oy = obj.height
    when 4
      obj.ox = 0
      obj.oy = obj.height / 2
    when 5
      obj.ox = obj.width / 2
      obj.oy = obj.height / 2
    when 6
      obj.ox = obj.width
      obj.oy = obj.height / 2
    when 7 # 【默认】显示原点为左上角
      obj.ox = 0
      obj.oy = 0
    when 8
      obj.ox = obj.width / 2
      obj.oy = 0
    when 9
      obj.ox = obj.width
      obj.oy = 0
    end
  end
  #--------------------------------------------------------------------------
  # ● 重置指定对象的显示原点位置
  #--------------------------------------------------------------------------
  def self.reset_xy_origin(obj, o)
    case o  # 固定不动点的位置类型 以九宫格小键盘察看
    when 1
      obj.y = obj.y - obj.height
    when 2
      obj.x = obj.x - obj.width / 2
      obj.y = obj.y - obj.height
    when 3
      obj.x = obj.x - obj.width
      obj.y = obj.y - obj.height
    when 4
      obj.y = obj.y - obj.height / 2
    when 5
      obj.x = obj.x - obj.width / 2
      obj.y = obj.y - obj.height / 2
    when 6
      obj.x = obj.x - obj.width
      obj.y = obj.y - obj.height / 2
    when 7; return # 【默认】显示原点为左上角
    when 8
      obj.x = obj.x - obj.width / 2
    when 9
      obj.x = obj.x - obj.width
    end
  end
  #--------------------------------------------------------------------------
  # ● 重置指定对象依据另一对象小键盘位置的新位置
  #--------------------------------------------------------------------------
  def self.reset_xy_dorigin(obj, obj2, o) # 左上角和左上角对齐
    if o < 0 # o小于0时，将obj2重置为全屏
      obj2 = Rect.new(0,0,Graphics.width,Graphics.height)
      o = o.abs
    end
    case o
    when 1,4,7; obj.x = obj2.x
    when 2,5,8; obj.x = obj2.x + obj2.width / 2
    when 3,6,9; obj.x = obj2.x + obj2.width
    end
    case o
    when 1,2,3; obj.y = obj2.y + obj2.height
    when 4,5,6; obj.y = obj2.y + obj2.height / 2
    when 7,8,9; obj.y = obj2.y
    end
  end
  #--------------------------------------------------------------------------
  # ● 基于指定位图，计算文本块所占宽高
  # （只进行 \\ 到 \e 的文本替换、忽略除\i以外的全部转义符、未考虑字号变化）
  #  k → 字符间距  ld → 行间距
  #--------------------------------------------------------------------------
  def self.calculate_text_wh(bitmap, text, k = 0, ld = 0)
    text_clone, array_width, array_height = text.dup, [], []
    # 转义符替换
    text_clone.gsub!(/\\/)      { "\e" }
    text_clone.gsub!(/\e\e/)    { "\\" }
    text_clone.gsub!(/\e[\.\|\^\!\$<>\{|\}]/i) { "" }
    text_clone.gsub!(/\e\w+\[(\d|\w)+\]/i) { "" } # 清除掉全部的\w[wd]格式转义符
    # 每一行计算宽度高度
    text_clone.each_line do |line|
      icon_count = 0; line.gsub!(/\ei\[\d+\]/i){ icon_count += 1; "" }
      r = bitmap.text_size(line)
      w = r.width + icon_count * 24 + (line.length - 1 + icon_count) * k
      array_width.push(w)
      h = icon_count > 0 ? [r.height, 24].max : r.height
      array_height.push(h)
    end
    return [array_width.max, array_height.inject{|sum, v| sum = sum + v + ld}]
  end
end # end of MESSAGE_EX

#==============================================================================
# ○ 定义能够响应的文字特效
#==============================================================================
module MESSAGE_EX::CHARA_EFFECTS
  #--------------------------------------------------------------------------
  # ● 移入移出特效预定
  #--------------------------------------------------------------------------
  def eagle_chara_effect_cin(param = '')
  end
  def eagle_chara_effect_cout(param = '')
  end
  #--------------------------------------------------------------------------
  # ● 正弦扭曲特效预定
  #--------------------------------------------------------------------------
  def eagle_chara_effect_csin(param = '')
  end
  #--------------------------------------------------------------------------
  # ● 波浪特效预定
  #--------------------------------------------------------------------------
  def eagle_chara_effect_cwave(param = '')
  end
  #--------------------------------------------------------------------------
  # ● 摇摆特效预定
  #--------------------------------------------------------------------------
  def eagle_chara_effect_cswing(param = '')
  end
  #--------------------------------------------------------------------------
  # ● 缩放特效预定
  #--------------------------------------------------------------------------
  def eagle_chara_effect_czoom(param = '')
  end
  #--------------------------------------------------------------------------
  # ● 抖动特效预定
  #--------------------------------------------------------------------------
  def eagle_chara_effect_cshake(param = '')
  end
  #--------------------------------------------------------------------------
  # ● 闪烁特效预定
  #--------------------------------------------------------------------------
  def eagle_chara_effect_cflash(param = '')
  end
  #--------------------------------------------------------------------------
  # ● 镜像特效预定
  #--------------------------------------------------------------------------
  def eagle_chara_effect_cmirror(param = '')
  end
  #--------------------------------------------------------------------------
  # ● 消散
  #--------------------------------------------------------------------------
  if defined?(Unravel_Bitmap)
  def eagle_chara_effect_uout(param = '')
  end
  def eagle_chara_effect_cu(param = '')
  end
  end
  #--------------------------------------------------------------------------
  # ● 文字切换特效预定
  #--------------------------------------------------------------------------
  def eagle_chara_effect_ctog(param = '')
  end
end

#=============================================================================
# ○ DataManager
#=============================================================================
class << DataManager
  #--------------------------------------------------------------------------
  # ● 设置新游戏
  #--------------------------------------------------------------------------
  alias eagle_message_ex_setup_new_game setup_new_game
  def setup_new_game
    eagle_message_ex_setup_new_game
    $game_message.add_escape(MESSAGE_EX::ESCAPE_STRING_INIT)
  end
end
#=============================================================================
# ○ Scene_Map
#=============================================================================
class Spriteset_Map; attr_reader :character_sprites; end
class Scene_Map; attr_reader :spriteset, :message_window; end
#=============================================================================
# ○ Scene_Battle
#=============================================================================
class Scene_Battle; attr_reader :spriteset; end
#=============================================================================
# ○ Game_System
#=============================================================================
class Game_System
  #--------------------------------------------------------------------------
  # ● 读档后的处理
  #--------------------------------------------------------------------------
  alias eagle_message_ex_on_after_load on_after_load
  def on_after_load
    eagle_message_ex_on_after_load
    $game_message.check_params # 确保新增AddOn时，参数hash存在
  end
end

#=============================================================================
# ○ Game_Message
#=============================================================================
class Game_Message
  attr_reader   :params_need_apply # 存储需要被预定应用的符号（调用对应处理方法）
  attr_accessor :chara_params # 存储文字特效预设 code_symbol => param_string
  attr_accessor :font_params, :win_params, :pop_params
  attr_accessor :face_params, :name_params, :pause_params
  attr_accessor :ex_params # 存储扩展params
  attr_accessor :escape_strings # 存储预定要添加的字符串
  attr_accessor :auto_r, :auto_t
  attr_accessor :hold, :instant, :draw, :para, :event_id
  attr_accessor :child_window_w_des, :child_window_h_des
  attr_accessor :default_open_type, :auto_wrap, :need_open, :no_close
  #--------------------------------------------------------------------------
  # ● 初始化对象
  #--------------------------------------------------------------------------
  alias eagle_message_ex_init initialize
  def initialize
    eagle_message_ex_init
    @temp_game_messages = {} # sym => game_message
    set_default_params
    @auto_r = true # 是否重置 @auto_t
    @auto_t = nil # 自动对话的倒计时（nil时为不自动继续）
    @default_open_type = false # 使用默认的窗口打开方式？
  end
  #--------------------------------------------------------------------------
  # ● 获取全部可保存params的符号的数组
  #--------------------------------------------------------------------------
  def eagle_params
    [:chara, :font, :win, :pop, :face, :name, :pause, :ex]
  end
  #--------------------------------------------------------------------------
  # ● 获取params的初始值
  #--------------------------------------------------------------------------
  def set_default_params
    eagle_params.each do |sym|
      self.send("#{sym}_params=".to_sym, MESSAGE_EX.get_default_params(sym).dup)
    end
    @params_need_apply = eagle_params.dup # 添加修改预定，用于应用初始值
    @escape_strings = [] # 存储等待执行的转义符字符串
  end
  #--------------------------------------------------------------------------
  # ● 检查params是否都存在
  #--------------------------------------------------------------------------
  def check_params
    eagle_params.each do |sym|
      params = self.send("#{sym}_params".to_sym)
      def_params = MESSAGE_EX.get_default_params(sym).dup
      if params == nil
        self.send("#{sym}_params=".to_sym, def_params)
        add_apply(sym)
      else
        params = def_params.merge(params)
        self.send("#{sym}_params=".to_sym, params)
      end
    end
  end
  #--------------------------------------------------------------------------
  # ● 清除（每次对话框开启时被调用）
  #--------------------------------------------------------------------------
  alias eagle_message_ex_clear clear
  def clear
    eagle_message_ex_clear
    @draw = true # 开启绘制？
    @hold = false # 当前对话框要保留显示？
    @instant = false # 当前对话框立即显示？
    @para = false # 并行显示选择框？
    @event_id = 0 # 存储当前执行的Game_Interpreter的事件ID
    @child_window_w_des = 0 # 因子窗口嵌入而额外增加的宽高
    @child_window_h_des = 0
    @need_open = true # 当为 true 时，需要执行open_and_wait
    @auto_wrap ||= true # 开启自动换行？
    @no_close ||= true # 当为 true 时，开启对话框跨指令显示
  end
  #--------------------------------------------------------------------------
  # ● 判定是否需要进入等待按键状态
  #--------------------------------------------------------------------------
  def input_pause?
    !(choice? || num_input? || item_choice?)
  end
  #--------------------------------------------------------------------------
  # ● 使用pop类型？
  #--------------------------------------------------------------------------
  def pop?
    @pop_params[:id] != nil
  end
  #--------------------------------------------------------------------------
  # ● 使用脸图？
  #--------------------------------------------------------------------------
  def face?
    @face_params[:name] != ""
  end
  #--------------------------------------------------------------------------
  # ● 使用姓名框？
  #--------------------------------------------------------------------------
  def name?
    @name_params[:name] != ""
  end
  #--------------------------------------------------------------------------
  # ● 添加修改预定
  #--------------------------------------------------------------------------
  def add_apply(param_sym)
    return if @params_need_apply.include?(param_sym)
    @params_need_apply.push(param_sym)
  end
  #--------------------------------------------------------------------------
  # ● 清空预定修改
  #--------------------------------------------------------------------------
  def clear_applys
    @params_need_apply.clear
  end
  #--------------------------------------------------------------------------
  # ● 重置指定参数
  #--------------------------------------------------------------------------
  def reset_params(param_sym, code_string = nil)
    return eagle_params.each{|sym| reset_params(sym)} if param_sym.nil?
    return reset_params_c(code_string) if param_sym == :chara
    return reset_params_ex(code_string) if param_sym == :ex
    default_params = MESSAGE_EX.get_default_params(param_sym)
    if code_string.nil? # 直接清除全部参数
      new_params = default_params.dup
    else
      new_params = method( param_sym.to_s + "_params" ).call.dup # 获取旧的hash
      code_string.split("|").each { |c|
        new_params[c.to_sym] = default_params[c.to_sym]
      }
    end
    self.send((param_sym.to_s+"_params=").to_sym, new_params)
    add_apply(param_sym) # 添加修改预定，用于应用结果
  end
  #--------------------------------------------------------------------------
  # ● 重置指定文字特效
  #--------------------------------------------------------------------------
  def reset_params_c(code_string = nil)
    default_params = MESSAGE_EX.get_default_params(:chara)
    return @chara_params = default_params if code_string.nil?
    code_string.split("|").each { |c|
      if default_params[c.to_sym]
        @chara_params[c.to_sym] = default_params[c.to_sym]
      else
        @chara_params.delete(c.to_sym)
      end
    }
  end
  #--------------------------------------------------------------------------
  # ● 重置扩展转义符
  #--------------------------------------------------------------------------
  def reset_params_ex(code_string = nil)
    default_params = MESSAGE_EX.get_default_params(:ex)
    return @ex_params = default_params if code_string.nil?
    code_string.split("|").each { |c|
      if default_params[c.to_sym]
        @ex_params[c.to_sym] = default_params[c.to_sym]
      else
        @ex_params.delete(c.to_sym)
      end
    }
  end
  #--------------------------------------------------------------------------
  # ● 保存当前状态
  #--------------------------------------------------------------------------
  def save_params(sym = :default)
    @temp_game_messages[sym] = clone
  end
  #--------------------------------------------------------------------------
  # ● 读取保存状态
  #--------------------------------------------------------------------------
  def load_params(param_sym, sym = :default)
    return false if @temp_game_messages[sym].nil?
    return eagle_params.each{|psym| load_params(psym, sym)} if param_sym.nil?
    m = param_sym.to_s + "_params"
    self.send( (m+"=").to_sym, @temp_game_messages[sym].send(m.to_sym).clone )
    add_apply(param_sym) # 添加修改预定
    return true
  end
  #--------------------------------------------------------------------------
  # ● 参数拷贝
  #--------------------------------------------------------------------------
  def clone
    t = Game_Message.new
    t.visible = true
    eagle_params.each do |sym|
      m = "#{sym}_params"
      t.send("#{m}=".to_sym, method(m.to_sym).call.clone)
    end
    t
  end
  #--------------------------------------------------------------------------
  # ● 下一次对话时要解析的转义符
  # 【由于解析问题，字符串中请将 "\" 替换成 "\e" 】
  #--------------------------------------------------------------------------
  def add_escape(string)
    @escape_strings.push(string)
  end
end

#=============================================================================
# ○ Game_Interpreter
#=============================================================================
class Game_Interpreter
  #--------------------------------------------------------------------------
  # ● 显示文字
  #--------------------------------------------------------------------------
  alias eagle_message_ex_command_101 command_101
  def command_101
    $game_message.event_id = @event_id
    eagle_message_ex_command_101
  end
end

#=============================================================================
# ○ Window_Message
#=============================================================================
class Window_Message
  include MESSAGE_EX::CHARA_EFFECTS
  attr_reader :eagle_charas_w, :eagle_charas_h, :eagle_chara_viewport
  #--------------------------------------------------------------------------
  # ● 获取主参数
  #--------------------------------------------------------------------------
  def game_message
    $game_message
  end
  #--------------------------------------------------------------------------
  # ● 重置指定对象的显示原点位置
  #--------------------------------------------------------------------------
  def eagle_reset_xy_origin(obj, o)
    MESSAGE_EX.reset_xy_origin(obj, o)
  end
  #--------------------------------------------------------------------------
  # ● 重置指定对象依据另一对象小键盘位置的新位置
  #--------------------------------------------------------------------------
  def eagle_reset_xy_dorigin(obj, obj2, o)
    MESSAGE_EX.reset_xy_dorigin(obj, obj2, o)
  end

  #--------------------------------------------------------------------------
  # ● 初始化对象
  #--------------------------------------------------------------------------
  alias eagle_message_ex_init initialize
  def initialize
    eagle_message_ex_init
    eagle_message_init_assets
    eagle_message_init_params
    eagle_message_reset
    eagle_set_wh(1, 1, true, true)
  end
  #--------------------------------------------------------------------------
  # ● 初始化组件
  #--------------------------------------------------------------------------
  def eagle_message_init_assets
    @eagle_chara_viewport = Viewport.new # 文字精灵的显示区域
    @eagle_chara_sprites = [] # 存储全部的文字精灵
    @eagle_sprite_pop_tag = Sprite.new # 初始化pop状态下的tag精灵
    eagle_reset_pop_tag_bitmap # 初始化tag的位图
    @eagle_sprite_face = Sprite.new # 初始化脸图精灵
    @eagle_window_name = Window_EagleMsgName.new(self) # 初始化姓名框窗口
    @eagle_sprite_pause = Sprite_EaglePauseTag.new(self) # 初始化等待按键的精灵
    @eagle_dup_windows ||= [] # 存储全部拷贝的窗口
  end
  #--------------------------------------------------------------------------
  # ● 初始化参数（只需要最初执行一次）
  #--------------------------------------------------------------------------
  def eagle_message_init_params
    @in_map = SceneManager.scene_is?(Scene_Map) # 地图场景中？
    @in_battle = SceneManager.scene_is?(Scene_Battle) # 战斗场景中？
    self.arrows_visible = false # 内容位图未完全显示时出现的箭头
    @flag_open_close = false # 当正在进行打开/关闭时，置为 true
    @flag_pop_chara = true # pop绑定的对象为地图场景上的行走图？
    @flag_temp_params = false # 当前对话框的转义符不会保存到game_message中？
  end
  #--------------------------------------------------------------------------
  # ● 拷贝自身
  #--------------------------------------------------------------------------
  def clone
    t = Window_Message_Clone.new(game_message.clone)
    t.game_message.win_params[:z] = 0
    t.x = self.x; t.y = self.y; t.width = self.width; t.height = self.height
    t.z = self.z - 5
    t.windowskin = self.windowskin
    # 拷贝背景精灵
    t.back_bitmap.dispose
    t.back_bitmap = @back_bitmap
    t.back_sprite.bitmap = @back_bitmap
    t.eagle_recreate_back_bitmap
    @back_bitmap = nil
    # 拷贝视图
    t.eagle_chara_viewport.dispose
    t.eagle_chara_viewport = @eagle_chara_viewport
    # 拷贝文字组
    t.eagle_chara_sprites = @eagle_chara_sprites
    t.eagle_chara_sprites.each { |s| s.bind_window(t) }
    # 复制文本宽高
    t.eagle_set_chara_wh(@eagle_charas_w, @eagle_charas_h,
      @eagle_charas_w_final, @eagle_charas_h_final)
    # 拷贝pop的tag
    t.eagle_sprite_pop_tag.dispose
    t.eagle_sprite_pop_tag = @eagle_sprite_pop_tag
    # 拷贝脸图
    t.eagle_sprite_face.dispose
    t.eagle_sprite_face = @eagle_sprite_face
    # 拷贝姓名框
    t.eagle_window_name.dispose
    t.eagle_window_name = @eagle_window_name
    t.eagle_window_name.bind_window(t)
    # 拷贝pause精灵
    t.eagle_sprite_pause.dispose
    t.eagle_sprite_pause = @eagle_sprite_pause
    t.eagle_sprite_pause.bind_window(t)
    # 拷贝pop对象
    t.eagle_pop_obj = @eagle_pop_obj
    # 集体更新z值
    t.eagle_reset_z
    # 自身初始化组件与重置
    eagle_message_init_assets
    eagle_message_reset
    # 重置之前存储的窗口的z值（确保最近的显示在最上面）
    @eagle_dup_windows.each_with_index do |w, i|
      w.z = t.z - (i+1) * 5; w.eagle_reset_z
    end
    t
  end
  #--------------------------------------------------------------------------
  # ● 释放
  #--------------------------------------------------------------------------
  alias eagle_message_ex_dispose dispose
  def dispose
    eagle_message_ex_dispose
    @eagle_face_bitmap.dispose if @eagle_face_bitmap
    if !$RGD
      @eagle_sprite_face.bitmap.dispose if @eagle_sprite_face.bitmap
    end
    @eagle_sprite_face.dispose
    @eagle_window_name.dispose
    @eagle_sprite_pop_tag.bitmap.dispose if @eagle_sprite_pop_tag.bitmap
    @eagle_sprite_pop_tag.dispose
    @eagle_sprite_pause.dispose
    @eagle_dup_windows.each { |w| w.dispose if !w.disposed? }
    @eagle_chara_viewport.dispose
  end
  #--------------------------------------------------------------------------
  # ● （覆盖）释放背景位图
  #--------------------------------------------------------------------------
  def dispose_back_bitmap
    @back_bitmap.dispose if @back_bitmap
    @back_bitmap = nil
  end

  #--------------------------------------------------------------------------
  # ● 重置对话框（打开时）
  #--------------------------------------------------------------------------
  def eagle_message_reset
    # 移出全部组件
    eagle_move_out_assets
    # 重置下一个文字的绘制x（左对齐、不考虑换行）
    @eagle_next_chara_x = 0
    # 重置文字区域的宽度高度
    @eagle_charas_w = @eagle_charas_h = 0
    @eagle_charas_w_final = @eagle_charas_h_final = 0
    # 重置pop、face、name参数
    pop_params[:id] = nil
    face_params[:name] = ""
    name_params[:name] = ""
    # 重置pause精灵的文末位置
    @eagle_sprite_pause.bind_last_chara(nil)
    @eagle_sprite_pause_width_add = 0 # 因pause精灵而扩展的窗口宽度
    # 重置auto的设置帧数
    game_message.auto_t = nil if game_message.auto_r # nil时为不自动继续
    # 重置强制关闭flag
    @eagle_force_close = false
    # 重置集体的z值
    eagle_reset_z
  end
  #--------------------------------------------------------------------------
  # ● 移出全部组件
  #--------------------------------------------------------------------------
  def eagle_move_out_assets
    # 隐藏pop的tag
    @eagle_sprite_pop_tag.visible = false
    # 移出显示的脸图
    eagle_face_move_out if @eagle_sprite_face.opacity > 0 # 上一次的初始化移出
    # 关闭姓名框（因为对话框关闭后，姓名框不再更新，调小openness确保先关闭）
    @eagle_window_name.close
    @eagle_window_name.openness -= 15
    # 隐藏pause精灵
    @eagle_sprite_pause.visible = false
  end
  #--------------------------------------------------------------------------
  # ● 重设z值
  #--------------------------------------------------------------------------
  def eagle_reset_z
    self.z = game_message.win_params[:z] if game_message.win_params[:z] > 0
    @back_sprite.z = self.z
    @eagle_chara_viewport.z = self.z + 1
    @eagle_sprite_pop_tag.z = self.z + 1
    @eagle_sprite_face.z = self.z + game_message.face_params[:z]
    @eagle_window_name.z = self.z + 2
    @eagle_sprite_pause.z = self.z + 2
  end

  #--------------------------------------------------------------------------
  # ● 更新fiber
  #--------------------------------------------------------------------------
  alias eagle_message_ex_update_fiber update_fiber
  def update_fiber
    eagle_update_before_fiber
    eagle_message_ex_update_fiber
    eagle_update_after_fiber
  end
  #--------------------------------------------------------------------------
  # ● 更新（在 @fiber 更新之前）
  #--------------------------------------------------------------------------
  def eagle_update_before_fiber
    eagle_update_assets_after_open if self.openness > 0
    eagle_face_update_move if game_message.face_params[:params_move]
  end
  #--------------------------------------------------------------------------
  # ● 更新（在 @fiber 更新之后）
  #--------------------------------------------------------------------------
  def eagle_update_after_fiber
    @eagle_chara_sprites.each { |s| s.update }
    eagle_update_dup_windows
  end
  #--------------------------------------------------------------------------
  # ● 对话框打开后进行组件更新
  #--------------------------------------------------------------------------
  def eagle_update_assets_after_open
    eagle_pop_update if game_message.pop?
    eagle_face_update if game_message.face?
    @eagle_window_name.update if game_message.name?
    @eagle_sprite_pause.update if @eagle_sprite_pause.visible
    force_close if MESSAGE_EX.skip?
  end
  #--------------------------------------------------------------------------
  # ● 更新拷贝窗口
  #--------------------------------------------------------------------------
  def eagle_update_dup_windows
    @eagle_dup_windows.delete_if { |w| w.disposed? }
    @eagle_dup_windows.each { |w| w.update; w.dispose if w.openness <= 0 }
  end

  #--------------------------------------------------------------------------
  # ● 打开直至完成（当有文字绘制完成时执行）
  #--------------------------------------------------------------------------
  def eagle_open_and_wait
    @eagle_chara_sprites.each { |c| c.visible = false }
    @eagle_window_name.open if game_message.name?
    @flag_open_close = true
    if game_message.default_open_type # using default open
      eagle_set_wh(nil, nil, true, true)
      open_and_wait
    else
      self.openness = 255
      eagle_set_wh(nil, nil, false, true)
    end
    game_message.need_open = false
    @flag_open_close = false
    @eagle_chara_sprites.each { |c| c.move_in; c.visible = true }
  end
  #--------------------------------------------------------------------------
  # ● （覆盖）更新打开处理
  #--------------------------------------------------------------------------
  def update_open
    self.openness += 36
    @opening = false if open?
  end
  #--------------------------------------------------------------------------
  # ● 关闭
  #--------------------------------------------------------------------------
  alias eagle_message_ex_close close
  def close
    eagle_message_ex_close
    eagle_process_temp
    eagle_message_reset
  end
  #--------------------------------------------------------------------------
  # ● 关闭直至完成
  #--------------------------------------------------------------------------
  def close_and_wait
    @flag_open_close = true
    eagle_message_sprites_move_out
    if game_message.default_open_type # using default open
      close
      Fiber.yield until all_close?
    else
      eagle_move_out_assets
      eagle_set_wh(1, 1) if self.openness > 0
      close
      self.openness = 0
    end
    @flag_open_close = false
  end
  #--------------------------------------------------------------------------
  # ● 移出全部文字精灵
  #--------------------------------------------------------------------------
  def eagle_message_sprites_move_out
    while(!@eagle_chara_sprites.empty?)
      c = eagle_take_out_a_chara
      ensure_character_visible(c)
      c.move_out # 已经交由文字池进行后续更新释放
      win_params[:cwo].times { Fiber.yield } unless @eagle_force_close
    end
  end
  #--------------------------------------------------------------------------
  # ● 取出一个文字精灵
  #--------------------------------------------------------------------------
  def eagle_take_out_a_chara
    case win_params[:cor]
    when 0, false; return @eagle_chara_sprites.shift
    when 1, true; return @eagle_chara_sprites.pop
    when 2;
      i = rand(@eagle_chara_sprites.size)
      return @eagle_chara_sprites.delete_at(i)
    end
  end

  #--------------------------------------------------------------------------
  # ● 设置对话框的宽高
  #--------------------------------------------------------------------------
  def eagle_set_wh(des_w = nil, des_h = nil, _instant = false, _open = false)
    if des_w.nil?
      des_w  = eagle_window_width
      des_w += eagle_window_width_add(des_w)
    end
    if des_h.nil?
      des_h  = eagle_window_height
      des_h += eagle_window_height_add(des_h)
    end
    if _instant
      self.width = des_w
      self.height = des_h
    end
    if _open # 如果为打开，则记录下最终稳定的宽高
      win_params[:des_w] = des_w
      win_params[:des_h] = des_h
    end
    eagle_recreate_back_bitmap(des_w, des_h)
    wait_until_des_wh(des_w, des_h) if !_instant
    eagle_win_update
  end
  #--------------------------------------------------------------------------
  # ● 更新对话框宽高直至完成
  #--------------------------------------------------------------------------
  def wait_until_des_wh(des_w, des_h)
    init_w = self.width;  d_w = des_w - init_w
    init_h = self.height; d_h = des_h - init_h
    return if d_w == 0 && d_h == 0
    max_w = des_w > self.width ? des_w : self.width
    max_h = des_h > self.height ? des_h : self.height
    _i = 0; _t = 20
    while(true)
      break if _i > _t
      break if self.openness == 0
      per = _i * 1.0 / _t
      per = (_i == _t ? 1 : (1 - 2**(-10 * per)))
      self.width = init_w + d_w * per
      self.height = init_h + d_h * per
      eagle_win_update
      update_back_sprite_zoom(max_w, max_h)
      Fiber.yield
      _i += 1
    end
  end
  #--------------------------------------------------------------------------
  # ● 获取窗口宽度高度
  #--------------------------------------------------------------------------
  def eagle_window_width
    if game_message.pop? && pop_params[:w] > 0
      return pop_params[:w] + standard_padding * 2
    end
    if win_params[:w] > 0
      return win_params[:w] + standard_padding * 2
    end
    w = nil
    w = @eagle_charas_w       if eagle_dynamic_w?
    w = @eagle_charas_w_final if eagle_dyn_fit_w?
    if w
      w = win_params[:wmin] if win_params[:wmin] > 0 && w < win_params[:wmin]
      w = win_params[:wmax] if win_params[:wmax] > 0 && w > win_params[:wmax]
      w += standard_padding * 2
      w += eagle_face_width
      return w
    end
    window_width
  end
  def eagle_window_height
    if game_message.pop? && pop_params[:h] > 0
      return eagle_check_param_h(pop_params[:h]) + standard_padding * 2
    end
    if win_params[:h] > 0
      return eagle_check_param_h(win_params[:h]) + standard_padding * 2
    end
    h = nil
    h = @eagle_charas_h       if eagle_dynamic_h?
    h = @eagle_charas_h_final if eagle_dyn_fit_h?
    if h
      h = win_params[:hmin] if win_params[:hmin] > 0 && h < win_params[:hmin]
      h = win_params[:hmax] if win_params[:hmax] > 0 && h > win_params[:hmax]
      h += standard_padding * 2
      return h
    end
    window_height
  end
  #--------------------------------------------------------------------------
  # ● 检查内容高度参数
  #  如果h小于行高，则判定其为行数
  #--------------------------------------------------------------------------
  def eagle_check_param_h(h)
    h = line_height * h + win_params[:ld] * (h - 1) if h < line_height
    return h
  end
  #--------------------------------------------------------------------------
  # ● 直接指定宽度高度？
  #--------------------------------------------------------------------------
  def eagle_fix_w?
    return pop_params[:w] > 0 if game_message.pop?
    return win_params[:w] > 0
  end
  def eagle_fix_h?
    return pop_params[:h] > 0 if game_message.pop?
    return win_params[:h] > 0
  end
  #--------------------------------------------------------------------------
  # ● 动态调整宽度高度？
  #--------------------------------------------------------------------------
  def eagle_dynamic_w?
    game_message.pop? ? pop_params[:dw] : win_params[:dw]
  end
  def eagle_dynamic_h?
    game_message.pop? ? pop_params[:dh] : win_params[:dh]
  end
  #--------------------------------------------------------------------------
  # ● 预计算完整文字区域的宽度高度？
  #--------------------------------------------------------------------------
  def eagle_dyn_fit_w?
    game_message.pop? ? pop_params[:fw] : win_params[:fw]
  end
  def eagle_dyn_fit_h?
    game_message.pop? ? pop_params[:fh] : win_params[:fh]
  end
  #--------------------------------------------------------------------------
  # ● 可由子窗口增加对话框的宽度高度？
  #--------------------------------------------------------------------------
  def eagle_add_w_by_child_window?
    return false if eagle_fix_w?
    return true  if eagle_dynamic_w? || eagle_dyn_fit_w?
    return false
  end
  def eagle_add_h_by_child_window?
    return false if eagle_fix_h?
    return true  if eagle_dynamic_h? || eagle_dyn_fit_h?
    return false
  end
  #--------------------------------------------------------------------------
  # ● 额外增加的窗口宽度高度
  #--------------------------------------------------------------------------
  def eagle_window_width_add(cur_width)
    eagle_window_w_empty + game_message.child_window_w_des
  end
  def eagle_window_height_add(cur_height)
    eagle_window_h_empty + game_message.child_window_h_des
  end
  #--------------------------------------------------------------------------
  # ● 窗口内容中，无法被用于文本绘制的宽高
  #--------------------------------------------------------------------------
  def eagle_window_w_empty
    win_params[:cdx] + @eagle_sprite_pause_width_add + win_params[:cdw]
  end
  def eagle_window_h_empty
    win_params[:cdy]
  end

  #--------------------------------------------------------------------------
  # ● 更新win参数组（初始化/一页绘制完成时调用）
  #--------------------------------------------------------------------------
  def eagle_win_update
    return eagle_pop_update if game_message.pop?
    eagle_change_windowskin
    self.x = win_params[:x] || 0
    self.y = win_params[:y] || default_init_y
    eagle_reset_xy_dorigin(self, nil, win_params[:do]) if win_params[:do] < 0
    eagle_reset_xy_origin(self, win_params[:o])
    self.x += win_params[:dx]
    self.y += win_params[:dy]
    eagle_fix_position if win_params[:fix]
    eagle_after_update_xy
  end
  #--------------------------------------------------------------------------
  # ● 获取对话框的初始y位置
  #--------------------------------------------------------------------------
  def default_init_y
    (@position * (Graphics.height - win_params[:des_h]) / 2)
  end
  #--------------------------------------------------------------------------
  # ● 修正位置（确保对话框完整显示）
  #--------------------------------------------------------------------------
  def eagle_fix_position
    self.x = [[self.x, 0].max, Graphics.width - self.width].min
    self.y = [[self.y, 0].max, Graphics.height - self.height].min
  end
  #--------------------------------------------------------------------------
  # ● 更新xy后的操作
  #--------------------------------------------------------------------------
  def eagle_after_update_xy
    eagle_set_charas_viewport
    eagle_name_update if game_message.name?
  end
  #--------------------------------------------------------------------------
  # ● 设置文字显示区域的矩形（屏幕坐标）
  #--------------------------------------------------------------------------
  def eagle_set_charas_viewport
    @eagle_chara_viewport.rect.set(eagle_charas_x0, eagle_charas_y0,
      eagle_charas_max_w + eagle_window_w_empty,
      eagle_charas_max_h + eagle_window_h_empty)
  end
  #--------------------------------------------------------------------------
  # ● 更新pop参数组
  #--------------------------------------------------------------------------
  def eagle_pop_update
    eagle_change_windowskin(pop_params[:skin])
    # 对话框左上角定位到绑定对象位图的对应o位置
    _x = 0; _y = 0
    if @flag_pop_chara # 如果对象使用的是行走图，定位到位图底部中心的屏幕位置
      _x = @eagle_pop_obj.screen_x
      _y = @eagle_pop_obj.screen_y
    else # 如果对象为精灵，则与对应精灵的坐标一致（注意：精灵底部中心为显示原点）
      _x = @eagle_pop_obj.x
      _y = @eagle_pop_obj.y
    end
    self.x = _x
    self.y = _y
    eagle_reset_xy_origin(self, 10 - pop_params[:do]) # 显示原点恰好相反
    # 将对话框移动到绑定对象的对应方向上，并加上偏移量
    case pop_params[:do]
    when 1,4,7; self.x -= (pop_params[:chara_w] / 2 + pop_params[:d])
    when 3,6,9; self.x += (pop_params[:chara_w] + pop_params[:d])
    end
    case pop_params[:do]
    when 1,2,3; self.y += (pop_params[:chara_h] / 2 + pop_params[:d])
    when 7,8,9; self.y -= (pop_params[:chara_h] + pop_params[:d])
    end
    # 坐标的补足偏移量
    self.x += pop_params[:dx]
    self.y += pop_params[:dy]
    eagle_pop_tag_update if pop_params[:tag] > 0
    if pop_params[:fix]
      eagle_fix_position
      eagle_pop_tag_fix_position if pop_params[:tag] > 0
    end
    eagle_after_update_xy
  end
  #--------------------------------------------------------------------------
  # ● 更新pop的tag
  #--------------------------------------------------------------------------
  def eagle_pop_tag_update
    o = 10 - pop_params[:do] # tag的o值恰好与pop对话框的do值相对
    return @eagle_sprite_pop_tag.visible = false if @flag_open_close || o < 1 || o > 9
    @eagle_sprite_pop_tag.visible = true
    redraw = @pop_tag_o_draw != o ? true : false
    MESSAGE_EX.windowtag_o(self, @eagle_sprite_pop_tag, @eagle_pop_tag_bitmap, o, redraw)
    @pop_tag_o_draw = o
    case o # 坐标距离事件格子中心的偏移量
    when 1,4,7; @eagle_sprite_pop_tag.x -= pop_params[:td]
    when 3,6,9; @eagle_sprite_pop_tag.x += pop_params[:td]
    end
    case o
    when 1,2,3; @eagle_sprite_pop_tag.y -= pop_params[:td]
    when 7,8,9; @eagle_sprite_pop_tag.y += pop_params[:td]
    end
  end
  #--------------------------------------------------------------------------
  # ● 修正pop的tag的位置
  #--------------------------------------------------------------------------
  def eagle_pop_tag_fix_position
    # 若tag因为对话框的fix position而位于对话框内，则隐藏
    s = @eagle_sprite_pop_tag
    return if s.x + pop_params[:td] >= self.x + self.width
    return if s.x + s.width - pop_params[:td] <= self.x
    return if s.y + pop_params[:td] >= self.y + self.height
    return if s.y + s.height - pop_params[:td] <= self.y
    @eagle_sprite_pop_tag.visible = false
  end
  #--------------------------------------------------------------------------
  # ● 更新face参数组
  #--------------------------------------------------------------------------
  def eagle_face_update
    if face_params[:dir] # 脸图放置于右侧时
      @eagle_sprite_face.x = self.x + self.width - standard_padding - @eagle_sprite_face.ox
    else # 脸图放置于左侧时
      @eagle_sprite_face.x = self.x + standard_padding + @eagle_sprite_face.ox
    end
    @eagle_sprite_face.x += face_params[:dx]
    @eagle_sprite_face.y = self.y + self.height - standard_padding + face_params[:dy]
    @eagle_sprite_face.mirror = face_params[:m]

    # 更新脸图循环播放
    if face_params[:flag_l]
      if face_params[:li_c] >= face_params[:le]
        # 每次loop之间的等待
        return if face_params[:lw].nil?
        face_params[:lw_c] -= 1
        return if face_params[:lw_c] > 0
        face_params[:lw_c] = face_params[:lw]
        face_params[:li_c] = face_params[:ls]
      else
        # 每帧之间的等待
        face_params[:lt_c] -= 1
        return if face_params[:lt_c] > 0
        face_params[:lt_c] = face_params[:lt]
        face_params[:li_c] += 1
      end
      face_params[:i] = face_params[:li_c]
      eagle_face_apply
    end
  end
  #--------------------------------------------------------------------------
  # ● 更新face参数组中的移动（用于滞后移出效果）
  #--------------------------------------------------------------------------
  def eagle_face_update_move
    if face_params[:params_move][0] > 0
      face_params[:params_move][0] -= 1
      face_params[:params_move][2] += face_params[:params_move][1]
      @eagle_sprite_face.x += face_params[:params_move][2]
      @eagle_sprite_face.opacity += face_params[:params_move][3]
    else
      face_params[:params_move] = nil
    end
  end
  #--------------------------------------------------------------------------
  # ● 更新name参数组（随win/pop参数组更新）
  #--------------------------------------------------------------------------
  def eagle_name_update
    eagle_reset_xy_dorigin(@eagle_window_name, self, name_params[:do])
    eagle_reset_xy_origin(@eagle_window_name, name_params[:o])

    # 若姓名框遮挡了脸图，则移动到不遮挡的地方
    lx = self.x + eagle_face_left_width
    rx = self.x + self.width - eagle_face_right_width
    w = @eagle_window_name.width
    @eagle_window_name.x = lx if @eagle_window_name.x < lx
    @eagle_window_name.x = rx-w if @eagle_window_name.x+w > rx

    @eagle_window_name.x += name_params[:dx]
    @eagle_window_name.y += name_params[:dy]
  end

  #--------------------------------------------------------------------------
  # ● 变更窗口皮肤
  #--------------------------------------------------------------------------
  def eagle_change_windowskin(index = nil)
    index = win_params[:skin] if index.nil?
    eagle_set_pop_tag_by_windowskin(index)
    return if @win_skin_draw == index
    @win_skin_draw = index
    self.windowskin = MESSAGE_EX.windowskin(index)
    change_color(text_color(0))
  end
  #--------------------------------------------------------------------------
  # ● 获取当前窗口皮肤的序号
  #--------------------------------------------------------------------------
  def get_cur_windowskin_index(index = nil)
    return index if index
    return pop_params[:skin] if game_message.pop? && !pop_params[:skin].nil?
    return win_params[:skin]
  end
  #--------------------------------------------------------------------------
  # ● 依据窗口皮肤设置tag序号
  #--------------------------------------------------------------------------
  def eagle_set_pop_tag_by_windowskin(index = nil)
    tag_id = MESSAGE_EX::WINDOWSKIN_TO_WINDOWTAG[index]
    return if tag_id.nil? || @pop_tag_draw == tag_id
    eagle_reset_pop_tag_bitmap(tag_id)
  end

  #--------------------------------------------------------------------------
  # ● 重新生成背景位图
  #--------------------------------------------------------------------------
  def eagle_recreate_back_bitmap(w = self.width, h = self.height)
    return if win_params[:bg] && eagle_draw_bg_pic
    @win_bg_draw = nil # 清除之前的图片背景
    case game_message.background
    when 1 # 暗色背景
      if @back_bitmap && @back_bitmap.width == w && @back_bitmap.height == h
      else # 重绘
        @back_bitmap.dispose if @back_bitmap
        @back_bitmap = Bitmap.new(w, h)
        rect1 = Rect.new(0, 0, w, 12)
        rect2 = Rect.new(0, 12, w, h - 24)
        rect3 = Rect.new(0, h - 12, w, 12)
        @back_bitmap.gradient_fill_rect(rect1, back_color2, back_color1, true)
        @back_bitmap.fill_rect(rect2, back_color1)
        @back_bitmap.gradient_fill_rect(rect3, back_color1, back_color2, true)
      end
      @back_sprite.bitmap = @back_bitmap
      @back_sprite.visible = true
      self.opacity = 0
    when 2 # 透明背景
      @back_sprite.visible = false
      self.opacity = 0
    else # 普通
      @back_sprite.visible = false
      self.opacity = 255
    end
  end
  #--------------------------------------------------------------------------
  # ● 绘制背景图片
  #--------------------------------------------------------------------------
  def eagle_draw_bg_pic
    @back_sprite.visible = true
    self.opacity = 0
    return true if @win_bg_draw == win_params[:bg]
    _bitmap = MESSAGE_EX.windowbg(win_params[:bg])
    if _bitmap != nil
      @back_sprite.bitmap = _bitmap
      @win_bg_draw = win_params[:bg]
      return true
    end
    return false
  end
  #--------------------------------------------------------------------------
  # ● 更新背景精灵
  #--------------------------------------------------------------------------
  def update_back_sprite
    eagle_reset_xy_dorigin(@back_sprite, self, win_params[:bgo])
    MESSAGE_EX.reset_sprite_oxy(@back_sprite, win_params[:bgo])
    @back_sprite.opacity = openness
    @back_sprite.update
  end
  #--------------------------------------------------------------------------
  # ● 更新背景精灵的缩放
  #--------------------------------------------------------------------------
  def update_back_sprite_zoom(max_w = nil, max_h = nil)
    if max_w == nil
      @back_sprite.zoom_x = 1
    else
      @back_sprite.zoom_x = self.width * 1.0 / max_w
    end
    if max_h == nil
      @back_sprite.zoom_y = 1
    else
      @back_sprite.zoom_y = self.height * 1.0 / max_h
    end
  end

  #--------------------------------------------------------------------------
  # ● 处理纤程的主逻辑（覆盖）
  #--------------------------------------------------------------------------
  def fiber_main
    game_message.visible = true
    update_background
    update_placement
    loop do
      eagle_process_all_text
      process_input
      eagle_process_before_close
      Fiber.yield
      break unless text_continue?
    end
    close_and_wait
    game_message.visible = false
    @fiber = nil
  end
  #--------------------------------------------------------------------------
  # ● 处理全部文本（扩展）
  #--------------------------------------------------------------------------
  def eagle_process_all_text
    return if !game_message.has_text?
    if game_message.para && !game_message.input_pause?
      @fiber_para = Fiber.new { process_all_text; @fiber_para = nil }
      return
    end
    process_all_text
  end
  #--------------------------------------------------------------------------
  # ● 处理关闭前的操作
  #--------------------------------------------------------------------------
  def eagle_process_before_close
    game_message.clear
    @gold_window.close
  end
  #--------------------------------------------------------------------------
  # ● 判定文字是否继续显示（覆盖）
  #--------------------------------------------------------------------------
  def text_continue?
    game_message.no_close && game_message.has_text? && !settings_changed?
  end
  #--------------------------------------------------------------------------
  # ● 判定对话框设置是否被更改（覆盖）
  #  若返回 false，则会保留当前对话框不关闭，继续显示下一个指令的文本
  #--------------------------------------------------------------------------
  def settings_changed?
    return true if game_message.face_name.empty?
    (face_params[:name] != game_message.face_name ||
    face_params[:i] != game_message.face_index)
  end

  #--------------------------------------------------------------------------
  # ● 获取即将绘制的所有文本内容
  #--------------------------------------------------------------------------
  def eagle_all_text
    text = game_message.all_text
    if !game_message.escape_strings.empty? # 如果存在待处理的转义符串，加到开头
      text = game_message.escape_strings.inject("") { |sum, s| sum = sum + s } + text
      game_message.escape_strings.clear
    end
    text = convert_escape_characters(text)
    text
  end
  #--------------------------------------------------------------------------
  # ● 进行控制符的事前变换
  #    在实际绘制前、将控制符替换为实际的内容。
  #    为了减少歧异，文字「\」会被首先替换为转义符（\e）。
  #--------------------------------------------------------------------------
  alias eagle_convert_escape_characters convert_escape_characters
  def convert_escape_characters(text)
    result = text.to_s.clone
    result = eagle_process_conv(result)
    result = eagle_process_rb(result)
    result = eagle_convert_escape_characters(result) # 此处将 \\ 替换成了 \e
    result.gsub!(/\eINFO\[(\w)(\d+)\]/i) { MESSAGE_EX.get_data_info($1, $2.to_i) }
    result.gsub!(/\enl|\enew_line/i) { "\n" } # 替换换行转义符
    result
  end
  #--------------------------------------------------------------------------
  # ● 替换转义符（此时依旧是 \\ 开头的转义符）
  #--------------------------------------------------------------------------
  def eagle_process_conv(text)
    text.gsub!(/\\conv\[(.*?)\]/i) { MESSAGE_EX.get_conv($1) }
    text
  end
  #--------------------------------------------------------------------------
  # ● 处理脚本转义符（此时依旧是 \\ 开头的转义符）
  #--------------------------------------------------------------------------
  def eagle_process_rb(text)
    s = $game_switches; v = $game_variables
    text.gsub!(/\\RB\{(.*?)\}/i) { eval($1).to_s }
    text
  end

  #--------------------------------------------------------------------------
  # ● （覆盖）处理所有文本内容
  #--------------------------------------------------------------------------
  def process_all_text
    text = eagle_all_text; pos = {}
    new_page(text, pos)
    loop do
      break if text.empty?
      process_character(text.slice!(0, 1), text, pos)
      break @pause_skip = true if @eagle_force_close
    end
    eagle_process_draw_update if !@eagle_chara_sprites.empty?
  end
  #--------------------------------------------------------------------------
  # ● （覆盖）翻页处理
  #--------------------------------------------------------------------------
  def new_page(text, pos)
    eagle_message_sprites_move_out
    eagle_reset_charas_oxy
    pos[:x] = new_line_x
    pos[:y] = 0
    pos[:new_x] = new_line_x
    pos[:height] = line_height
    reset_font_settings
    clear_flags

    eagle_apply_params_changes
    eagle_check_pre_settings(text)
    eagle_draw_face(game_message.face_name, game_message.face_index)
    eagle_draw_name(text)

    # 当预先转义符全部处理完成，进行一次预绘制
    pre_calc_charas_wh(text, pos)
  end
  #--------------------------------------------------------------------------
  # ● （覆盖）获取换行位置
  #--------------------------------------------------------------------------
  def new_line_x; 0; end
  #--------------------------------------------------------------------------
  # ● 计算文字区域最终绘制完成时的宽度高度
  #  本质上为预先全部绘制一次（但不真实绘制）
  #--------------------------------------------------------------------------
  def pre_calc_charas_wh(text, pos)
    text_ = text.clone; pos_ = pos.clone
    game_message.save_params
    game_message.draw = false
    # 初始化
    @eagle_charas_w = @eagle_charas_h = 0
    # 执行预绘制
    process_character(text_.slice!(0, 1), text_, pos_) until text_.empty?
    # 记录最终的文字区域宽度高度
    @eagle_charas_w_final = @eagle_charas_w
    @eagle_charas_h_final = @eagle_charas_h
    before_input_pause unless @pause_skip # 此处追加对pause精灵占用宽度的处理
    # 复原
    @eagle_charas_w = @eagle_charas_h = 0
    game_message.load_params(nil)
    game_message.draw = true
  end
  #--------------------------------------------------------------------------
  # ● 强制中断绘制全部文本
  #--------------------------------------------------------------------------
  def force_close
    @eagle_force_close = true  # 若还在绘制，则直接结束绘制并跳过最后的等待按键
    @eagle_auto_continue_c = 0 # 若进入了按键等待，则将计数置0，并依靠auto跳过按键
  end

  #--------------------------------------------------------------------------
  # ● 文字显示区域的左上角位置（屏幕坐标系）
  #--------------------------------------------------------------------------
  def eagle_charas_x0
    self.x + standard_padding + eagle_face_left_width + win_params[:cdx]
  end
  def eagle_charas_y0
    self.y + standard_padding + win_params[:cdy]
  end
  #--------------------------------------------------------------------------
  # ● 计算文字显示区域的宽度和高度
  #--------------------------------------------------------------------------
  def eagle_charas_max_w
    self.width - standard_padding * 2 - eagle_face_width - eagle_window_w_empty
  end
  def eagle_charas_max_h
    self.height - standard_padding * 2 - eagle_window_h_empty
  end
  #--------------------------------------------------------------------------
  # ● 文字显示区域的显示原点
  #--------------------------------------------------------------------------
  def eagle_charas_ox; self.ox; end
  def eagle_charas_oy; self.oy; end
  #--------------------------------------------------------------------------
  # ● 重置文字显示区域
  #--------------------------------------------------------------------------
  def eagle_reset_charas_oxy
    self.ox = self.oy = 0
    @eagle_chara_viewport.rect.set(0,0,Graphics.width,Graphics.height)
  end
  #--------------------------------------------------------------------------
  # ● 重新生成适合全部文字的位图
  #--------------------------------------------------------------------------
  def recreate_contents_for_charas
    w = @eagle_charas_w + eagle_window_w_empty
    h = @eagle_charas_h + eagle_window_h_empty
    w = 1 if w == 0
    h = 1 if h == 0
    f = self.contents.font.dup
    self.contents.dispose if self.contents
    self.contents = Bitmap.new(w, h)
    self.contents.font = f
  end
  #--------------------------------------------------------------------------
  # ● （覆盖）普通文字的处理
  #--------------------------------------------------------------------------
  def process_normal_character(c, pos)
    c_rect = text_size(c); c_w = c_rect.width; c_h = c_rect.height
    eagle_auto_new_line(c_w, pos)
    if game_message.draw
      s = eagle_new_chara_sprite(pos[:x], pos[:y], c_w, c_h)
      s.eagle_font.draw(s.bitmap, 0, 0, c_w, c_h, c, 0)
    end
    eagle_process_draw_end(c_w, c_h, pos)
  end
  #--------------------------------------------------------------------------
  # ● （覆盖）处理控制符指定的图标绘制
  #--------------------------------------------------------------------------
  def process_draw_icon(icon_index, pos)
    eagle_auto_new_line(24, pos)
    if game_message.draw
      s = eagle_new_chara_sprite(pos[:x], pos[:y], 24, 24)
      s.eagle_font.draw_icon(s.bitmap, 0, 0, icon_index)
    end
    eagle_process_draw_end(24, 24, pos)
  end
  #--------------------------------------------------------------------------
  # ● （封装）生成一个新的文字精灵
  #--------------------------------------------------------------------------
  def eagle_new_chara_sprite(c_x, c_y, c_w, c_h)
    f = Font_EagleCharacter.new(font_params)
    f.set_param(:skin, win_params[:skin])
    f.set_param(:ex_cg, ex_params[:cg])

    s = MESSAGE_EX.charapool_new(self, f, c_x, c_y, c_w, c_h, @eagle_chara_viewport)
    s.start_effects(game_message.chara_params)
    @eagle_chara_sprites.push(s)
    s
  end
  #--------------------------------------------------------------------------
  # ● 检查自动换行
  #--------------------------------------------------------------------------
  def eagle_auto_new_line(c_w, pos)
    return if game_message.auto_wrap == false
    return if game_message.draw == false
    return if !eagle_fix_w? && eagle_dynamic_w?
    max_w = eagle_charas_max_w
    return if max_w <= 0
    return if pos[:x] + c_w <= max_w # 若当前文字绘制完成后会超出边界，则换行
    process_new_line('', pos)
  end
  #--------------------------------------------------------------------------
  # ● 绘制完成时的处理
  #--------------------------------------------------------------------------
  def eagle_process_draw_end(c_w, c_h, pos)
    # 处理下一次绘制的参数
    pos[:x] += (c_w - game_message.win_params[:ck])
    pos[:height] = [pos[:height], c_h].max
    # 记录下一个文字绘制位置x
    @eagle_next_chara_x = pos[:x]
    # 处理文字区域大小更改
    @eagle_charas_w = pos[:x] if @eagle_charas_w < pos[:x]
    @eagle_charas_h = pos[:y] + pos[:height] if @eagle_charas_h < pos[:y] + pos[:height]
    return if !game_message.draw
    return if show_fast? # 如果是立即显示，则不更新
    eagle_process_draw_update
    wait_for_one_character
  end
  #--------------------------------------------------------------------------
  # ● 绘制完成时的更新
  #--------------------------------------------------------------------------
  def eagle_process_draw_update
    # 第一个文字绘制后打开窗口
    return eagle_open_and_wait if game_message.need_open
    eagle_set_wh(nil, nil, true) # 重设对话框宽高，并更新对话框位置
    # 对齐需要用到对话框的宽高，因此在更新后执行
    eagle_charas_reset_alignment(win_params[:ali])
    # 确保最后绘制的文字在视图区域内
    ensure_character_visible(@eagle_chara_sprites[-1])
  end
  #--------------------------------------------------------------------------
  # ● 重排列全部文字精灵
  #--------------------------------------------------------------------------
  def eagle_charas_reset_alignment(align)
    return if @eagle_chara_sprites.empty?
    charas = [] # 存储当前迭代行的全部文字精灵
    # 存储当前迭代行的y值（同y的为同一行）（未考虑列排文字）
    charas_y = @eagle_chara_sprites[0].origin_y  # 初始为第一行
    # 最大宽度 = [可供文字绘制区域的最大宽度, 文字占据宽度].max
    max_w = [eagle_charas_max_w, @eagle_charas_w].max
    @eagle_chara_sprites.each do |s|
      next charas.push(s) if s.origin_y == charas_y # 第一行的首字符会存入
      # 对同一行的字符重排
      eagle_charas_realign_line(charas, align, max_w)
      charas.clear
      # 将当前迭代的 下一行的首字符 存入
      charas.push(s)
      charas_y = s.origin_y
    end
    # 对最后一行进行重排列
    eagle_charas_realign_line(charas, align, max_w) if !charas.empty?
  end
  #--------------------------------------------------------------------------
  # ● 重排列同一行上的文字精灵
  #--------------------------------------------------------------------------
  def eagle_charas_realign_line(charas, align, max_w)
    w_line = charas[-1].origin_x - charas[0].origin_x + charas[-1].width
    h_line = charas.collect{ |c| c.height }.max
    charas.each do |c|
      case align
      when 0 # 左对齐（默认对齐方式）
        _x = c.origin_x
      when 1 # 居中排列
        _x = c.origin_x + (max_w - w_line) / 2
      when 2 # 右排列
        _x = c.origin_x + max_w - w_line
      end
      _y = c.origin_y + h_line - c.height # 底部对齐
      c.reset_xy(_x, _y)
    end
  end
  #--------------------------------------------------------------------------
  # ● 确保指定文字在视图内
  #--------------------------------------------------------------------------
  def ensure_character_visible(c)
    return if c.nil?
    self.ox = 0 if c._x < self.ox
    d = c._x + c.width - @eagle_chara_viewport.rect.width
    self.ox = d if d > 0
    self.oy = 0 if c._y < self.oy
    d = c._y + c.height - @eagle_chara_viewport.rect.height
    self.oy = d if d > 0
  end
  #--------------------------------------------------------------------------
  # ● （覆盖）处于快进显示？
  #--------------------------------------------------------------------------
  def show_fast?
    game_message.instant || @show_fast || @line_show_fast
  end
  #--------------------------------------------------------------------------
  # ● （覆盖）输出一个字符后的等待
  #--------------------------------------------------------------------------
  def wait_for_one_character
    MESSAGE_EX.se(game_message.win_params[:se])
    game_message.win_params[:cwi].times do
      return if show_fast?
      update_show_fast if game_message.win_params[:cfast]
      Fiber.yield
    end
  end
  #--------------------------------------------------------------------------
  # ● （覆盖）换行文字的处理（删去翻页）
  #  由于自动对齐的存在，无需预先计算当前行高，text参数无效
  #--------------------------------------------------------------------------
  def process_new_line(text = '', pos)
    pos[:height] += game_message.win_params[:ld] # 当前行增加一个行间距
    @line_show_fast = false
    pos[:x] = pos[:new_x]
    pos[:y] += pos[:height]
    pos[:height] = line_height
  end

  #--------------------------------------------------------------------------
  # ● 输入处理（此处为全部绘制完成后，判定接下来的输入类型）
  #--------------------------------------------------------------------------
  alias eagle_message_ex_process_input process_input
  def process_input
    eagle_message_ex_process_input
    eagle_process_hold
  end
  #--------------------------------------------------------------------------
  # ● （覆盖）处理输入等待
  #--------------------------------------------------------------------------
  def input_pause
    return if !game_message.draw
    before_input_pause
    eagle_process_draw_update # 统一更新一次
    @eagle_sprite_pause.bind_last_chara(@eagle_chara_sprites[-1])
    @eagle_sprite_pause.show
    self.pause = true unless MESSAGE_EX::NO_DEFAULT_PAUSE
    process_input_pause
    self.pause = false
    @eagle_sprite_pause.hide
  end
  #--------------------------------------------------------------------------
  # ● 输入等待前的操作
  #--------------------------------------------------------------------------
  def before_input_pause
    # 当pause精灵位于句末且紧靠边界时
    #  增加对话框宽度保证它在对话框内部（不可占用padding）
    if game_message.pause_params[:v] != 0 && game_message.pause_params[:do] <= 0 &&
       !eagle_fix_w? && game_message.input_pause?
      d = @eagle_charas_w + win_params[:cdw] - @eagle_next_chara_x
      d -= @eagle_sprite_pause.width
      @eagle_sprite_pause_width_add = -d if d < 0
    end
  end
  #--------------------------------------------------------------------------
  # ● 执行输入等待
  #--------------------------------------------------------------------------
  def process_input_pause
    recreate_contents_for_charas
    @eagle_auto_continue_c = game_message.auto_t
    ox_max = [self.ox, @eagle_charas_w - @eagle_chara_viewport.rect.width].max
    oy_max = self.oy
    d_oxy = 1; last_input = nil; last_input_c = 0
    self.arrows_visible = true
    while true
      Fiber.yield
      # 处理自动继续
      if @eagle_auto_continue_c
        break if @eagle_auto_continue_c <= 0
        process_while_auto_wait_input_pause(@eagle_auto_continue_c)
        @eagle_auto_continue_c -= 1
      end
      break if check_input_pause?
      # 处理内容滚动
      if Input.press?(:UP)
        self.oy -= d_oxy
        self.oy = 0 if self.oy < 0
      elsif Input.press?(:DOWN)
        self.oy += d_oxy
        self.oy = oy_max if self.oy > oy_max
      elsif Input.press?(:LEFT)
        self.ox -= d_oxy
        self.ox = 0 if self.ox < 0
      elsif Input.press?(:RIGHT)
        self.ox += d_oxy
        self.ox = ox_max if self.ox > ox_max
      end
      if last_input == Input.dir4
        last_input_c += 1
        d_oxy += 1 if last_input_c % 10 == 0
      else
        d_oxy = 1
        last_input_c = 0
      end
      last_input = Input.dir4
    end
    self.arrows_visible = false
    Input.update
  end
  #--------------------------------------------------------------------------
  # ● 等待按键时，启用auto时的额外处理
  #  c 为自动继续的剩余帧数，用 game_message.auto_t 获取总等待帧数
  #--------------------------------------------------------------------------
  def process_while_auto_wait_input_pause(c)
    @eagle_sprite_pause.redraw_auto_countdown(c)
  end
  #--------------------------------------------------------------------------
  # ● 检查输入等待的按键
  #--------------------------------------------------------------------------
  def check_input_pause?
    Input.trigger?(:B) || Input.trigger?(:C)
  end
  #--------------------------------------------------------------------------
  # ● 处理选项的输入（覆盖）
  #--------------------------------------------------------------------------
  def input_choice
    input_wait_until_msg_wh(@choice_window)
    input_wait_while_active(@choice_window)
  end
  #--------------------------------------------------------------------------
  # ● 处理数值的输入（覆盖）
  #--------------------------------------------------------------------------
  def input_number
    input_wait_until_msg_wh(@number_window)
    input_wait_while_active(@number_window)
  end
  #--------------------------------------------------------------------------
  # ● 处理物品的选择（覆盖）
  #--------------------------------------------------------------------------
  def input_item
    input_wait_until_msg_wh(@item_window)
    input_wait_while_active(@item_window)
  end
  #--------------------------------------------------------------------------
  # ● 等待对话框宽高处理结束
  #--------------------------------------------------------------------------
  def input_wait_until_msg_wh(child_window)
    child_window.hide.start
    eagle_set_wh # 执行因子窗口嵌入而变更的窗口大小
    child_window.show.open.activate
  end
  #--------------------------------------------------------------------------
  # ● 并行等待子窗口处理结束
  #--------------------------------------------------------------------------
  def input_wait_while_active(child_window)
    while child_window.active
      break child_window.deactivate.close if @eagle_force_close
      @fiber_para.resume if @fiber_para
      Fiber.yield
    end
    @fiber_para = nil
  end

  #--------------------------------------------------------------------------
  # ● 应用预定的转义符修改
  #--------------------------------------------------------------------------
  def eagle_apply_params_changes
    game_message.params_need_apply.each do |sym|
      m_c = ("eagle_text_control_#{sym}").to_sym
      method(m_c).call("") if respond_to?(m_c)
    end
    game_message.clear_applys
  end
  #--------------------------------------------------------------------------
  # ● 设置【预先】指令的参数
  #--------------------------------------------------------------------------
  def eagle_check_pre_settings(text)
    eagle_check_temp(text)
    eagle_check_hold(text)
    eagle_check_instant(text)
    eagle_check_popt(text)
    eagle_check_facep(text)
  end
  #--------------------------------------------------------------------------
  # ● 设置/执行temp指令
  #--------------------------------------------------------------------------
  def eagle_check_temp(text)
    text.gsub!(/\e(temp)/i) { "" }
    if $1
      game_message.save_params(:temp)
      @flag_temp_params = true
    end
  end
  def eagle_process_temp
    return if @flag_temp_params == false
    @flag_temp_params = false
    game_message.load_params(nil, :temp) # 已经在预绘制时存储了参数
  end
  #--------------------------------------------------------------------------
  # ● 设置/执行hold指令
  #--------------------------------------------------------------------------
  def eagle_check_hold(text)
    text.gsub!(/\e(hold)/i) { "" }
    game_message.hold = $1 ? true : false
  end
  def eagle_process_hold
    if game_message.hold
      @eagle_dup_windows.unshift( self.clone )
      self.openness = 0
    else
      eagle_release_hold
    end
  end
  def eagle_release_hold # 所有暂存窗口关闭
    @eagle_dup_windows.each { |w| w.close_clone }
  end
  #--------------------------------------------------------------------------
  # ● 设置instant指令
  #--------------------------------------------------------------------------
  def eagle_check_instant(text)
    text.gsub!(/\e(ins|instant)/i) { game_message.instant = true if $1; "" }
  end
  #--------------------------------------------------------------------------
  # ● 分析【预先】转义符的全部参数（按出现顺序处理）
  #--------------------------------------------------------------------------
  def parse_pre_params(text, sym, hash, default_type = :default)
    params = []
    text.gsub!(/\e#{sym}\[(.*?)\]/i) { params.push($1); "" }
    params.push("") if params.empty?
    params.each { |param| parse_param(hash, param, default_type) }
  end
  #--------------------------------------------------------------------------
  # ● 设置popt指令的参数
  #--------------------------------------------------------------------------
  def eagle_check_popt(text)
    old_tag = pop_params[:tag]
    parse_pre_params(text, 'popt', pop_params, :tag)
    new_tag = pop_params[:tag]
    return if new_tag <= 0 || old_tag == new_tag || @pop_tag_draw == new_tag
    eagle_reset_pop_tag_bitmap(new_tag)
  end
  #--------------------------------------------------------------------------
  # ● 重置tag的位图
  #--------------------------------------------------------------------------
  def eagle_reset_pop_tag_bitmap(tag_id = pop_params[:tag])
    @pop_tag_draw = tag_id
    @pop_tag_o_draw = 0 # 确保将重绘
    @eagle_pop_tag_bitmap = MESSAGE_EX.windowtag(tag_id)
    w = @eagle_pop_tag_bitmap.width
    h = @eagle_pop_tag_bitmap.height
    @eagle_sprite_pop_tag.bitmap.dispose if @eagle_sprite_pop_tag.bitmap
    @eagle_sprite_pop_tag.bitmap = Bitmap.new(w/3, h/3)
  end
  #--------------------------------------------------------------------------
  # ● 设置facep指令的参数
  #--------------------------------------------------------------------------
  def eagle_check_facep(text)
    parse_pre_params(text, 'facep', face_params, :dir)
    face_params[:dir] = MESSAGE_EX.check_bool(face_params[:dir])
    face_params[:m] = MESSAGE_EX.check_bool(face_params[:m])
  end
  #--------------------------------------------------------------------------
  # ● 初始化姓名框
  #--------------------------------------------------------------------------
  def name_params; game_message.name_params; end
  def eagle_draw_name(text)
    # 用 | 分隔需要绘制的name字符串（其中转义符用<>代替[]）和参数组
    str_name = ""
    text.gsub!(/\ename\[(.*?)\]/i) {
      t = $1.dup
      if t.include?('|')
        str_name = t.slice!(/.*?\|/).chop
        "\ename[#{t}]"
      else
        str_name = t
        ""
      end
    }
    parse_pre_params(text, 'name', name_params, :o)
    return if name_params[:name] == str_name
    name_params[:name] = str_name
    return if name_params[:name].empty?
    @eagle_window_name.reset
  end

  #--------------------------------------------------------------------------
  # ● 控制符的处理
  #     code : 控制符的实际形式（比如“\C[1]”是“C”）
  #     text : 绘制处理中的字符串缓存（字符串可能会被修改）
  #     pos  : 绘制位置 {:x, :y, :new_x, :height}
  #--------------------------------------------------------------------------
  alias eagle_message_ex_process_escape_character process_escape_character
  def process_escape_character(code, text, pos)
    temp_code = code.downcase
    m_c = ("eagle_text_control_" + temp_code).to_sym
    m_e = ("eagle_chara_effect_" + temp_code).to_sym
    if respond_to?(m_c)
      param = obtain_escape_param_string(text)
      method(m_c).call(param)
    elsif respond_to?(m_e)
      param = obtain_escape_param_string(text)
      # 当只传入 0 时，代表关闭该特效
      return eagle_chara_effect_clear(temp_code.to_sym) if param == '0'
      game_message.chara_params[temp_code.to_sym] = param
      method(m_e).call(param)
    elsif code.upcase == 'C'
      game_message.font_params[:c] = obtain_escape_param(text)
      change_color(text_color(game_message.font_params[:c]))
    else
      eagle_message_ex_process_escape_character(code, text, pos)
    end
  end
  #--------------------------------------------------------------------------
  # ● （覆盖）获取控制符的实际形式（这个方法会破坏原始数据）
  #--------------------------------------------------------------------------
  def obtain_escape_code(text)
    text.slice!(/^[\$\.\|\^!><\{\}\\]|^[A-Z]+/i)
  end
  #--------------------------------------------------------------------------
  # ● 获取控制符的参数（字符串形式）（这个方法会破坏原始数据）
  #--------------------------------------------------------------------------
  def obtain_escape_param_string(text)
    text.slice!(/^\[[\$\-\d\w]+\]/)[/[\$\-\d\w]+/] rescue ""
  end
  #--------------------------------------------------------------------------
  # ● 解析字符串参数
  #--------------------------------------------------------------------------
  def parse_param(param_hash, param_text, default_type = "default")
    MESSAGE_EX.parse_param(param_hash, param_text, default_type)
  end
  #--------------------------------------------------------------------------
  # ● 清除暂存的指定文字特效
  #--------------------------------------------------------------------------
  def eagle_chara_effect_clear(code_sym)
    game_message.chara_params.delete(code_sym)
  end

  #--------------------------------------------------------------------------
  # ● 设置font参数
  #--------------------------------------------------------------------------
  def font_params; game_message.font_params; end
  def eagle_text_control_font(param = "")
    parse_param(font_params, param, :size)
    MESSAGE_EX.apply_font_params(self.contents.font, font_params)
    change_color(text_color(font_params[:c]))
  end
  #--------------------------------------------------------------------------
  # ● （覆盖）重置字体设置
  #--------------------------------------------------------------------------
  def reset_font_settings
    change_color(normal_color)
    font_params[:c] = 0
  end
  #--------------------------------------------------------------------------
  # ● （覆盖）放大字体尺寸
  #--------------------------------------------------------------------------
  def make_font_bigger
    self.contents.font.size += 4 if self.contents.font.size <= 64
    font_params[:size] = self.contents.font.size
  end
  #--------------------------------------------------------------------------
  # ● （覆盖）缩小字体尺寸
  #--------------------------------------------------------------------------
  def make_font_smaller
    self.contents.font.size -= 4 if self.contents.font.size >= 16
    font_params[:size] = self.contents.font.size
  end
  #--------------------------------------------------------------------------
  # ● （覆盖）更改内容绘制颜色
  #     enabled : 有效的标志。false 的时候使用半透明效果绘制
  #--------------------------------------------------------------------------
  def change_color(color, enabled = true)
    super(color, enabled)
    font_params[:ca] = self.contents.font.color.alpha
  end

  #--------------------------------------------------------------------------
  # ● 设置win参数
  #--------------------------------------------------------------------------
  def win_params; game_message.win_params; end
  def eagle_text_control_win(param = "")
    parse_param(win_params, param, :o)
    win_params[:hmin] = eagle_check_param_h(win_params[:hmin])
    win_params[:hmax] = eagle_check_param_h(win_params[:hmax])
    win_params[:dw] = MESSAGE_EX.check_bool(win_params[:dw])
    win_params[:fw] = MESSAGE_EX.check_bool(win_params[:fw])
    win_params[:dh] = MESSAGE_EX.check_bool(win_params[:dh])
    win_params[:fh] = MESSAGE_EX.check_bool(win_params[:fh])
    win_params[:cwi] = 0 if win_params[:cwi] < 0
    win_params[:cwo] = 0 if win_params[:cwo] < 0
    win_params[:cfast] = MESSAGE_EX.check_bool(win_params[:cfast])
    win_params[:fix] = MESSAGE_EX.check_bool(win_params[:fix])
    eagle_reset_z
  end
  #--------------------------------------------------------------------------
  # ● （覆盖）获取基础行高
  #--------------------------------------------------------------------------
  alias eagle_message_ex_line_height line_height
  def line_height
    h = win_params[:lh]
    return h if h > 0
    return eagle_message_ex_line_height
  end

  #--------------------------------------------------------------------------
  # ● 设置pop参数
  #--------------------------------------------------------------------------
  def pop_params; game_message.pop_params; end
  def eagle_text_control_pop(param = "")
    @flag_pop_chara = false # 若为行走图类型的精灵，置为true
    pop_params[:id] = nil # 绑定对象的id
    parse_param(pop_params, param, :id)
    return if pop_params[:id].nil?
    @eagle_pop_obj = eagle_get_pop_obj # 获取所绑定的对象
    return pop_params[:id] = nil if @eagle_pop_obj.nil?
    # 存在绑定对象，可以使用pop对话框
    s = eagle_get_pop_sprite # 获取所绑定对象的精灵
    pop_params[:chara_w] = s.width
    pop_params[:chara_h] = s.height
    pop_params[:dw] = MESSAGE_EX.check_bool(pop_params[:dw])
    pop_params[:fw] = MESSAGE_EX.check_bool(pop_params[:fw])
    pop_params[:dh] = MESSAGE_EX.check_bool(pop_params[:dh])
    pop_params[:fh] = MESSAGE_EX.check_bool(pop_params[:fh])
    pop_params[:fix] = MESSAGE_EX.check_bool(pop_params[:fix])
    eagle_pop_update
  end
  #--------------------------------------------------------------------------
  # ● 获取pop的弹出对象（需要有x、y、width、height方法）
  #--------------------------------------------------------------------------
  def eagle_get_pop_obj
    return eagle_get_pop_obj_m if @in_map
    return eagle_get_pop_obj_b if @in_battle
    return nil
  end
  #--------------------------------------------------------------------------
  # ● 获取pop的对象（地图场景中）（Game_Character的实例）
  #--------------------------------------------------------------------------
  def eagle_get_pop_obj_m
    @flag_pop_chara = true
    id = pop_params[:id]
    if id == 0 # 当前事件
      return $game_map.events[game_message.event_id]
    elsif id > 0 # 第id号事件
      chara = $game_map.events[id]
      chara ||= $game_map.events[game_message.event_id]
      return chara
    elsif id < 0 # 队伍中数据库id号角色（不存在则取队长）
      id = id.abs
      $game_player.followers.each { |f|
        return f if f.actor && f.actor.actor.id == id
      }
      return $game_player
    end
  end
  #--------------------------------------------------------------------------
  # ● 获取pop的对象（战斗场景中）（Sprite_Battler的实例）
  #--------------------------------------------------------------------------
  def eagle_get_pop_obj_b
    id = pop_params[:id]
    return nil if id.nil?
    if id > 0 # 敌人index
      SceneManager.scene.spriteset.battler_sprites.each do |s|
        return s if s.battler && s.battler.enemy? && s.battler.index == id-1
      end
    elsif id < 0 # 我方数据库id
      id = id.abs
      SceneManager.scene.spriteset.battler_sprites.each do |s|
        return s if s.battler && s.battler.actor? && s.battler.id == id
      end
    end
    return nil
  end
  #--------------------------------------------------------------------------
  # ● 获取pop对象的精灵（用于计算偏移值）
  #--------------------------------------------------------------------------
  def eagle_get_pop_sprite
    # 地图场景中，所存储的并非精灵，需要再次检索
    return @eagle_pop_obj if !@flag_pop_chara
    SceneManager.scene.spriteset.character_sprites.each do |s|
      return s if s.character == @eagle_pop_obj
    end
    return nil
  end

  #--------------------------------------------------------------------------
  # ● 设置face参数
  #--------------------------------------------------------------------------
  def face_params; game_message.face_params; end
  def eagle_text_control_face(param = "")
    return if face_params[:name] == ""
    face_params[:ls] = -1 # 设置循环开始编号（+1直至le，再从ls循环）
    face_params[:le] = -1 # 设置循环结束编号
    parse_param(face_params, param, :i)

    # 判断是否需要循环的flag
    face_params[:flag_l] = (face_params[:ls] > -1 && face_params[:le] > face_params[:ls])
    face_params[:li_c] = face_params[:ls] # 循环用index计数
    face_params[:lt_c] = face_params[:lt] # 循环用time计数
    face_params[:lw_c] = face_params[:lw] # 循环后wait计数
    eagle_face_apply
  end
  #--------------------------------------------------------------------------
  # ● 初始化脸图
  #--------------------------------------------------------------------------
  def eagle_draw_face(face_name, face_index)
    return if face_params[:name] == face_name && face_params[:i] == face_index
    face_params[:name] = face_name
    face_params[:i] = face_index
    return if face_name == ""

    @eagle_face_bitmap.dispose if @eagle_face_bitmap
    @eagle_face_bitmap = Cache.face(face_name)
    face_name =~ /_(\d+)x(\d+)_?/i  # 从文件名获取行数和列数（默认为2行4列）
    face_params[:num_line] = $1 ? $1.to_i : face_default_line
    face_params[:num_col] = $2 ? $2.to_i : face_default_col
    face_params[:sole_w] = @eagle_face_bitmap.width / face_params[:num_col]
    face_params[:sole_h] = @eagle_face_bitmap.height / face_params[:num_line]
    # 脸图以底部中心为显示原点
    if $RGD
      @eagle_sprite_face.bitmap = @eagle_face_bitmap
      @eagle_sprite_face.ox = face_params[:sole_w] / 2
      @eagle_sprite_face.oy = face_params[:sole_h]
    else
      @eagle_sprite_face.bitmap.dispose if @eagle_sprite_face.bitmap
      @eagle_sprite_face.bitmap = Bitmap.new(face_params[:sole_w], face_params[:sole_h])
      @eagle_sprite_face.ox = @eagle_sprite_face.width / 2
      @eagle_sprite_face.oy = @eagle_sprite_face.height
    end
    @eagle_sprite_face.opacity = 0
    # 覆盖部分face参数
    eagle_text_control_face
    # 显示
    eagle_face_apply
    eagle_face_move_in
  end
  #--------------------------------------------------------------------------
  # ● 脸图默认规格（行和列）
  #--------------------------------------------------------------------------
  def face_default_line; 2; end
  def face_default_col;  4; end
  #--------------------------------------------------------------------------
  # ● 初始化脸图移入
  #--------------------------------------------------------------------------
  def eagle_face_move_in
    # 用于控制移入移出的参数组 [time, v_x, dx, v_opa]
    t = face_params[:it]
    v_x = face_params[:iv] * (face_params[:dir] ? -1 : 1)
    face_params[:params_move] = [t, v_x, v_x*t*-1, face_params[:io]]
  end
  #--------------------------------------------------------------------------
  # ● 初始化脸图移出
  #--------------------------------------------------------------------------
  def eagle_face_move_out
    t = face_params[:ot]
    v_x = face_params[:ov] * (face_params[:dir] ? 1 : -1)
    face_params[:params_move] = [t, v_x, 0, -1*face_params[:oo]]
  end
  #--------------------------------------------------------------------------
  # ● 应用设置的脸图
  # （根据设置好的参数，重新绘制脸图精灵的bitmap）
  #--------------------------------------------------------------------------
  def eagle_face_apply
    w = face_params[:sole_w]
    h = face_params[:sole_h]
    x = face_params[:i] % face_params[:num_col] * w
    y = face_params[:i] / face_params[:num_col] * h
    rect = Rect.new(x, y, w, h)
    if $RGD
      @eagle_sprite_face.src_rect = rect
    else
      @eagle_sprite_face.bitmap.clear
      @eagle_sprite_face.bitmap.blt(0,0, @eagle_face_bitmap,rect)
    end
  end
  #--------------------------------------------------------------------------
  # ● 脸图占用的宽度
  #--------------------------------------------------------------------------
  def eagle_face_width
    return 0 if !game_message.face?
    return 0 if face_params[:z] < 0
    @eagle_sprite_face.width + face_params[:dw]
  end
  #--------------------------------------------------------------------------
  # ● 脸图在左侧占用的宽度（用于调整文字区域的左侧起始位置）
  #--------------------------------------------------------------------------
  def eagle_face_left_width
    return 0 if face_params[:dir] # 显示在右侧时
    eagle_face_width
  end
  #--------------------------------------------------------------------------
  # ● 脸图在右侧占用的宽度
  #--------------------------------------------------------------------------
  def eagle_face_right_width
    return 0 if !face_params[:dir] # 显示在左侧时
    eagle_face_width
  end

  #--------------------------------------------------------------------------
  # ● 设置pause参数
  #--------------------------------------------------------------------------
  def pause_params; game_message.pause_params; end
  def eagle_text_control_pause(param = "")
    parse_param(pause_params, param, :pause)
    @eagle_sprite_pause.reset
  end

  #--------------------------------------------------------------------------
  # ● 设置wait参数
  #--------------------------------------------------------------------------
  def eagle_text_control_wait(param = '0')
    h = {}
    h[:t] = 0 # 等待帧数
    parse_param(h, param, :t)
    wait(h[:t])
  end
  #--------------------------------------------------------------------------
  # ● （覆盖）等待
  #--------------------------------------------------------------------------
  def wait(duration)
    return if !game_message.draw
    duration.times { break if @eagle_force_close; Fiber.yield }
  end

  #--------------------------------------------------------------------------
  # ● 设置auto参数
  #--------------------------------------------------------------------------
  def eagle_text_control_auto(param = '0')
    h = {}
    h[:t] = game_message.auto_t # 自动继续的帧数
    h[:r] = game_message.auto_r ? 1 : 0
    parse_param(h, param, :t)
    game_message.auto_t = h[:t]
    game_message.auto_r = MESSAGE_EX.check_bool(h[:r])
  end

  #--------------------------------------------------------------------------
  # ● 设置shake参数
  #--------------------------------------------------------------------------
  def eagle_text_control_shake(param = '0')
    return if !game_message.draw
    h = {}
    h[:p] = 5 # shake power
    h[:s] = 5 # shake speed
    h[:t] = 40 # shake duration
    parse_param(h, param, :t)
    # 等待震动至结束
    shake = 0 # 对话框的偏移值
    shake_direction = 1 # 下一次位移量
    while h[:t] > 0
      delta = (h[:p] * h[:s] * shake_direction) / 10.0
      shake += delta
      shake_direction = -1 if shake > h[:p] * 2
      shake_direction = 1 if shake < - h[:p] * 2
      h[:t] -= 1
      self.x += shake
      eagle_after_update_xy
      Fiber.yield
    end
    shake = shake.to_i # 平滑移动回初始位置
    d = shake > 0 ? -1 : 1
    while shake != 0
      shake += d
      self.x += shake
      eagle_after_update_xy
      Fiber.yield
    end
  end

  #--------------------------------------------------------------------------
  # ● 设置扩展参数
  #--------------------------------------------------------------------------
  def ex_params; game_message.ex_params; end
  #--------------------------------------------------------------------------
  # ● 设置cg参数 / 渐变绘制预定
  #--------------------------------------------------------------------------
  if defined?(Sion_GradientText)
  def eagle_text_control_cg(param = '0')
    ex_params[:cg].clear
    ex_params[:cg] = param if param != '' && param != '0'
  end
  end
end # end of class Window_Message

#=============================================================================
# ○ 对话框拷贝
#=============================================================================
class Window_Message_Clone < Window_Message
  attr_accessor :back_bitmap, :back_sprite
  attr_accessor :eagle_chara_viewport
  attr_accessor :eagle_chara_sprites, :eagle_sprite_pop_tag
  attr_accessor :eagle_sprite_face, :eagle_window_name, :eagle_sprite_pause
  attr_accessor :eagle_pop_obj
  #--------------------------------------------------------------------------
  # ● 初始化对象
  #--------------------------------------------------------------------------
  def initialize(game_message)
    @game_message = game_message
    super()
    self.openness = 255
    @fin = false # 结束显示？
  end
  #--------------------------------------------------------------------------
  # ● 获取主参数
  #--------------------------------------------------------------------------
  def game_message
    @game_message
  end
  #--------------------------------------------------------------------------
  # ● 重置单页对话框（覆盖，防止过早移出组件）
  #--------------------------------------------------------------------------
  def eagle_message_reset
    @eagle_sprite_pause_width_add = 0 # 拷贝窗口中不存在pause精灵
  end
  #--------------------------------------------------------------------------
  # ○ 记录文本的宽高（用于更新大小）
  #--------------------------------------------------------------------------
  def eagle_set_chara_wh(w, h, w_final, h_final)
    @eagle_charas_w = w
    @eagle_charas_h = h
    @eagle_charas_w_final = w_final
    @eagle_charas_h_final = h_final
  end
  #--------------------------------------------------------------------------
  # ● （覆盖）去除全部子窗口
  #--------------------------------------------------------------------------
  def create_all_windows
  end
  def dispose_all_windows
  end
  def update_all_windows
  end
  #--------------------------------------------------------------------------
  # ● （覆盖）判定是否所有窗口已全部关闭
  #--------------------------------------------------------------------------
  def all_close?
    close?
  end
  #--------------------------------------------------------------------------
  # ● 更新纤程
  #--------------------------------------------------------------------------
  def update_fiber
    eagle_update_before_fiber
    if @fiber
      @fiber.resume
    elsif self.openness >= 255 && !@fin
      @fiber = Fiber.new { fiber_main }
      @fiber.resume
    end
    eagle_update_after_fiber
  end
  #--------------------------------------------------------------------------
  # ● 处理纤程的主逻辑
  #--------------------------------------------------------------------------
  def fiber_main
    eagle_set_wh # 由于pause精灵需要去除，增加更新宽高
    loop do
      Fiber.yield
      break if @fin
    end
    close_and_wait
    @fiber = nil
  end
  #--------------------------------------------------------------------------
  # ○ 关闭对话框
  #--------------------------------------------------------------------------
  def close_clone
    @fin = true
  end
end

#=============================================================================
# ○ 姓名框窗口
#=============================================================================
class Window_EagleMsgName < Window_Base
  #--------------------------------------------------------------------------
  # ● 初始化对象
  #--------------------------------------------------------------------------
  def initialize(window_msg)
    bind_window(window_msg)
    super(0, 0, 32, 32)
    self.openness = 0
  end
  #--------------------------------------------------------------------------
  # ● 绑定对话框
  #--------------------------------------------------------------------------
  def bind_window(window)
    @window_msg = window
  end
  #--------------------------------------------------------------------------
  # ● 姓名参数
  #--------------------------------------------------------------------------
  def name_params
    @window_msg.name_params
  end
  #--------------------------------------------------------------------------
  # ● 获取行高
  #--------------------------------------------------------------------------
  def line_height
    @window_msg.font_params[:size]
  end
  #--------------------------------------------------------------------------
  # ● 重绘
  #--------------------------------------------------------------------------
  def reset
    t = all_text
    w, h = MESSAGE_EX.calculate_text_wh(@window_msg.contents, t)
    h = [h, @window_msg.font_params[:size]].max
    move(0, 0, w + standard_padding * 2, h + standard_padding * 2)
    create_contents

    MESSAGE_EX.apply_font_params(contents.font, @window_msg.font_params)
    draw_text_ex(0, 0, t)

    skin = @window_msg.get_cur_windowskin_index(name_params[:skin])
    self.windowskin = MESSAGE_EX.windowskin(skin)
    self.opacity = name_params[:opa]
    self.back_opacity = name_params[:opa]
    self.contents_opacity = 255
    self.openness = 0
    self.show
  end
  #--------------------------------------------------------------------------
  # ● 获取全部文本
  #--------------------------------------------------------------------------
  def all_text
    t = MESSAGE_EX.get_name_prefix + name_params[:name]
    t.gsub!(/<(.*?)>/) { "[" + $1 + "]" }
    t = @window_msg.convert_escape_characters(t)
    t
  end
end

#=============================================================================
# ○ 等待按键的精灵
#=============================================================================
class Sprite_EaglePauseTag < Sprite
  #--------------------------------------------------------------------------
  # ● 初始化对象
  #--------------------------------------------------------------------------
  def initialize(window_bind)
    super(nil)
    bind_window(window_bind)
    @type_source = 0 # 记录当前源位图的类型（见module中对应【设置】）
    @type_pos = 0 # 记录当前相对于对话框的位置类型
    @last_chara = nil
    @last_pause_index = nil
    init_auto_countdown
    reset
    hide
  end
  #--------------------------------------------------------------------------
  # ● 绑定window
  #--------------------------------------------------------------------------
  def bind_window(window_bind)
    @window_bind = window_bind
  end
  #--------------------------------------------------------------------------
  # ● 释放
  #--------------------------------------------------------------------------
  def dispose
    @sprite_auto_countdown.bitmap.dispose if @sprite_auto_countdown.bitmap
    @sprite_auto_countdown.dispose
    @s_bitmap.dispose
    self.bitmap.dispose
    super
  end
  #--------------------------------------------------------------------------
  # ● 获取参数组
  #--------------------------------------------------------------------------
  def params
    @window_bind.pause_params
  end
  #--------------------------------------------------------------------------
  # ● 绑定文末精灵
  #--------------------------------------------------------------------------
  def bind_last_chara(sprite_chara)
    @last_chara = sprite_chara
    reset_position
  end
  #--------------------------------------------------------------------------
  # ● 重置
  #--------------------------------------------------------------------------
  def reset
    reset_source if @last_pause_index != params[:pause]
    reset_bitmap
  end
  #--------------------------------------------------------------------------
  # ● 重置源位图
  #--------------------------------------------------------------------------
  def reset_source
    @s_bitmap.dispose if @s_bitmap
    @last_pause_index = params[:pause]
    _params = MESSAGE_EX.pause_params(@last_pause_index)
    _bitmap = Cache.system(_params[0])
    _rect = _params[1].nil? ? _bitmap.rect : _params[1]
    @s_bitmap_row = _params[2] # 源位图中一行中帧数目
    @s_bitmap_col = _params[3] # 源位图中一列中帧数目
    @s_bitmap_n = @s_bitmap_row * @s_bitmap_col # 总帧数

    @s_bitmap = Bitmap.new(_rect.width, _rect.height)
    @s_bitmap.blt(0, 0, _bitmap, _rect)
    @s_rect = Rect.new(0, 0, @s_bitmap.width / @s_bitmap_row,
      @s_bitmap.height / @s_bitmap_col)

    self.bitmap.dispose if self.bitmap
    self.bitmap = Bitmap.new(@s_rect.width, @s_rect.height)
    @index = 0 # 当前index
  end
  #--------------------------------------------------------------------------
  # ● 重绘位图
  #--------------------------------------------------------------------------
  def reset_bitmap
    self.bitmap.clear
    @s_rect.x = (@index % @s_bitmap_row) * @s_rect.width
    @s_rect.y = (@index / @s_bitmap_row) * @s_rect.height
    self.bitmap.blt(0, 0, @s_bitmap, @s_rect)
    @count = 0
  end
  #--------------------------------------------------------------------------
  # ● 更新位置
  #--------------------------------------------------------------------------
  def reset_position
    self.viewport = nil
    if params[:do] > 0
      MESSAGE_EX.reset_xy_dorigin(self, @window_bind, params[:do])
    elsif @last_chara
      self.viewport = @window_bind.eagle_chara_viewport
      self.x = @last_chara._x + @last_chara.width - @window_bind.eagle_charas_ox
      self.y = @last_chara._y + @last_chara.height/2 - @window_bind.eagle_charas_oy
    else
      self.x = @window_bind.eagle_charas_x0
      self.y = @window_bind.eagle_charas_y0
    end
    self.x += params[:dx]
    self.y += params[:dy]
    MESSAGE_EX.reset_xy_origin(self, params[:o])
    reset_auto_countdown_position
  end
  #--------------------------------------------------------------------------
  # ● 更新
  #--------------------------------------------------------------------------
  def update
    super
    update_index
    reset_position if self.viewport && @last_chara
  end
  #--------------------------------------------------------------------------
  # ● 更新帧动画
  #--------------------------------------------------------------------------
  def update_index
    return if (@count += 1) < params[:t]
    @index = (@index + 1) % @s_bitmap_n
    reset_bitmap
  end
  #--------------------------------------------------------------------------
  # ● 显示
  #--------------------------------------------------------------------------
  def show
    return if params[:v] == 0
    reset_position
    @sprite_auto_countdown.visible = true
    self.visible = true
    self
  end
  #--------------------------------------------------------------------------
  # ● 隐藏
  #--------------------------------------------------------------------------
  def hide
    @sprite_auto_countdown.visible = false
    self.visible = false
    self
  end
  #--------------------------------------------------------------------------
  # ● 初始化自动倒计时
  #--------------------------------------------------------------------------
  def init_auto_countdown
    @auto_countdown_max = 0
    @sprite_auto_countdown = Sprite.new
    @sprite_auto_countdown.bitmap = Bitmap.new(13, 13)
  end
  #--------------------------------------------------------------------------
  # ● 重置自动倒计时
  #--------------------------------------------------------------------------
  def reset_auto_countdown_position
    MESSAGE_EX.reset_xy_dorigin(@sprite_auto_countdown, @window_bind, 3)
    @sprite_auto_countdown.x -= @sprite_auto_countdown.width
    @sprite_auto_countdown.y -= @sprite_auto_countdown.height
    @sprite_auto_countdown.z = self.z + 1
  end
  #--------------------------------------------------------------------------
  # ● 重绘自动倒计时
  #--------------------------------------------------------------------------
  def redraw_auto_countdown(cd)
    return if !$imported["EAGLE-UtilsDrawing"]
    @sprite_auto_countdown.bitmap.clear
    a2 = 360 - (360.0 * cd / @window_bind.game_message.auto_t).to_i
    [[4,4],[5,5],[6,6],[5,7],[4,8],
     [6,3],[7,4],[8,5],[9,6],[8,7],[7,8],[6,9]].each do |xy|
      @sprite_auto_countdown.bitmap.set_pixel(xy[0], xy[1], Color.new(255,255,255))
    end
    r = 6
    EAGLE.Arc(@sprite_auto_countdown.bitmap,r,r, r, 0,a2,false,Color.new(255,255,255,250))
  end
end

#==============================================================================
# ○ 文字池（用于更新需要移出的文字精灵）
#==============================================================================
module MESSAGE_EX
  #--------------------------------------------------------------------------
  # ● 重置
  #--------------------------------------------------------------------------
  def self.charapool_reset
    @pool_charas ||= []
    @pool_charas.each { |s| s.dispose }
    @pool_charas.clear
  end
  #--------------------------------------------------------------------------
  # ● 更新
  #--------------------------------------------------------------------------
  def self.charapool_update
    @pool_charas.each { |s| s.update if !s.disposed? && !s.finish? }
  end
  #--------------------------------------------------------------------------
  # ● 放入文字池中
  #--------------------------------------------------------------------------
  def self.charapool_push(s)
    return if s.disposed?
    return @pool_charas.unshift(s) if s.finish?
    @pool_charas.push(s)
  end
  #--------------------------------------------------------------------------
  # ● 获取一个可用的精灵
  #--------------------------------------------------------------------------
  def self.charapool_new(window, font, x,y,w,h, viewport)
    s = nil
    while true
      s = @pool_charas.shift
      break if s.nil?
      next if s.disposed?
      if !s.finish?
        @pool_charas.unshift(s)
        break s = nil
      end
      break
    end
    return Sprite_EagleCharacter.new(window, font, x,y,w,h, viewport) if s.nil?
    s.bind_viewport(viewport)
    s.bind_window(window)
    s.bind_font(font)
    s.reset(x,y,w,h)
    s
  end
end
#=============================================================================
# ○ Scene_Base
#=============================================================================
class Scene_Base
  #--------------------------------------------------------------------------
  # ● 开始处理
  #--------------------------------------------------------------------------
  alias eagle_charapool_start start
  def start
    MESSAGE_EX.charapool_reset
    eagle_charapool_start
  end
  #--------------------------------------------------------------------------
  # ● 更新画面（基础）
  #--------------------------------------------------------------------------
  alias eagle_charapool_update_basic update_basic
  def update_basic
    eagle_charapool_update_basic
    MESSAGE_EX.charapool_update
  end
  #--------------------------------------------------------------------------
  # ● 结束处理
  #--------------------------------------------------------------------------
  alias eagle_charapool_terminate terminate
  def terminate
    eagle_charapool_terminate
    MESSAGE_EX.charapool_reset
  end
end
#=============================================================================
# ○ 文字绘制类
#=============================================================================
class Font_EagleCharacter
  #--------------------------------------------------------------------------
  # ● 初始化
  #--------------------------------------------------------------------------
  def initialize(font_params)
    @params = font_params.dup
  end
  #--------------------------------------------------------------------------
  # ● 设置参数
  #--------------------------------------------------------------------------
  def set_param(sym, value)
    @params[sym] = value
  end
  #--------------------------------------------------------------------------
  # ● 获取文字颜色
  #     n : 文字颜色编号（0..31）
  #--------------------------------------------------------------------------
  def text_color(n)
    MESSAGE_EX.windowskin(@params[:skin]).get_pixel(64 + (n % 8) * 8, 96 + (n / 8) * 8)
  end
  #--------------------------------------------------------------------------
  # ● 获取渐变色数组
  #--------------------------------------------------------------------------
  def get_gradient_color(str)
    result = []
    param = str.downcase
    while(param != "")
      param.slice!(/\D+/)
      result.push((param.slice!(/\d+/)).to_i)
    end
    result
  end
  #--------------------------------------------------------------------------
  # ● 执行文字绘制
  #--------------------------------------------------------------------------
  def draw(bitmap, x, y, w, h, c, ali = 0)
    bitmap.font.color = text_color(@params[:c])
    MESSAGE_EX.apply_font_params(bitmap.font, @params)

    draw_param_p(bitmap, x, y, w, h) if @params[:p]
    draw_param_l(bitmap, x, y, w, h, c, ali) if @params[:l]
    if defined?(Sion_GradientText) && @params[:ex_cg] && @params[:ex_cg] != ''
      grad_cs = get_gradient_color(@params[:ex_cg])
      Sion_GradientText.draw_text(bitmap,x,y,w*2,h,c,ali,grad_cs)
    else
      bitmap.draw_text(x, y, w*2, h, c, ali)
    end
    draw_param_d(bitmap) if @params[:d]
    draw_param_u(bitmap) if @params[:u]
  end
  #--------------------------------------------------------------------------
  # ● 执行图标绘制
  #--------------------------------------------------------------------------
  def draw_icon(bitmap, x, y, icon_index)
    draw_param_p(bitmap, x, y, 24, 24) if @params[:p]
    draw_param_l_rect(bitmap, x, y, 24, 24) if @params[:l]
    _bitmap = Cache.system("Iconset")
    rect = Rect.new(icon_index % 16 * 24, icon_index / 16 * 24, 24, 24)
    bitmap.blt(x, y, _bitmap, rect, 255)
    draw_param_d(bitmap) if @params[:d]
    draw_param_u(bitmap) if @params[:u]
  end
  #--------------------------------------------------------------------------
  # ● 绘制底纹
  #--------------------------------------------------------------------------
  def draw_param_p(bitmap, x, y, w, h)
    color = text_color(@params[:pc])
    case @params[:p]
    when 1 # 边框
      bitmap.fill_rect(x, y, w, h, color)
      bitmap.clear_rect(x+1, y+1, w-2, h-2)
    when 2 # 纯色方块
      bitmap.fill_rect(x, y, w, h, color)
    end
  end
  #--------------------------------------------------------------------------
  # ● 绘制外发光
  #--------------------------------------------------------------------------
  def draw_param_l(bitmap, x, y, w, h, c, ali)
    bitmap.font.outline = false
    bitmap.font.shadow = false
    color = bitmap.font.color.dup
    bitmap.font.color = text_color(@params[:lc])
    @params[:lp].times do
      bitmap.draw_text(x, y, w+4, h, c, ali)
      bitmap.blur
    end
    bitmap.font.color = color
  end
  def draw_param_l_rect(bitmap, x, y, w, h)
    c = text_color(@params[:lc])
    bitmap.fill_rect(x, y, w, h, c)
    bitmap.blur
  end
  #--------------------------------------------------------------------------
  # ● 绘制删除线
  #--------------------------------------------------------------------------
  def draw_param_d(bitmap)
    c = text_color(@params[:dc])
    bitmap.fill_rect(0, bitmap.height/2 - 1, bitmap.width, 1, c)
  end
  #--------------------------------------------------------------------------
  # ● 绘制下划线
  #--------------------------------------------------------------------------
  def draw_param_u(bitmap)
    c = text_color(@params[:uc])
    bitmap.fill_rect(0, bitmap.height - 1, bitmap.width, 1, c)
  end
end
#=============================================================================
# ○ 单个文字的精灵
#=============================================================================
class Sprite_EagleCharacter < Sprite
  attr_reader :origin_x, :origin_y, :_x, :_y, :eagle_font
  #--------------------------------------------------------------------------
  # ● 初始化对象
  #  window_bind ：所绑定的显示窗口，需要有以下方法
  #    .z 返回窗口的z值（当前文字精灵将高于该值）
  #    .eagle_charas_x0 .eagle_charas_y0 返回文字显示区域的左上角坐标（屏幕坐标）
  #    .eagle_charas_ox .eagle_charas_oy 返回文字显示区域的显示原点（文字区域坐标）
  #    .eagle_charas_max_h 返回文字区域的最大高度
  #  font_bind ：所绑定的字符绘制类 Font_EagleCharacter 的对象
  #--------------------------------------------------------------------------
  def initialize(window_bind, font_bind, x, y, w, h, viewport = nil)
    super(viewport)
    bind_viewport(viewport)
    bind_window(window_bind)
    bind_font(font_bind)
    reset(x, y, w, h)
  end
  #--------------------------------------------------------------------------
  # ● 文字中心点是否在视图内部？
  #--------------------------------------------------------------------------
  def in_viewport?
    return true if self.viewport.nil?
    x_ = self.x - self.ox + self.width / 2
    y_ = self.y - self.oy + self.height / 2
    return false if x_ < 0 || x_ > self.viewport.rect.width
    return false if y_ < 0 || y_ > self.viewport.rect.height
    return true
  end
  #--------------------------------------------------------------------------
  # ● 设置绑定的视图
  #--------------------------------------------------------------------------
  def bind_viewport(vp)
    @viewport_bind = vp
    self.viewport = vp
  end
  #--------------------------------------------------------------------------
  # ● 设置绑定的窗口
  #--------------------------------------------------------------------------
  def bind_window(window_bind)
    @window_bind = window_bind
    self.z = @window_bind.z + 1
  end
  #--------------------------------------------------------------------------
  # ● 设置绑定的绘制参数
  #--------------------------------------------------------------------------
  def bind_font(font_bind)
    @eagle_font = font_bind
  end
  #--------------------------------------------------------------------------
  # ● 取消绑定视图
  #--------------------------------------------------------------------------
  def unbind_viewport
    self.viewport = nil
  end
  #--------------------------------------------------------------------------
  # ● 重新绑定视图
  #--------------------------------------------------------------------------
  def rebind_viewport
    self.viewport = @viewport_bind
  end
  #--------------------------------------------------------------------------
  # ● 释放
  #--------------------------------------------------------------------------
  def dispose
    @bitmaps.each { |b| b.dispose }; @bitmaps.clear
    self.bitmap.dispose if !self.bitmap.disposed?
    super
  end
  #--------------------------------------------------------------------------
  # ● 重置
  #--------------------------------------------------------------------------
  def reset(x, y, w, h)
    self.bitmap.dispose if self.bitmap
    self.bitmap = Bitmap.new(w, h)
    # (x0,y0) 当前的文字显示区域的左上角的屏幕坐标
    @x0 = 0; @y0 = 0
    # (_ox,_oy) 当前的文字显示区域的显示原点位置（对话框内部坐标系）
    @_ox = 0; @_oy = 0
    # 左对齐时，本文字的显示位置（存储为标准位置，方便对齐）
    @origin_x = x; @origin_y = y
    # 设置本文字的显示位置
    reset_xy(x, y)
    reset_oxy(7)
    # 动态移动时的偏移值
    @dx = 0; @dy = 0
    @flag_move = nil # 在移动中？
    # 重置特效参数
    @effects = {} # effect_sym => param_string
    @params = {} # effect_sym => param_hash
    @bitmaps ||= [] # 备用位图
    @bitmaps.each { |b| b.dispose }
    # 重置精灵参数
    self.src_rect = Rect.new(0,0,self.width,self.height)
    self.zoom_x = self.zoom_y = 1.0
    self.angle = 0
    self.wave_amp    = 0
    self.wave_length = 0
    self.wave_speed  = 0
    self.wave_phase  = 0
    self.mirror = false
    self.blend_type = 0
    self.opacity = 255
    self.visible = true
  end
  #--------------------------------------------------------------------------
  # ● 设置相对偏移值（以对话框中的文字显示区域的屏幕左上角为原点）
  #--------------------------------------------------------------------------
  def reset_xy(x, y)
    @_x = x # 存储文字相对对话框左上角的显示位置
    @_y = y
  end
  #--------------------------------------------------------------------------
  # ● 设置显示原点
  #--------------------------------------------------------------------------
  def reset_oxy(o)
    MESSAGE_EX.reset_sprite_oxy(self, o)
  end
  #--------------------------------------------------------------------------
  # ● 结束
  #--------------------------------------------------------------------------
  def finish
    self.opacity = 0
    bind_viewport(nil)
    @window_bind = nil # 取消窗口的绑定
  end
  #--------------------------------------------------------------------------
  # ● 结束使命？
  #--------------------------------------------------------------------------
  def finish?
    self.opacity == 0
  end
  #--------------------------------------------------------------------------
  # ● 更新
  #--------------------------------------------------------------------------
  def update
    super
    update_position
    return move_update(@flag_move) if @flag_move
    update_effects if !@effects.empty?
  end
  #--------------------------------------------------------------------------
  # ● 更新位置
  #--------------------------------------------------------------------------
  def update_position
    self.x = @_x + @dx + self.ox
    self.y = @_y + @dy + self.oy
    if @window_bind
      @x0 = @window_bind.eagle_charas_x0
      @y0 = @window_bind.eagle_charas_y0
      if self.viewport
        @_ox = @window_bind.eagle_charas_ox
        @_oy = @window_bind.eagle_charas_oy
        self.x -= self.viewport.rect.x
        self.y -= self.viewport.rect.y
      end
    end
    self.x += (@x0 - @_ox)
    self.y += (@y0 - @_oy)
  end
  #--------------------------------------------------------------------------
  # ● 更新移动
  #--------------------------------------------------------------------------
  def move_update(sym = :cin) # 只有移动结束时，才进行其他更新
    params = @params[sym]
    params[:tc] -= 1
    (params[:vxc] = 0; @dx += params[:vx]) if (params[:vxc] += 1) == params[:vxt]
    (params[:vyc] = 0; @dy += params[:vy]) if (params[:vyc] += 1) == params[:vyt]
    (params[:vzc] = 0;@_zoom += params[:vz]) if (params[:vzc] += 1) == params[:vzt]
    if (params[:rxc] += 1) == params[:rxt]
      params[:rxc] = 0
      self.src_rect.x += params[:rx]
    end
    if (params[:ryc] += 1) == params[:ryt]
      params[:ryc] = 0
      self.src_rect.y += params[:ry]
    end
    self.zoom_x = self.zoom_y = 1.0 + @_zoom/100.0
    self.angle += params[:va]
    self.opacity += params[:vo]
    move_end(sym) if params[:tc] == 0
  end
  def move_end(sym = :cin)
    rebind_viewport
    reset_oxy(7)
    if sym == :cin
      self.zoom_x = self.zoom_y = 1.0
      self.opacity = 255
      update_position
    elsif sym == :cout
      finish
    end
    @flag_move = nil
  end
  #--------------------------------------------------------------------------
  # ● 解析参数
  #--------------------------------------------------------------------------
  def parse_param(params, param_s, default_type = "default")
    MESSAGE_EX.parse_param(params, param_s, default_type)
  end
  #--------------------------------------------------------------------------
  # ● 初始化特效的默认参数
  #--------------------------------------------------------------------------
  def init_effect_params(sym)
    @params[sym] = MESSAGE_EX.get_default_params(sym).dup # 初始化
  end
  #--------------------------------------------------------------------------
  # ● 开始特效（整合）
  #--------------------------------------------------------------------------
  def start_effects(effects)
    @effects = effects.dup # code_symbol => param_string
    @effects.each { |sym, param_s|
      m = ("start_effect_" + sym.to_s).to_sym
      init_effect_params(sym)
      method(m).call(@params[sym], param_s.dup) if respond_to?(m)
    }
  end
  # def start_effect_code(param)  code → 转义符
  # end
  #--------------------------------------------------------------------------
  # ● 更新特效（整合）
  #--------------------------------------------------------------------------
  def update_effects
    @effects.each { |sym, param|
      m = ("update_effect_" + sym.to_s).to_sym
      method(m).call(@params[sym]) if respond_to?(m)
    }
  end
  # def update_effect_code(param)  code → 转义符
  # end
  #--------------------------------------------------------------------------
  # ● 移入
  #--------------------------------------------------------------------------
  def start_effect_cin(params, param_s, flag_move_in = true)
    parse_param(params, param_s)
    params[:t] = 1 if params[:t] < 1
    params[:vxc] = 0; params[:vyc] = 0; params[:vzc] = 0 # 计数用
    params[:vxt] = 1 if params[:vxt] < 1
    params[:vyt] = 1 if params[:vyt] < 1
    params[:vzt] = 1 if params[:vzt] < 1
    rand_cin(params, param_s) if params[:r] != 0
    params[:vo] ||= 255 / params[:t] # 移入时每帧不透明度增量
    params[:vo] = [params[:vo], 1].max
    params[:rxc] = 0; params[:ryc] = 0
    params[:rxt] = 1 if params[:rxt] < 1
    params[:ryt] = 1 if params[:ryt] < 1
    move_in if flag_move_in
  end
  #--------------------------------------------------------------------------
  # ● 随机移入
  #--------------------------------------------------------------------------
  RAND_V = lambda { |v| rand(v * 2 + 1) - v }
  def rand_cin(params, param_s)
    params[:t] = rand(params[:t]) + 1
    params[:vx] = RAND_V.call(params[:vx])
    params[:vxt] = rand(params[:vxt]) + 1
    params[:vy] = RAND_V.call(params[:vy])
    params[:vyt] = rand(params[:vyt]) + 1
    params[:vz] = RAND_V.call(params[:vz])
    params[:vzt] = rand(params[:vzt]) + 1
    params[:va] = RAND_V.call(params[:va])
  end
  #--------------------------------------------------------------------------
  # ● 执行移入
  #--------------------------------------------------------------------------
  def move_in
    params = @params[:cin]
    return if params.nil?
    unbind_viewport
    @dx = -(params[:t]/params[:vxt]) * params[:vx]
    @dy = -(params[:t]/params[:vyt]) * params[:vy]
    @_zoom = -(params[:t]/params[:vzt]) * params[:vz]
    self.angle = -params[:t] * params[:va]
    self.src_rect.x = -(params[:t]/params[:rxt]) * params[:rx]
    self.src_rect.y = -(params[:t]/params[:ryt]) * params[:ry]
    self.opacity = 0
    self.zoom_x = self.zoom_y = 1.0 + @_zoom/100.0
    reset_oxy(5)
    params[:tc] = params[:t]
    @flag_move = :cin
  end
  #--------------------------------------------------------------------------
  # ● 移出
  #--------------------------------------------------------------------------
  def start_effect_cout(params, param_s)
    start_effect_cin(params, param_s, false)
    params[:vo] *= -1
  end
  #--------------------------------------------------------------------------
  # ● 执行移出
  #--------------------------------------------------------------------------
  def move_out
    if !in_viewport? # 若精灵在视图外，则直接结束
      finish
    else
      bind_viewport(nil)
      if !(@params[:cout].nil? || @params[:cout].empty?)
        move_out_cout(@params[:cout])
      elsif !@params[:uout].nil?
        move_out_uout(@params[:uout])
      else
        finish
      end
    end
    MESSAGE_EX.charapool_push(self) # 由文字池接管
  end
  #--------------------------------------------------------------------------
  # ● 执行默认移出
  #--------------------------------------------------------------------------
  def move_out_cout(params)
    @dx = @dy = @_zoom = 0
    reset_oxy(5)
    params[:tc] = params[:t]
    @flag_move = :cout
    update_position # 更新一次位置
    @window_bind = nil
  end
  #--------------------------------------------------------------------------
  # ● 消散移出
  #--------------------------------------------------------------------------
  def start_effect_uout(params, param_s)
    parse_param(params, param_s)
    params[:dir] = MESSAGE_EX::CU_PARAM_DIR[ params[:dir] ]
    params[:s] = MESSAGE_EX::CU_PARAM_S[ params[:s] ]
  end
  def move_out_uout(parmas)
    Unravel_Bitmap.new(self.x, self.y, self.bitmap.clone, 0, 0, self.width,
      self.height, params[:n], params[:d], params[:o], params[:dir], params[:s])
    finish
  end
  #--------------------------------------------------------------------------
  # ● 正弦扭曲特效
  #--------------------------------------------------------------------------
  def start_effect_csin(params, param_s)
    parse_param(params, param_s)
    self.wave_amp    = params[:a]
    self.wave_length = params[:l]
    self.wave_speed  = params[:s]
    self.wave_phase  = params[:p]
  end
  #--------------------------------------------------------------------------
  # ● 波浪特效
  #--------------------------------------------------------------------------
  def start_effect_cwave(params, param_s)
    params[:tc] = 0  # 移动计数用初值（一次性）
    parse_param(params, param_s)
  end
  def update_effect_cwave(params)
    return if (params[:tc] += 1) < params[:t]
    params[:tc] = 0
    @dy += params[:vy]
    params[:vy] *= -1 if @dy < -params[:h] || @dy > params[:h]
  end
  #--------------------------------------------------------------------------
  # ● 抖动特效
  #--------------------------------------------------------------------------
  def start_effect_cshake(params, param_s)
    params[:vxc] = 0  # 移动计数用初值（一次性）
    params[:vyc] = 0  # 移动计数用初值（一次性）
    parse_param(params, param_s)
    params[:vx] = rand(2) * 2 - 1 if params[:vx] == 0
    params[:vy] = rand(2) * 2 - 1 if params[:vy] == 0
  end
  def update_effect_cshake(params)
    if (params[:vxc] += 1) > params[:vxt]
      params[:vxc] = 0
      @dx += params[:vx]
      params[:vx] *= -1 if @dx < -params[:l] || @dx > params[:r]
    end
    if (params[:vyc] += 1) > params[:vyt]
      params[:vyc] = 0
      @dy += params[:vy]
      params[:vy] *= -1 if @dy < -params[:u] || @dy > params[:d]
    end
  end
  #--------------------------------------------------------------------------
  # ● 摇摆特效
  #--------------------------------------------------------------------------
  def start_effect_cswing(params, param_s)
    params[:ac] = 0 # 当前偏移角度和
    params[:tc] = 0
    parse_param(params, param_s)
    params[:d] = rand(2) * 2 - 1 if params[:d] == 0
    reset_oxy(params[:o])
    self.angle = 0
  end
  def update_effect_cswing(params)
    return if (params[:tc] -= 1) > 0
    params[:tc] = params[:t]
    params[:ac] += params[:d]
    if params[:ac].abs > params[:a]
      params[:ac] = params[:a] * (params[:ac] > 0 ? 1 : -1)
      params[:d] *= -1
    end
    self.angle = params[:ac]
  end
  #--------------------------------------------------------------------------
  # ● 缩放特效
  #--------------------------------------------------------------------------
  def start_effect_czoom(params, param_s)
    params[:tc] = 0 # 计时
    parse_param(params, param_s)
    params[:zoom_x] = 100 # 初始的总缩放量
    params[:zoom_y] = 100
    reset_oxy(params[:o])
  end
  def update_effect_czoom(params)
    return if (params[:tc] -= 1) > 0
    params[:tc] = params[:t]
    if params[:dx] != 0
      params[:zoom_x] += params[:dx]
      params[:dx] *= -1 if params[:zoom_x] > params[:max] || params[:zoom_x] < params[:min]
      self.zoom_x = params[:zoom_x] * 1.0 / 100
    end
    if params[:dy] != 0
      params[:zoom_y] += params[:dy]
      params[:dy] *= -1 if params[:zoom_y] > params[:max] || params[:zoom_y] < params[:min]
      self.zoom_y = params[:zoom_y] * 1.0 / 100
    end
  end
  #--------------------------------------------------------------------------
  # ● 闪烁特效
  #--------------------------------------------------------------------------
  def start_effect_cflash(params, param_s)
    params[:tc] = 0  # 闪烁后的等待时间计数
    parse_param(params, param_s)
    params[:color] = Color.new(params[:r], params[:g], params[:b], params[:a])
  end
  def update_effect_cflash(params)
    return if (params[:tc] -= 1) > 0
    params[:tc] = params[:t] + params[:d]
    self.flash(params[:color], params[:d])
  end
  #--------------------------------------------------------------------------
  # ● 镜像特效
  #--------------------------------------------------------------------------
  def start_effect_cmirror(params, param_s)
    params[:b]  = '0'
    parse_param(params, param_s, :b)
    self.mirror = (params[:b] == '0' ? false : true)
  end
  #--------------------------------------------------------------------------
  # ● 消散特效
  #--------------------------------------------------------------------------
  def start_effect_cu(params, param_s)
    params[:t_c] = 0 # 间隔计数
    parse_param(params, param_s)
    params[:dir] = MESSAGE_EX::CU_PARAM_DIR[ params[:dir] ]
    params[:s] = MESSAGE_EX::CU_PARAM_S[ params[:s] ]
  end
  def update_effect_cu(params)
    return if !in_viewport?
    return if (params[:t_c] += 1) < params[:t]
    params[:t_c] = 0
    _x = self.x; _y = self.y
    if(self.viewport)
      _x += self.viewport.rect.x; _y += self.viewport.rect.y
    end
    Unravel_Bitmap.new(_x, _y, self.bitmap.clone, 0, 0, self.width,
      self.height, params[:n], params[:d], params[:o], params[:dir], params[:s])
  end
  #--------------------------------------------------------------------------
  # ● 位图切换特效
  #--------------------------------------------------------------------------
  def start_effect_ctog(params, param_s)
    parse_param(params, param_s)
    @bitmaps.push(self.bitmap)
    charas = MESSAGE_EX.get_tog_charas(params[:i], params[:n])
    charas.each do |c|
      s = Bitmap.new(self.width, self.height)
      @eagle_font.draw(s, 0, 0, s.width*2, s.height, c, 0)
      @bitmaps.push(s)
    end
    params[:i_cur] = 0
    params[:i_max] = @bitmaps.size
    params[:tc] = 0
  end
  def update_effect_ctog(params)
    return if (params[:tc] += 1) < params[:t]
    params[:tc] = 0
    if(params[:r] > 0)
      params[:i_cur] = rand(params[:i_max])
    else
      params[:i_cur] += 1
      params[:i_cur] %= params[:i_max]
    end
    self.bitmap = @bitmaps[params[:i_cur]]
  end
end
